{"title": "PDF", "author": "PDF", "url": "http://biblioteca.usbbog.edu.co:8080/Biblioteca/BDigital/72724.pdf", "hostname": "PDF", "description": "PDF", "sitename": "PDF", "date": "PDF", "cleaned_text": "RAE 1. TIPO DE DOCUMENTO: TRABAJO DE GRADO 2. TITULO: DESARROLLO DE UN CONTROLADOR MIDI NO CONVENCIONAL, IMPLEMENTADO EN UN SISTEMA EMBEBIDO, UTILIZANDO EL KINECT. 3. AUTOR: ANDR\u00c9 S CABALLERO PAZ 4. LUGAR: BOGOT \u00c1 5. FECHA: ENERO 17 DE 2013 6. PALABRAS CLAVES: SISTEMAS EMBEBI DOS, DSP, LINUX, UBUNTU, PURE DATA, KINECT, INNOVACI\u00d3N. 7. DESCRIPCION DEL TRABAJO: El documento presenta el desarrollo de un controlador MIDI no convencional implementado en un Sistema Embebido utilizando el Kinect. El dispositivo permite utilizar el protoco lo MIDI para controlar hardware y/o software remoto v\u00eda WiFi por medio de la captura de movimientos. Con la utilizaci\u00f3n de este tipo herramientas tecnol\u00f3gicas se puede construir controladores no convencionales aplicados a la ingenier\u00eda de sonido, integrabl es a diferentes redes de comunicaci\u00f3n de forma pr\u00e1ctica, eficaz e innovadora. 8. LINEA DE INVESTIGACION: AN\u00c1LISIS Y PROCESAMIENTO DE SE\u00d1ALES . 9. FUENTES CONSULTADAS : 1. Abbott, Doug. Linux for Embedded and Real -Time Application. Newnes. 2003 . 2. Webb, Jarrett - Ashley, James. Beginning Kinect Programming with the Microsoft Kinect SDK. Apress, 2012 10. CONTENIDOS: INTRODUCCI\u00d3N, PLANTEAMIENTO DEL PROBLEMA, METODOLOG\u00cdA, L\u00cdNEA D E INVESTIGACI\u00d3N, MARCO TE\u00d3RICO, DESARROLLO INGENIERIL, AN\u00c1LISIS DE RESULTADOS, CONCLUSIONES , PRODUCTOS, RECOMENDACIONES, BIBLIOGRAF\u00cdA, GLOSARIO, ANEXOS . 11. METODOLOGIA: EMP\u00cdRICO -ANAL\u00cdTICA 12. CONCLUSIONES: El docum ento presenta el dise\u00f1o y desarrollo de un controlador MIDI no convencional utilizando el Kinect, implementado en el Sistema Embebido Pandaboard ES. En el S.E. se implement\u00f3 la distribuci\u00f3n de Ubuntu, la cual permite la instalaci\u00f3n y configuraci\u00f3n de los p rogramas y servicios con los cuales se realiza la transmisi\u00f3n de los datos en protocolo MIDI a un computador fijo adquiriendo los datos a partir de movimientos capturados por el Kinect. DESARROLLO DE UN CONTROLADOR MIDI NO CONVENCIONAL, IMPL EMENTADO EN UN SISTEMA EMBEBIDO, UTILIZANDO EL KINECT. ANDR\u00c9S CABALLERO PAZ UNIVERSIDAD DE SAN BUENAVENTURA FACULTAD DE INGENIER\u00cdA INGENIER\u00cdA DE SONIDO BOGOT\u00c1 2012 DESARROLLO DE UN CONTROLADOR MIDI NO CONVENCIONAL, IMPLEMENTADO EN UN SIST EMA EMBEBIDO, UTILIZANDO EL KINECT. ANDR\u00c9S CABALLERO PAZ Trabajo de Grado para optar al t\u00edtulo de Ingeniero de Sonido Director Ing. NELSON FELIPE ROSAS JIM\u00c9NEZ., MSc. UNIVERSIDAD DE SAN BUENAVENTURA FACULTAD DE INGENIER\u00cdA INGENIER\u00cdA DE SO NIDO BOGOT\u00c1 2012 Nota Ciudad y fecha (dd/mes/a\u00f1o) __________,___/____/________ \"A mis padres y a mi hermano, V\u00edctor Andr\u00e9s, Adriana y Felipe\" \"A mi novia, Kelly\" Este trabajo ha sido posible gracias a ellos Agradecimientos A mi profesor y director de tesis Nelson Rosas Jim\u00e9nez, por su apoyo incondicional, confianza y orientaci\u00f3n a lo largo del proyecto. A mis amigos Andr\u00e9s Alonso y Juan Carlos S\u00e1nchez, quienes aportaron directa o indirectamente en est e proceso y estuvieron presentes a lo largo del mismo. A mis compa\u00f1eros de tr abajo y amigos Katherine Garc\u00eda, Nicol\u00e1s Calder\u00f3n , Johanna Gait\u00e1n , Mar\u00eda Fernanda Bosc\u00e1n y Andrea Gualtero, por ser un apoyo a lo largo de la carrera. Por \u00faltimo pero a las pers onas m\u00e1s importantes en mi vida, mis padres V\u00edctor Andr\u00e9s y Adriana, mi hermano Felipe y mi novia Kelly , gracias por su amor, comprensi\u00f3n y paciencia en los momentos m\u00e1s complicados, por hacer parte de mi vida en esta etapa que finaliza. Tabla de C ontenido INTRODUCCI\u00d3N ................................ ................................ ................................ ... 12 1. PLANTEAMIENTO 14 1.1. ANTECEDEN TES ................................ ................................ ..................... 14 1.2. DESCRIPCI\u00d3N Y FORMULACI\u00d3N DEL PROBLEMA ............................. 20 1.3. JUSTIFICACI\u00d3N ................................ ................................ ....................... 20 ........................ 22 2.2. HIP\u00d3TESIS ................................ ................................ ............................... ................................ ................................ ..................... L\u00cdNEA DE INVESTIGACI\u00d3N DE LA UNIVERSIDAD/ SUB -L\u00cdNEA DE LA FACULTAD/ CAMPO TEM\u00c1TICO DEL PROGRAMA ................................ ............ 23 4. MARCO TE\u00d3RICO ................................ ................................ de Cambio de Programa ................................ ...................... 27 4.1.4. Mensaje de Cambio mensajes MIDI por WLAN ................................ .................... 56 5.2.1. Configuraci\u00f3n Router para una Red Local Inal\u00e1mbrica (WLAN) ........ 57 5.2.2. Configuraci\u00f3n de Red en Ubuntu ................................ ....................... 58 5.2.3. Codificaci\u00f3n y env\u00edo de MIDI por UDP/IP Multicast ............................ 60 5.2.4. Implementaci\u00f3n y Pruebas -Kinect 5.4. Implementaci\u00f3n Controlador MIDI Convencional 73 5.4.1. Recepci\u00f3n e 91 ANEXO B: Anexos digitales ................................ ................................ ................... 95 LISTA DE FIGURAS Fig. 1 Controlador MIDI. Fuente: Propia ................................ ................................ 24 Fig. 2 Conexiones protocolo MIDI. Fue nte: Propia ................................ ................ 25 Fig. 3 ................................ ................................ .... 29 Fig. 5 Fotograf\u00eda de grilla de puntos de luz infrarroja emitidos por el Kinect e imagen de profundidad. Fuente: Propia. ................................ ................................ 30 Fig. 6 Fotograf\u00eda de la c\u00e1mara RGB e imagen de profundidad del Kinect. Fuente: Propia ................................ ................................ ................................ [33] ................................ ................................ ........ 33 Fig. 8 Conexi\u00f3n modo ................................ ............................. 34 Fig. 9 Acerca de QmidiNet. Fuente: Propia ................................ ............................ 35 Fig. 10 Sistema Embebido Raspberry Pi [35] ................................ ........................ 36 Fig. 11 Secci\u00f3n de documentaci\u00f3n e informaci\u00f3n de Pure Data. Fuente: Propia .. 38 Fig. 12 Diagrama de bloques Adecuaci\u00f3n S.E. ................................ ...................... 39 Fig. 13 Descripci\u00f3n Desarrollo Controlador MIDI con Convencional ..................... 40 Fig. 14 Descripci\u00f3n proceso instalaci\u00f3n Ubuntu en sistemas embebidos .............. 41 Fig. 15 Arquitectura general de un Sistema de Linux Embebido [39] .................... 42 Fig. 16 Ventana compilaci\u00f3n Ubuntu minimal. Fuente: Propia ............................... 43 Fig. 17 Ventana creaci\u00f3n imagen pre compilada. Fuente: Propia .......................... 45 Fig. 18 Interfaz Gr\u00e1fica Xfce. Fuente: Propia ................................ ......................... 46 Fig. 19 Interfaz Gr\u00e1fica Kde. Fuente: Propia ................................ .......................... 47 Fig. 20 Interfaz Gr\u00e1fica Gnome. Fuente: Propia ................................ .................... 48 Fig. 21 Interfaz Gr\u00e1fica Lxde. Fuente: Propia ................................ ........................ 49 Fig. 22 Interfaz gr\u00e1fica Unity. Propia 50 Fig. 23 Fig. 24 Fig. 25 Pandaboard ES. Fuente: Propia ................................ 55 Fig. 26 Transmisi\u00f3n Mensajes MIDI ................................ ................................ ....... 57 Fig. 27 Implementaci\u00f3n escritorio remoto desde una Tablet. Fuente: Propia ........ 59 Fig. 28 Diagr ama de flujo codificaci\u00f3n y envi\u00f3 MIDI ................................ .............. 60 Fig. 29 Diagrama conexi\u00f3n QmidiNet ................................ ................................ .... 60 Fig. 30 Interfaz de configuraci\u00f3n QmidiNet. Fuente : Propia ................................ .. 61 Fig. 31 Entradas y Salidas MIDI de Ubuntu. Fuente: Propia ................................ .. 61 Fig. 32 Integraci\u00f3n Kinect ...................... Fig. 33 Descripci\u00f3n proceso compilaci\u00f3n Pure Data Extended .............................. 63 Fig. 34 Interfaz gr\u00e1fica principal de Pd Extended. Fuente: Propia ......................... 65 Fig. 35 Ventana de Comando de Compilaci\u00f3n Freenect, con el Kinect conectado a la Pandaboard ES. Fuente: Propia ................................ ................................ ........ 66 Fig. 36 Ejemplo imagen ntroladores Freenect. Fuente: Propia ................................ ................................ ................................ control de PrimeSense [40] ................................ .................. 68 Fig. 38 Ensamble implementado en Pd para la captura de datos en el eje Z y X .. 70 Fig. 39 Secci\u00f3n principal ensamble ................................ ................................ ....... 70 Fig. 40 Secci\u00f3n activaci\u00f3n Gem ................................ ................................ ............. 71 Fig. 41 Secci\u00f3n obtenci\u00f3n datos X y Z ................................ ................................ ... 71 Fig. 42 Configuraci\u00f3n ................................ .......... 72 Fig. 44 Descripci\u00f3n proceso de implementaci\u00f3n y prueba del sistema .................. 73 Fig. 45 Diagrama de bloques recepci\u00f3n y decodificaci\u00f3n ................................ ...... 74 Fig. 46 Recepci\u00f3n de datos MIDI v\u00eda WiFi a MIDI -OX. Fuente: Propia .................. 74 Fig. 47 Recepci\u00f3n de datos MIDI desde V MPK al Kmidimon. Fuente: Propia ....... 75 Fig. 48 Implementaci\u00f3n Controlador MIDI no Convencional en Pandaboard ES. Fuente: Propia ................................ ................................ ................................ ....... FL Studio. Fuente: Propia ................................ ............... 77 Fig. 50 Captura de pantalla de la implementaci\u00f3n en el FL Studio. Fuente: Propia ................................ ................................ ................................ ............................... 77 Fig. 51 Interfaz de captura de los datos del Kinect implementado en Pure Data. Fuente: Propia ................................ ................................ ................................ ....... 78 Fig. 52 Pandaboard ES conectada remotamente a Samsung Galaxy Tab 10.1. Fuente: Propia ................................ ................................ ................................ ....... 91 Fig. 53 Interfaz del editor conexiones de red. Fuente: Propia ................................ 91 Fig. 54 Configuraci\u00f3n de control remoto MIDI de FL Studio. Fuente : Propia ......... 92 Fig. 55 Conexi\u00f3n Pandaboard ES con el Kinect. Fuente: Propia ........................... 92 Fig. 56 Interfaz de usuario de TouchOSC para Samsung G alaxy Tab 10.1. Fuente: Propia ................................ ................................ ................................ .................... Virtual VMPK. Fuente: Propia ................................ ........ 93 Fig. 58 Ensamble de aplicaci\u00f3n TouchOSC. Fuente: Propia ................................ ................................ ................................ .................... 94 Tabla 1 Mensajes MIDI ................................ ................................ .......................... 26 Tabla 2 Comandos Bytes de Estado ................................ ................................ ...... 26 Tabla 3 Comparaci\u00f3n especificaciones sistemas embebidos ................................ 56 RESUMEN El documento presenta el desarrollo de un controlador MIDI no convencion al implementado en un Sistema Embebido utilizando el Kinect. El dispositivo permite utilizar el protocolo MIDI para controlar hardware y/o software remoto v\u00eda WiFi por medio de la captura de movimientos. Con l a utilizaci\u00f3n de este tipo herramientas tecnol\u00f3 gicas se puede construir controladores no convencionales aplicados a la ingenier\u00eda de sonido, integrables a diferentes redes de comunicaci\u00f3n de f orma pr\u00e1ctica , eficaz e innovadora . ABSTRACT The document presents the development of a non -conventional MIDI controller implemented into an embedded system using the Kinect. The device uses the MIDI protocol to control software and/or hardware via WiFi through movement detection. Whit the utilization of this kind of its possible developme nt no - conventional controllers to Sound Engineer, connecting to different network environment and practical and Kinect allows developing such applications in a practical and effective way . 12 INTRODUCCI\u00d3N Los sistemas embebidos son herramient as pr\u00e1ctica s y vers\u00e1til es para la implementaci\u00f3n de proyectos relacionados con la ingenier\u00eda de sonido , los cuales incorporan nuevas opciones para el desarrollo de procesos control y producci\u00f3n audiovisual . En este campo se han desarrollado aplicaciones , tales como un compresor de audio y video e n tiempo real utilizando un Sistema Embebido, en el cual se obtuvo una alta velocidad y calidad en el proces amiento y una disminuci\u00f3n en costos [38]. A su vez este tipo de sistema s permiten realizar procesos de t ransferencia tecnol\u00f3gica y de conocimientos, con herramientas econ\u00f3micas y de f\u00e1cil acceso, gracias a sus dimensiones y a las prestaciones o caracter\u00edsticas de Hardware /Software que soportan . [4] En comparaci\u00f3n con los computadores de prop\u00f3sito general, l os sistemas embebidos son dise\u00f1ados e implementados para ejecutar aplicaciones espec\u00edficas y previamente definidos por parte de l dise\u00f1ador . [4][39] Al ser sistemas programables se pueden implementar diferentes sistemas de comunicaci\u00f3n, entre los cuales se encuentra el protocolo MIDI, creado para unificar los criterios en cuanto a comunicaci \u00f3n de instrumentos digitales. Este protocolo se puede implementar en automatizaciones, desarrollo de sistemas de control de luces, automatizaci\u00f3n de secuencias musicales y sistemas dom\u00f3tico s. A partir de herramientas tecnol\u00f3gicas modernas como el Kinect, se puede implementar sistemas vers\u00e1tiles e interactivos para el usuario con el objetivo de desarrollar controladores no convencionales para diferentes aplicaciones. El Kinect es capaz de cambiar su espacio de funcionamiento, disminuyendo el \u00e1rea de captura a un rango determinado por el usuario gracias a su proyecto r y sensor infrarrojos. Los controladores MIDI s on dispositivos utilizados para realizar edicion es, producc iones y diferentes tipos de control, los cuales trabajan con el protocolo MIDI que al ser universal permite la conexi\u00f3n a diferentes dispositivos de forma 13 pr\u00e1ctica . Estos dispositivos, normalmente , est\u00e1n compuestos por teclas, potenci\u00f3metros y botones, los cuales son el medio de interacci\u00f3n con el usuario. El dispositivo implementado en el proyecto de grado se enfoca en el desarrollo de una herramienta vers\u00e1til e interactiva , en la cual el usuario es capaz de generar mensajes MIDI por medio de detecci\u00f3n de movimientos, para luego enviarlos v\u00eda WiFi y previamente proces ados por un computador que realiza control MIDI de forma remota. 14 1. PLANTEAMIENTO DEL PROBLEMA 1.1. ANTECEDENTES \"Future human interfaces to computer controlled sound systems \"[28] Este art\u00edculo plantea nuevas posibilidades de interacci\u00f3n hombre -m\u00e1quina por medio de seguimiento de posici\u00f3n especial, de ojos, de cabeza y de entradas t\u00e1ctiles . Presenta algunas tecnolog\u00eda s de interfaces humanas, las cuales pueden ser implementada s en los sistemas de sonido. Los avances en la interacci\u00f3n hombre -m\u00e1quina se divide en 3 secciones; ingreso y reconocimiento de datos por la computador a, sistemas visuales y de escucha y an\u00e1lisis de espacialidad. Los problemas asociados a estos dise\u00f1os suelen afectar la us abilidad de los sistemas que est\u00e1n conectados a este , implementar un dispositivo \u00f3ptico -el\u00e9ctrico conlleva diferentes problemas. Con e l sentido de la vista, el sentido de la audici\u00f3n es la forma principal en la que los humanos recolectan informaci\u00f3n de s u entorno, como la localizaci\u00f3n espacial . [28] \"Gesture to Operate DAW Software \" [29] Hoy d\u00eda existen dife rentes formas de capturar gestos , como en un mouse o en una pantalla multi -touch, para su aplicaci\u00f3n a las estaciones de trabajo de a udio digita l, un ejemplo es el movimiento de un dedo para el cambio de un valor de un par\u00e1metro espec\u00edfico . La pregunta es \u00bfen qu\u00e9 medida el software de audio es ve beneficiado de esto ? Se describe el dise\u00f1o de estrategias que consisten en integrar gestos determinado s asociados a comandos. El art\u00edculo plantea el uso de 22 funciones DAW. En una tabla indica n los gestos y la funci\u00f3n asociada a este, y la reacci\u00f3n de las personas que hicieron las respectivas pruebas. Al final se concluye que los participantes escogieron algunas funciones por encima de otras. Sobre todo porque esto requiere cierto tipo de entrenamiento para que puedan explotar todas las posibilidades de gestos, y la habilidad de creaci\u00f3n de gestos por parte de los usuarios. 15 \"Interactive Mixing Using Wii C ontroller \" [30] El art\u00edculo describe el dise\u00f1o, construcci\u00f3n y an\u00e1lisis de un control interactivo por medio de gestos para la me zcla de audio, utilizando un control inal\u00e1mbrico de video juegos. El concepto est\u00e1 basado en la idea que el ingeniero de mezcla no est\u00e9 cerca la consola y se convierta en parte de la interpretaci\u00f3n de la pista de audio. El sistema permite un control total y en vivo de los controles de ganancia, paneo, ecualizaci\u00f3n, rango din\u00e1mico de la compresi\u00f3n y otra variedad de efectos multi c anal. El control del Wii posee varios sensores de movimiento, que permiten al usuario ubicarse en 3 dimensiones gracias a su aceler\u00f3metro. Tambi\u00e9n cuenta con un sensor infrarrojo que determina la posi ci\u00f3n en el eje X y Y, y posee un dispositivo bluetooth para su conexi\u00f3n . La construcci\u00f3n de un control de movimiento para la mezcla de audio muestra una forma de innovar y mejorar la me zcla en tiempo real. Permite al ingeniero liberarse de la forma convencional de mezcla, d\u00e1ndole libertad de mo vimiento. \"Embedded Controllers For Audio Devices \" [31] Los sistemas embebidos para el audio son presentados como un controlador basado en el protocolo MIDI, son f\u00e1cilmente adaptados para el audio, el art\u00edculo muestra el desarrollo y las herramientas utilizadas para programar un Sistema Embebido para el control de dispositivos de audio. Los sistemas embebidos abren un gran n\u00famero de posibilidades en la implementaci\u00f3n de aplicaciones audio. El control requiere un Sistema Embebido el cual ser\u00e1 programado seg\u00fan sea nece sario. Este se divide en cuatro secciones: memoria, unidad l\u00f3gica, unidad de control y entradas y salidas. [31] Memoria: Se almacena y se lee la informaci\u00f3n del sistema. Unidad L\u00f3gica: Realiza las operaciones l\u00f3gicas y matem\u00e1ticas de la informaci\u00f3n. 16 Unidad De Control: Dirige las actividades de la computadora, siguiendo las instrucciones almacenadas en la memoria para cumplir una tarea espec\u00edfica. Aqu\u00ed se encuentra el procesador y microprocesadores. Entradas y Salidas: En los dispositivos de entrada hay interacci\u00f3n con el usuario de forma f\u00edsica para comunicarse con el computador. Los de salida se utilizan para que el computador se comunique con el usuario. Using Xbox 360 Kinect Games on Enhancing Visual Institutionalized Older A dults with Wheelchairs\" [76] El objetivo de este estudio es explorar los beneficios de los videojuegos en personas de la tercera edad, el Kinect pueden llegar a ser una buena herramienta para poblaci\u00f3n de la tercera edad con silla de ruedas. El estudio se realiz\u00f3 con 53 participantes divididos en dos grupos, un grupo experimental de 22 personas de unos 78 a\u00f1os, y un grupo de control de 31 personas de unos 79 a\u00f1os, el grupo experimental accedi\u00f3 voluntariamente a practicar 3 sesiones de entrenamiento de Xbox 360 con el Kinect por una semana, con una duraci\u00f3n de 30 minutos cada vez. El Vienna Test System y el test de Soda Pop fueron usados para medir la reacci\u00f3n y la coordinaci\u00f3n entre ojos y manos de las habilidades de interpretaci\u00f3n visual, cuyos resultados favorables indicaron que las personas de la tercera edad mejoran este tipo de habilidades gracias a Xbox 360 Kinect. [76] \"Kinect -based obstacle detection for manipulator\" [77] Este art\u00edculo presenta un m\u00e9todo para distinguir obst\u00e1culos y poder manipula rlos cuando se encuentran en el mismo espacio, para esto se utiliza el Kinect como dispositivo de captura, adem\u00e1s de la explicaci\u00f3n del m\u00e9todo de calibraci\u00f3n de Kinect, se describe el m\u00e9todo de calibraci\u00f3n interactivo de m\u00ednimos cuadrados entre el Kinect y el manipulador. El modelo del manipulador es generado usando la librer\u00eda OpenGL. Finalmente, la superficie del manipulador es eliminada de la escena utilizando el sensor infrarrojos del Kinect. [77] 17 \"Human motion tracking of mobile robot with Kinect 3D sensor\" [78] Este art\u00edculo presenta un sistema de control de seguimiento del movimiento con el Kinect, implementado en robot m\u00f3vil. En este sistema, la informaci\u00f3n obtenida con el Kinect de la posici\u00f3n en tres dimensiones de la persona, permite controlar directamente la velocidad y los movimientos del robot. Para reducir el ruido, se utiliz\u00f3 el efecto de oclusi\u00f3n incluida en los datos adquiridos por el Kinect y asu estimar el estado del movimiento, se usa el filtro Kalman, el cual tambi\u00e9n es descrito en e ste art\u00edculo. [78] \"The design and initial calibration using the Microsoft Kinect\" [79] La correcci\u00f3n de movimientos requiere un confiable y minucioso seguimiento, el cual es llevado a cabo por sistemas que usan dispositivos como el sensor de movimiento Polaris Vicra1 para monitorear la posici\u00f3n y orientaci\u00f3n de una herramienta. Los sistemas de seguimiento del movimiento se fijan directamente en el objeto sin necesidad de usar marcadores, este m\u00e9todo fue desarrollado gracias al Kinect, que posee una c\u00e1mara RGB y un sensor infrarrojo de bajo costo el cual puede capturar movimientos r\u00edgidos del cuerpo. El algoritmo del proyecto abierto llamado \"PointCloudLibrary\" fue implementado para registrar la grilla de puntos generados por el Kinect. [79] \"Static Hand Gesture Recognition Based on HOG with Kinect\" [80] En este art\u00edculo se implementa un m\u00e9todo de reconocimiento est\u00e1tico de gestos de la mano usando informaci\u00f3n de profundidad del Kinect. Debido a que la mano es relativamente u n objeto peque\u00f1o con articulaciones complejas, es dif\u00edcil lograr reconocer sus movimientos. Por tal raz\u00f3n, se emple\u00f3 la funci\u00f3n del momento geom\u00e9trico invariante adaptado a los cambios de luz, mediante el an\u00e1lisis de las caracter\u00edsticas de la mano. Gracias al algoritmo de entrenamiento \"Adaboost\" se obtuvieron los modelos gestuales de prueba, con el fin de construir un sistema 1 Es un dispositivo de medici\u00f3n \u00f3 ptico que mide la posici\u00f3n en 3D de marcadores activos o pasivos que son capturados por una aplicaci\u00f3n especifica 18 preciso y eficiente de reconocimiento de gestos manuales usando el sensor del Kinect. [80] En este art\u00edculo se describe la calibraci\u00f3n y funcionamiento de captura de im\u00e1genes en rangos espec\u00edficos utilizando el Kinect, c on la calibraci\u00f3n adecuada de su c\u00e1mara RGB y de profundidad, el Kinect puede capturar detallada mente nubes de puntos hasta 30 fotogramas por segundo. Esta capacidad convierte al Kinect en una herramienta ideal para su uso en la rob\u00f3tica como un sensor de navegaci\u00f3n de bajo costo. Por lo tanto, las t\u00e9cnicas de calibrac i\u00f3n de la c\u00e1mara de profundidad Kinect permiten determinar un rango de funcionamiento espec\u00edfico . Para realizar la calibraci\u00f3n de profundidad, es necesario tener una plataforma de calibraci\u00f3n y software , que fueron desarrollados para asignar autom\u00e1ticamente valores brutos de profundidad para objeto s. La plataforma de calibraci\u00f3n consisti\u00f3 en un tablero de ajedrez blanco facilitado al software asignar los valores de profundidad . Para modificar la \u00f3ptica del Kinect y mejorar la imagen de corto alcance, se utiliz\u00f3 el adaptador \" Nyko Zoom \", aunque es eficaz en la reducci\u00f3n de la distancia m\u00ednima de Kinect, este introduce distorsi\u00f3n al sistema, para esto se desarroll\u00f3 un modelo para corregir dicha distorsi\u00f3n mediante software. Con esto se logr\u00f3 disminuir el alcance m\u00ednimo del Kinect en aproximadament e 30%. [81] \"A new embedded image information processing system design\" [82] Este art\u00edculo presenta un sistema embebido de adquisici\u00f3n de informaci\u00f3n de imagen, e l cual incluye la codificaci\u00f3n y almacenamiento de im\u00e1genes capturadas y otros m\u00e9todos de t ratamiento que cumplen diferentes secciones; la primera es investigar acerca de una pantalla en tiempo real de la informaci\u00f3n digital de imagen a trav\u00e9s de un LCD , y segundo lograr el dise\u00f1o de una parte de almacenamiento de informaci\u00f3n de imagen en el sis tema a trav\u00e9s de la codificaci\u00f3n de imagen BMP. [82] [83] Este art\u00edculo presenta el desarrollo de un sistema de percepci\u00f3n para ambientes de interior con el prop\u00f3sito de permitir la n avegaci\u00f3n aut\u00f3noma de robots m\u00f3viles de vigilancia. El s istema se compone de dos partes, la primera es un sistema de navegaci\u00f3n reactiva en el cual el robot m\u00f3vil se mueve evadiendo obst\u00e1culos, usando el Kinect, y la segunda parte usa una red neural artifi cial (ANN) para reconocer diferentes configuraciones de l entorno. El ANN esta entrenado usando informaci\u00f3n capturada desde el Kinect en interiores , de este modo, el robot es capaz de realizar una navegaci\u00f3n topol\u00f3gica combinando un comportamiento reactivo interno. El mapa topol\u00f3gico es representado por una gr\u00e1fica que representa la configuraci\u00f3n del ambiente. El sistema tambi\u00e9n trabaja en la oscuridad, lo cual es una gran ventaja para sistemas de vigilancia. El experimento fue llevado a cabo con un robot Pi oneer P3 - AT equipado con un sensor Kinect con el fin de validar y evaluar este enfoque. [83] \"A Multi -User Interaction System Based on Kinect Remote\" [84] El sistema de interacci\u00f3n multi -usuario que implementa el Kinect y un control remoto Wii, f ue desarrollado para manipular el escritorio de W indows . Este sistema combina la informaci\u00f3n gestual capturada desde estos sensores brindando una experiencial m\u00e1s real y natural al usuario. [84] 20 1.2. DESCRIPCI\u00d3N Y FORMULACI\u00d3N DEL PROBLEMA Hoy en d\u00eda se ve como los avances tecnol\u00f3gicos simplifican procesos e interact\u00faan de forma m\u00e1s amigable con el usuario, brind\u00e1ndole una experiencia m\u00e1s realista, hasta el punto de evitar en lo posible el contacto f\u00edsico con los objetos para poder controlarlos, ya sea por s ensores o por detecci\u00f3n de movimiento. Por eso se quiere llevar esta tecnolog\u00eda al campo de la ingenier\u00eda de sonido, para ofrecer en el mercado formas innovadoras para realizar grabaciones, mezclas, montajes de sonido en vivo, etc. Con el fin de captar la atenci\u00f3n de las personas que a\u00fan no conocen la carrera. Al ser software poco com\u00fan, se buscan formas pr\u00e1cticas y sencillas para crear proyectos caseros de sonido de forma interactiva, evitando memorizar por ejemplo m\u00e9todos abreviados de teclado o tener qu e abrir pesta\u00f1a por pesta\u00f1a, buscando la opci\u00f3n que requiera. \u00bfC\u00f3mo brindar una experiencia m\u00e1s realista a los usuarios de programas de sonido, por medio de la implementaci\u00f3n de sistemas de control MIDI no convencionales? 1.3. JUSTIFICACI\u00d3N Hoy en d\u00eda se b usca que todos los procesos se apliquen de una forma sencilla , y adem\u00e1s se cuente con una interfaz amigable con el usuario, por eso se requiere que la comunicaci\u00f3n con un computador sea lo m\u00e1s interactiva posible , evitando la instalaci\u00f3n de cualquier tipo de controladores para que un di spositivo externo a \u00e9l funcione, por lo cual se utilizan avances tecnol\u00f3gicos, dise\u00f1ados para tal fin . La implementaci\u00f3n de sistemas embebidos para este fin, a\u00fan no ha sido aplicada a la ingenier\u00eda de sonido , por lo cual se quiere promover su uso mediante la transmisi\u00f3n de MIDI v\u00eda WiFi para control de diferentes dispositivos aplicados a la Ingenier\u00eda de Sonido. 21 1.4. OBJETIVOS 1.4.1. Objetivo General Desarrollar un controlador MIDI interactivo, implementado en un Sistema Embebido que envi\u00e9 mensajes MIDI, utilizando el KINECT. 1.4.2. Objetivos Espec\u00edficos Integrar el KINECT con un sistema embebido. Desarrollar interfaz gr\u00e1fica para la interacci\u00f3n con el usuario, que pueda interpretar mensajes MIDI. Desarrollar sistema de control de usua rio, que permita el control por medio de 3 tipos de mensaje MIDI con el sistema embebido 1.5. ALCANCES Y LIMITACIONES 1.5.1. Alcances Se podr\u00e1 controlar software compatible con el protocolo MIDI, con diferentes funciones seg\u00fan movimientos asignados por el usuario. 1.5.2. Limitaciones Se programar\u00e1 n determinados mensajes MIDI, para evitar que el KINECT confunda algunos movimientos que podr\u00edan llegar a ser muy similares, y envi\u00e9 mensajes err\u00f3neos al sistema. 22 2. METODOLOG\u00cdA 2.1. ENFOQUE DE LA INVESTIGACI\u00d3N El enfoq ue de es te proyecto es emp\u00edrico -anal\u00edtico, debido a que se est\u00e1n aplicando nuevas formas de procesamiento y manejo de mensajes MIDI a partir de controladores no convencionales, a trav\u00e9s de la aplicaci\u00f3n de procesos de transferencia tecnol\u00f3gica. Los sistemas embe bidos se han convertido en una fuente de desarrollo pr\u00e1ctico, este tipo de herramientas permite crear aplicaciones espec\u00edficas de software y hardware para el desarrollo de dispositivos, gracias a sus dimensiones y a las prestaciones. Con el desarrollo de este dispositivo pueden comprobarse la efectividad y versatilidad de la aplicaci\u00f3n de sistemas embebidos para el procesamiento de se\u00f1ales. 2.2. HIP\u00d3TESIS De acuerdo al comportamiento del Kinect en un sistema embebido , se busca que la comunicaci\u00f3n del usuario con el sistema sea m\u00e1s agradable e interactiva , tomando los movimientos capturados para ejecutar acciones espec\u00edficas con ayuda de protocolo MIDI , y se tendr\u00e1 en cuenta que la latencia de captura de imagen no afecte la interacci\u00f3n con el sistema. 2.3. VARIABL ES 2.3.1. Independientes Asignar movimientos a los siguientes mensajes MIDI: Cambio de Control Cambio de Programa 23 Nota MIDI 2.3.2. Dependientes Comportamiento del Kinect en un Sistema Embebido y latencia del mensaje al llegar a alg\u00fan dispositivo 3. L\u00cdNEA DE INVESTIGA CI\u00d3N DE LA UNIVERSIDAD/ SUB -L\u00cdNEA DE LA FACULTAD/ CAMPO TEM\u00c1TICO DEL PROGRAMA L\u00ednea de investigaci\u00f3n : an\u00e1lisis y procesamiento de se\u00f1ales . N\u00facleo Probl\u00e9mico: Ac\u00fastica y audio. 24 4. MARCO TE\u00d3RICO En el desarrollo de un controlador MIDI no convenciona l, utilizando el Kinect, es necesario identificar las siguientes tem\u00e1ticas : Controladores MIDI , Kinect, Sistemas de Transmisi\u00f3n Inal\u00e1mbrica, Sistemas Embebidos y Pure Data 4.1. Controlador MIDI Dispositivo capaz de interpretar y reproducir mensajes MIDI. E n sus modelos m\u00e1s simples cuenta n \u00fanicamente con teclas, entrada y salida MIDI, con lo que cualquier cambio que se desee hacer en el programa debe hacerse directamente desde un software espec\u00edfico . Los m\u00e1s completos disponen de m\u00e1s opciones para el manejo de bancos, c ambio de control o de programa. Normalmente el controlador tiene la apariencia de un instrumento tradicional , redise\u00f1ado para funcionar bajo el prot ocolo MIDI. Los controladores comunes son teclados como el que se observa en la Figura 1, adiciona lmente pueden modificar la modulaci\u00f3n , afinaci\u00f3n , etc... .Pero no produce sonidos por s\u00ed mismos .[2][3][5] Fig. 1 Controlador MIDI . Fuente: Propia 25 Para la interconexi\u00f3n de dos o m\u00e1s interfaces se utilizan tres diferentes puertos y un cable con conector es DIN de 5 pines. Los tres puertos son IN, OUT y THRU los cu\u00e1les cumplen las siguientes funciones: Fig. 2 Conexiones protocolo MIDI . Fuente: Propia MIDI IN: Es la entrada del dispositivo, captura la informaci\u00f3n proveniente desde otro dispositivo MID I. MIDI OUT: Es la salida del dispositivo, por donde se env\u00eda la informaci\u00f3n generada por el dispositivo MIDI. MIDI THRU: Es un puerto que se utiliza para la interconexi\u00f3n de otro dispositivos MIDI. Este es una copia exacta de la informaci\u00f3n proveniente del puerto MIDI IN y se utiliza en el caso de tener un dispositivo maestro que env\u00ede informaci\u00f3n a m\u00e1s de un dispositivo a la vez.[7] 26 4.1.1. Bytes MIDI Hay dos clases de bytes: De estado y de datos. Principalmente se diferencian por el primer bit, que p uede ser 0 o 1, siend o el primero de datos y el segundo de estado , al enviar un mensaje MIDI se env\u00eda un byte de estado, que puede estar seguido de determinada cantidad de bytes de datos , a su vez, los mensajes de estado se dividen en dos: mensajes de cana l y mensajes de sistema ., los mensajes de canal se env\u00edan a un dispositivo espec\u00edfico configurado en ese canal , mientras que los mensajes de sistema son recibidos por todos los equipos. [2](Ver Tabla 1, Tabla 2) Byte Estado Descripci\u00f3n 1000cccc Desactiv aci\u00f3n de nota 1001cccc Activaci\u00f3n de -pulsaci\u00f3n polif\u00f3nica 1011cccc Cambio control 1100cccc -pulsaci\u00f3n monof\u00f3nica de canal 1110cccc Pitch 11110000 Mensaje exclusivo del fabricante 111100 01 Mensaje de trama temporal 11110010 Puntero posici\u00f3n de canci\u00f3n 11110011 Selecci\u00f3n de canci\u00f3n 11110110 Requerimiento de entonaci\u00f3n 11110111 Fin de mensaje 11111111 Reseteo del sistema Tabla 1 Mensajes MIDI Valor (Decimal) Valor (Hexadecimal) Comando Byte de dato 128-143 80-8F Nota Off 2 (nota, Velocidad) 144-159 90-9F Nota ON 2 (nota, Velocidad) 160-175 A0-AF Presi\u00f3n de tecla 2 (nota, Presi\u00f3n) 176-191 B0-BF Cambio de Control 2 (# de Control, Valor) Tabla 2 Comandos Bytes de Estado 27 4.1.2. Mensaje de Nota On/Off Al momento de pulsar una tecla el controlador emite un mensaje MIDI de Nota On, el byte de estado indicara por cual canal se emitir\u00e1 el mensaje , seguido por dos bytes que especifican el n\u00famero de tecla y el valor de la velocidad de la pulsaci\u00f3n el cual determina que tan fuerte fue pulsada .[2] Al soltar la tecla, el controlador emite un m ensaje MIDI de Nota Off, este tambi\u00e9n lleva bytes de datos para determinar la nota y la velocidad con que se ha soltado la tecla, normalmente el byte de datos que determina la velocidad no es tomado en cuenta , ya que al apaga la nota por medio de l byte de estado. 4.1.3. Mensaje de Cambio de Programa Es el p ar\u00e1metro que modifica los elementos que genera n el sonido dentro de un sintetizador, b\u00e1sicamente un cambio de programa que se refiere a cambiar el instrumento del programa activo. Consiste en un byte de encab ezamiento (1100) seguido por un byte de datos que indica el n\u00famero de programa, al recibir este mensaje cambiar \u00e1 inmediatamente el timbre con el que se est\u00e1 tocando las notas. [3] 4.1.4. Mensaje de Cambio de Control Se usan para controlar una gran variedad de funciones de un sintetizador , en los mensajes de cambio de control se incluye la mayor\u00eda de los controles de expresi \u00f3n de sonido, los cuales se transmiten en mensajes independientes , estos controles tienen asignado un n \u00famero que est \u00e1 establecido en la norm a MIDI. En los mensajes de control, el primer byte de datos indica el n\u00famero de controlador o n\u00famero de control y el segundo indica el valor que se ha variado a dicho control. En el caso de los controles que solo pueden tomar dos estados \u00fanicamente (On/Off ), como el sostenido, el segundo byte de datos toma el valor 0 cuando est\u00e1 apagado y 127 cuando est\u00e1 activo. 28 4.2. Kinect2 Fue desarrollado con la idea de crear una interacci\u00f3n juego -humano m\u00e1s realista , con lo que se logr\u00f3 obtener la capacidad de entende r las dimensiones del espacio y tener reconocimiento de voz . Gracias a esto identifica e interpreta sus movimientos y los traduce en un formato en el que los desarrolladores puedan usar para implementar nuevas aplicaciones y mejorar la experiencia del usuario. [6] Este combina una c\u00e1mara RGB3, una c\u00e1mara infrarroja , un sensor infrarrojo y cuatro micr\u00f3fonos de desarrollo propio. Estos componentes brinda n nuevas experiencias a trav\u00e9s de cualquier consola Xbox 360 , Gracias a esto se logra captura r movimiento s en tres dimensiones, reconocimiento facial y de voz. Fig. 3 Microsoft Kinect [32] 2Controlador de juego libre desarrollado por Alex Kipman y Microsoft para la consola Xbox 360. 3Del ingl\u00e9s Red, Green, Blue ; \"rojo, verde, azul\" modelo de color basado en l a s\u00edntesis aditiva , con el que es posible representar un color mediante la mezcla los tres colores luz primarios. 29 4.2.1. Componentes y Funcionamiento La c\u00e1mara RGB percibe la luz que es reflejada por los objetos hacia el lente de la c\u00e1mara, luego la imagen es reconstruida simulando al ojo h umano . El Kinect obtiene datos de distancia en 3D de los objetos mediante la emisi\u00f3n de puntos de luz infrarroja que proyecta el sensor infrarrojo, el cual permite al Kinect percibir su posici\u00f3n en el espacio sin importar su forma f\u00edsica. Fig. 4 Kinect sin carcasa exterior [ 32] El proyector de rayos infrarrojos se encuentra ubicado a la izquierda del Kinect como se puede ver en la Figura 4, este emite una grilla de puntos infrarr ojos, por el rango de frecuencia que maneja se hacen imperceptibles para e l ojo humano y solo la c\u00e1mara infrarroja es capaz de procesarlos , esta se encuentra ubicada a la derecha del Kinect. Proyector Rayos Infrarrojos C\u00e1mara Infrarroja C\u00e1mara RGB 30 Fig. 5 Fotograf\u00eda de grilla de puntos de luz infrarroja emitidos por el Kinect e imagen de profundidad. Fuente: Propia. Es posible determinar la distancia de un objeto a la c\u00e1mara debido a que cada Kinect esta calibrado a determinado rango de operaci\u00f3n, as\u00ed cuando un objeto se encuentra fuera de ese rango, los puntos generados por el sensor infrarrojo cambian de direcci\u00f3n , de esta maner a a partir de la posici\u00f3n de la grilla de puntos se puede conocer las distancias de cada objeto a l Kinect. Una imagen de profundidad es m\u00e1s f\u00e1cil de entender por un computador que una imagen convencional, ya que cada pixel muestra que tal lejos est\u00e1 de la c\u00e1mara, lo cual ayuda a determinar en qu\u00e9 punto inicia y termina un objeto. Tambi\u00e9n contiene informaci\u00f3n sobre el espacio en tres dimensiones, esto con el fin de identificar y seguir la trayectoria de los movimientos de cada individuo, inclusive localiza las articulaciones del cuerpo. 31 Fig. 6 Fotograf\u00eda de la c\u00e1mara RGB e imagen de profundidad del Kinect . Fuente: Propia La c\u00e1 mara RGB muestra una imagen com\u00fan sin ninguna informaci\u00f3n aparentemente \u00fatil, pero al alinearla con la imagen de profundidad, se puede alterar la imagen de la c\u00e1mara RGB, creando un espacio en tres dimen siones o un entorno virtual a color, con la capacidad de manipular el espacio gracias a los datos proporcionados por el sensor infrarrojo. [7] 4.2.2. Controladores Son los encargados de con ectar el Kinect con el computador o sistema embebido, tienen la capacidad de traducir los datos capturados Kinect para que pued an ser entendidos por el ordenador . 4.2.2.1. Open Kinect Es una comunidad de personas que desarrolla librer\u00edas para el Kinect, principa lmente se enfocan en el libfreenect4, que es el controlador que utiliza esta comunidad. Maneja una licencia de c\u00f3digo completamente abierto, siendo este gratuito las personas interesadas puede contribuir en el mejoramiento del mismo. [9][7] 4 Enlace de la comunidad OpenKinect: http://openkinect.org/wiki/Main_Page 32 El libfreenec t soporta la c\u00e1mara RGB, c\u00e1mara infrarroja, motor, aceler\u00f3metro, led y micr\u00f3fonos , brinda ndo un control completo sobre todos sus componentes, este maneja la informaci\u00f3n de posici\u00f3n en los ejes X , Y y Z. 4.3. Sistemas de Transmisi\u00f3n Inal\u00e1mbrica Son los encarga dos de interconectar dos o m\u00e1s dispositivos por medio de la transmisi\u00f3n de se\u00f1ales de un lugar a otro utilizando la modulaci\u00f3n de ondas electromagn\u00e9ticas. Los dispositivos f\u00edsicos son utilizados como emisor y receptor de se\u00f1al. [11] 4.3.1. Redes Inal\u00e1mbricas Es un mecanismo de conexi\u00f3n en red de dos o m\u00e1s dispositivos electr\u00f3nicos, sin la necesidad de una conexi\u00f3n cableada , este tipo de conexi\u00f3n esta presente en los dispositivos habilitados con Wi Fi5, tales como: ordenador es port\u00e1tiles, consola s de videojuegos , tel\u00e9fonos inteligentes o un reproductor de audio digital .[12][15] Existen diferentes categor\u00edas de redes inal\u00e1mbricas y depende n del \u00e1rea de cobertura: 1. Red de \u00e1rea personal inal\u00e1mbrica (WPAN) . [72] 2. Red de \u00e1rea local inal\u00e1mbrica Red de \u00e1rea me tropolitana inal\u00e1mbrica (WMAN) [74] 4. Red d e \u00e1rea extendida inal\u00e1mbrica (WW AN). [75] La Red de \u00e1rea local inal\u00e1mbrica (WLAN) es la de inter\u00e9s, siendo esta la utilizando en hogares, empresas y sitios p\u00fablicos . Tiene un alcance de unos 20 metros en interior es, se pueden cubrir grandes \u00e1reas con la superposici\u00f3n de m\u00faltiples puntos de acceso. [12][10] Los receptores inal\u00e1mbricos en muchos casos se encuentran integrados dentro de los mismos dispositivos, o son implementados como perif\u00e9ricos USB6, en su 5Marca de la Wi-Fi Alliance . Est\u00e1ndar de comunicaci\u00f3n inal\u00e1mbrica. 6Universal Serial Bus . \"Bus Universal en Serie\". Es un est\u00e1ndar de conexi\u00f3n para dispositivos y perif\u00e9ricos electr\u00f3nicos. 33 mayor\u00eda PnP7.Los transmisores utilizados son los enrutadores que proporcionan conectivida d de nivel de red de \u00e1rea local, su funci\u00f3n es reenviar y enrutar paquetes de datos a d iferentes receptores conectados , los dispositivos son identificados por medio de direc ciones IP8. [10] Trabaja bajo el est\u00e1ndar IEEE denominado 802.11 x, abarca la capa f\u00edsica y una subcapa de acceso al medio de la capa de enlace del modelo OSI9. Define el concepto de Conjunto B\u00e1sico de Servicio (BSS), consiste en el reconocimiento de dos o m\u00e1s nodos inal\u00e1mbricos con la capacidad de transmitir informaci\u00f3n entre ellos. [13] Pueden intercambiar informaci\u00f3n de dos maneras distintas: 1. Directa: Cada nodo se comunica sin necesidad de una interfaz que se encargue del intercambio de datos, creando u na red inal\u00e1mbrica descentralizada. E ste modo es llamado Ad -Hoc, solo permite la transmisi\u00f3n de datos entre dispositivos inal\u00e1mbricos .[13] Fig. 7 Conexi\u00f3n modo Ad -Hoc [33] 2. Por Interfaz: Cada nodo se comunica con una interfaz de comunicaci\u00f3n encargada de gestionar la transmisi\u00f3n de datos y la creaci\u00f3n de una red local, pueden ser Enrutadores o Puntos de Acceso. Este es llamado 7Plug-and-Play, \"Conectar y utilizar\". es la tecnolog\u00eda que permite a un dispositivo ser conectado a una computadora sin necesidad de c ontroladores . 8 Del Ingles Internet Protocol. \"Protocolo de Internet\" de comunicaci\u00f3n de datos digitales . 9Open systeminterconnection. \"Modelo de interconexi\u00f3n de sistemas abiertos\" Marco de referencia para la definici\u00f3n de arquitecturas de inter conexi\u00f3n de sistemas de comunicaci\u00f3n. 34 modo Infraestructura y permite vincular red inal\u00e1mbrica con red cableada, ya que la interfaz funciona como puente de comunicaci\u00f3n entre estos dos.[13] Fig. 8 Conexi\u00f3n modo infraestructura [33] 4.3.2. Transmisor MIDI: QmidiNet Software encargado de codifica r y decodificar mensajes MIDI para su envi\u00f3 por medio de redes locales. Se encarga de abrir un enlace de red para la transmisi\u00f3n de m ensajes MIDI v\u00eda UDP/IP Multicast . Recibe y env\u00eda datos MIDI utilizando el secuenciador de ALSA o el puerto MIDI de JACK a trav\u00e9s de redes, al\u00e1mbricas e inal\u00e1mbricas. Este crea puertos MIDI virtuales que son reconocidos por JACK, que facilita su interconex i\u00f3n con diferentes aplicaciones dentro de LINUX. Para su implementaci\u00f3n se utiliza un controlador MIDI para Linux llamado VMPK, el cual genera y recibe mensajes MIDI. [14] Es software libre, distribuido como GNU10 Licencia Publica General versi\u00f3n 2 o poster ior. 10Proyecto iniciado por Richard Stallman con el objetivo de crear un sistema operativo completamente libre . 35 Fig. 9 Acerca de QmidiNet . Fuente: Propia 4.4. Sistemas Embebidos Son sistemas programables, dise\u00f1ados para realizar tareas espec\u00edficas determinadas por el usuario, con el fin de optimizar los procesos para mejorar su desempe\u00f1o y eficiencia, reducien do tama\u00f1o y costos de producci\u00f3n. L os sistemas embebidos se convierten en herramientas de desarrollo \u00fatiles dentro de diversos \u00e1mbitos de la ingenier\u00eda de sonido. [18] A diferencia de los computadores convencionales se caracterizan por el bajo consumo de e nerg\u00eda, son econ\u00f3micos, poseen perif\u00e9ricos limitados, implementaci\u00f3n de diferentes sistemas operativos y algunos son dise\u00f1ados para realizar tareas espec\u00edficas . Est\u00e1n compuestos por tres componentes principales: Procesador, Dispositivos de Almacenamiento y Perif\u00e9ricos. Los cuales var\u00edan seg\u00fan los par\u00e1metros de dise\u00f1o requeridos. Para sistemas embebidos pre dise\u00f1ados o de uso general como lo son la BeagleBoard11, PandaBoard12 o Raspberry Pi13. Utilizan arquitect uras de 11 Sistema embebido de medianas prestaciones que permite a novatos, innovadores e ingenieros la implementaci\u00f3n d e proyectos. 12 Sistema embebido de altas prestaciones con una mayor cantidad de perif\u00e9ricos dise\u00f1ada para ser correr varias aplicaciones simult\u00e1neamente. 13 Sistema embebido de muy bajo costo dise\u00f1ado para correr aplicaciones cotidianas de un computador de bajas prestaciones. 36 procesador similares, todas son arquitect ura ARM14, utilizan una memoria SD/MicroSD15 como dispositivo de almacenamiento y memoria de trabajo RAM16. [35][36][37] Fig. 10 Sistema Embebido Raspberry Pi [35] 4.4.1. Software Lo sistemas embebidos requieren la instalaci\u00f3n de un sistema operativo el cual est\u00e1 dise\u00f1ando para administrar de forma eficiente los recursos del dispositivo, este permite la comunicaci\u00f3n hardware/software con el fin de ejecutar las tareas para las que fue programado.[18] Algunos S.O. Embebidos que se trabajan actualmente son: Android: Plataforma m\u00f3vil desarrollada en base Linux creada por Google, junto con aplicaciones middleware est\u00e1 dise\u00f1ada para ser utilizada en tel\u00e9fonos inteligentes , tablets, televisores, etc. Dise\u00f1ado principalmente para la arquitectura ARM. 14es una familia de procesadores dise\u00f1ado por AcornComputers y desarrollado por Advanced RISC Machines Ltd. 15Secure Digital. Dispositivo digital de almacenamiento. 16del Ingles random -accessmemory. \"Memoria de Acceso Aleatorio\" 37 Tiene una comun idad de desarrolladores grande al ser una plataforma de software libre y de c\u00f3digo abierto . [19][20][21] Linux : Sistema operativo multiplataforma, desarrollado para las arquitecturas x86, x86 -64 y ARM. Por lo cual puede ser ejecutado tanto en computadores convencionales como en sistema s embebidos, aunque muchas de las aplicaciones para Ubuntu est\u00e1n para las tres arquitecturas hay herramientas de compilaci\u00f3n cruzada gratuitas para llevar las aplicaciones de una arquitectura a otra.[22][23][24][26] 4.5. Pure Dat a Es un entorno de programaci\u00f3n por medio de bloques para audio, video y procesamiento de imagen . Es un software libre desarrollado por Miller Puckette el cual tiene una gran cantidad de desarrolladores trabajando en nuevas librer\u00edas, por lo que todo el p aquete es en gran medida un esfuerzo de la comunidad.17 Es un sistema multiplataforma en software , por lo que es muy port\u00e1til, existen versiones para Win32, IRIX, GNU / Linux, BSD, Mac OSX y se ejecuta en cualquier equipo. Fue creado con el fin de explor ar maneras alternativas de programaci\u00f3n por bloques, y para que la implementaci\u00f3n de aplicaciones en audio y MIDI se extendiera a gr\u00e1ficos y v\u00eddeo. Pure Data cuenta con librer\u00edas externas que son escritas en el lenguaje de programaci\u00f3n C++ , estas son de sarrolladas por los mismos usuarios y con el tiempo se incluyen en las librer\u00edas est\u00e1ndar de Pure Data .[27] 17La p\u00e1gina web de la comunidad de Pure Data es: http://puredata.info/ 38 Fig. 11 Secci\u00f3n de documentaci\u00f3n e informaci\u00f3n de Pure Data . Fuente: Propia 39 5. DESARROLLO INGENIERIL En el proyecto de grado se desarroll \u00f3 un controlador MIDI no convencional implementado en un sistema embebido, utilizando el Kinect . El sistema utiliza el protocolo MIDI para controlar hardware o software remoto v\u00eda WiFi por medio de la captura de movimientos. El de sarroll\u00f3 se describe en el diagrama de bloques presentado en la Figura 13. A continuaci\u00f3n se describen las etapas de desarrollo del proyecto: 5.1. Adecuaci\u00f3n S. E. Los S.E. son dispositivos desarrollados a partir de un co -dise\u00f1o hardware/software, el cual se basa en la interacci\u00f3n d e los dos componentes de una forma eficiente, con el fin de mejor ar los procesos del sistema. En el proyecto se implementaron sistemas embebidos comerciales , por lo que fue necesario determinar cu\u00e1l era el sistema operativo \u00f3ptimo para trabajar , se util iz\u00f3 Linux la distribuci\u00f3n de Ubuntu, puesto que es un S.O. vers\u00e1til, tiene un gran soporte, es libre, adaptable y tiene fuentes de desarrollo completas. [18] Estas ventajas son las principales motivaciones por las cuales se emplea el Linux en el desarrollo de la tesis. Existen diferentes versiones las cuales est\u00e1n dise\u00f1adas espec\u00edficamente para cada procesador o memoria , con el fin de obtener un mejor rendimiento dependiendo del hardware, algunas son pre-cargadas con m\u00f3dulos innecesarios y pueden afectar el rendimiento del mismo. Fig. 12 Diagrama de bloques Adecuaci\u00f3n S.E. Beagleboard C3 Compilaci\u00f3n Sistema Operativo Interfaces Graficas de Ubuntu Beagleboard xM Compilaci\u00f3n Sistema Operativo Interfaces Graficas de Ubuntu Pandaboard ES Compilaci\u00f3n Sistema Operativo Interfaces Graficas de Ubuntu Adecuacion S.E. 40 Fig. 13 Descripci\u00f3n Desarrollo Controlador MIDI con Convencional 41 5.1.1 Compilaci\u00f3n Sistema Operativo Se efectu\u00f3 el an\u00e1lisis de varias versiones de Ubuntu en tres sistemas embebidos diferentes, con im\u00e1genes pre compiladas e im\u00e1genes compiladas manualmente, el proceso del desarrollo general para obtener la versi\u00f3n \u00f3ptima se describe en el diagrama de bloque de la Figura 14. Fig. 14 Descripci\u00f3n proceso instalaci\u00f3n Ubuntu en sist emas embebidos Sistemas Operativos Embebidos Compilacion Paso -a-Paso Kernel - RFS - GUI Cross Compilaci\u00f3n Instalaci\u00f3n Prueba Error Pre Compiladas Cross Compilaci\u00f3n Instalaci\u00f3n Prueba Error 42 5.1.1.1. Compilaci\u00f3n Paso -a-Paso El Kernel es el encarga do de gestionar y controlar directamente los recursos de hardware, este fue escogido en base a las recomendaciones dadas por las versiones de Ubuntu. El RFS o sistema de Archivos Ra\u00edz son los archivos encargados del arranque del sistema operativo, poseen una estructura de directorios jer\u00e1rquicos en forma de \u00e1rbol, donde se almacenan aplicaciones, librer\u00edas y archivos de trabajo. La GUI o interfaz gr\u00e1fica de usuario es la que se encarga de brin dar un entorno grafico amigable con el usuario, permitiendo su configuraci\u00f3n por medio de ventanas, men\u00fas , explorador de archivos. [18] Fig. 1 5 Arquitectura general de un Sistema de Linux Embebido [39] En la Figura 15 se presenta la estructura de l Kern el, el cual se compone de: la Interfaz de Bajo Nivel y la Abstracci \u00f3n de Alto Nivel, generalmente es independiente del hardware y provee abstracciones comunes a todos los sistemas Unix, incluyendo procesos, archivos, sockets y se \u00f1ales. Entre estos dos niv eles se encuentran los Componentes de interpretaci \u00f3n, interact \u00faan con las estructuras de datos recibidas o transmitidas por los dispositivos. Los tipos de sistemas de archivos (FAT 32, NTFS, EXT2, EXT3, EXT4 ) y los protocolos de red son ejemplos de estructu ras de datos. Cuando el K ernel se encuentra operando, requiere manejar una estructura adecuada del sistema de archivo, que se denomina RFS el cual es cargado al momento del arranque del sistema operativo, en este caso solo carga librer\u00edas 43 necesarias para su ejecuci\u00f3n, por lo que si se requieren m\u00e1s deber\u00e1n ser instaladas manualmente. Una vez se tienen determinados estos par\u00e1metros se enlazan gracias al script18 de cross compilaci\u00f3n : [18] Setup_sdcard.sh El comando se encarga de preparar la memoria para q ue inicie desde un Sistema Embebido como se observa en la Figura 16 , el script crea la partici\u00f3n de arranque donde se encuentra el Kernel del sistema y la partici\u00f3n de archivos de ejecuci\u00f3n RFS. Fig. 16 Ventana compilaci\u00f3n Ubuntu minimal . Fuente: Propi a Al finalizar se inserta la memoria en el Sistema Embebido y se corren los comandos necesario para instalar la GUI previamente escogida dependiendo del mismo. 18 Conjunto de instrucciones generalmente almacenadas en un archivo de texto que deben ser interpretados l\u00ednea a l\u00ednea en tiempo real para su ejecuci\u00f3n 44 Se realizan las pruebas del sistema operativo, en las que se analiza velocidad de inicio, si e l sistema es estable, si soporta las librer\u00edas necesarias, etc. Esto esperando encontrar el sistema ideal con la interfaz gr\u00e1fica adecuada para su \u00f3ptimo funcionamiento. 5.1.1.2. Imagen Pre -Compila da Por este m\u00e9todo contamos con im\u00e1genes desarrolladas oficialment e por Ubuntu en las que se encuentra un Kernel, RFS y GUI definidos, existen diferentes versiones para cada tipo de Sistemas Embebidos . La imagen pre -compilada contiene un paquete de librer\u00edas m\u00e1s amplio lo cual las hace m\u00e1s densas que la versi\u00f3n minimal , pero ahorran mucho tiempo a la hora de descargar librer\u00edas extra o activar m\u00f3dulos del Kernel. S e cross -compilan con el comando: $ zcat dispositivo SD\" ; sudo sync Al finalizar el script como se muestra en la Figura 17 se inserta la memoria en el sistema embebido, y a comparaci\u00f3n con en el m\u00e9todo Paso -a-Paso, este va a iniciar una interfaz gr\u00e1fica autom\u00e1ticamente, la cual guiar\u00e1 al usuario a trav\u00e9 s de la instalaci\u00f3n del Sistema O perativo, similar al proceso que se lleva en una computadora com\u00fan. Una vez instalado se hacen las pruebas necesarias para determinar el sistema operativo ideal para el sistema, siguiendo los mismos par\u00e1metros analizados en el primer m\u00e9todo: velocidad de i nicio, si el sis tema es estable o si soporta las librer\u00edas necesarias . 45 Fig. 1 7 Ventana creaci\u00f3n imagen pre compilada . Fuente: Propia 5.1.1 Interfaces Graficas de Ubuntu Existen varias interfaces gr\u00e1ficas que se pueden implementar en Ubuntu y son variaciones del mismo, al gunas de ellas son Kubuntu, Lubuntu y Xubuntu. Estas distribuciones incluyen algunos de los paquetes esenciales pero con interfaces gr\u00e1ficas ligeras. Las cinco interfaces utilizadas fueron KDE, LXDE, XFCE, Gnome y Unity. Gnome sol\u00eda ser el est\u00e1ndar en U buntu hasta la llegada de Unity una interfaz m\u00e1s completa pero a su vez m\u00e1s pesada, est\u00e1 incluida desde la versi\u00f3n 11.04 de Ubuntu. 46 5.1.1.1 XFCE La interfaz XFCE fue la primera en ser implementada, con esta se obtuvieron mejoras en cuanto a rendimiento, perm itiendo al usuario poder ingresar a los diferentes men\u00fas, instalar software complementario y configurar sus perif\u00e9ricos desde la interfaz gr\u00e1fica. El problema surge al instalar programas de procesamiento digital de se\u00f1ales, el monitor de memoria alcanza el 80% de la memoria por ende disminuye el rendimiento del sistema . $ sudo apt -get install xfce Fig. 1 8 Interfaz Gr\u00e1fica Xfce . Fuente: Propia 5.1.1.2 KDE La interfaz KDE surge de la necesidad de buscar un mejor rendimiento de la Beagleboard y aunque el rendi miento aument\u00f3 con respecto al Unity, no superaba al XFCE ya que tan solo ejecutar la terminal e instalar paquetes por m\u00e1s sencillos que fueran, el monitor de memoria alcanzo el 100% por ello se descart\u00f3 su implementaci\u00f3n . $ sudo apt -get install kde 47 Fig. 19 Interfaz Gr\u00e1fica Kde . Fuente: Propia 5.1.1.3 Gnome La interfaz Gnome es una interfaz eficiente para trabajar , las distribuciones de Ubuntu que incluye Gnome pod\u00edan ser instaladas en computadoras con procesadores mono n\u00facleo y con poca memoria RAM, s e concluye que puede se r una soluci\u00f3n \u00f3ptima. Al hacer el proceso de cross -compilaci\u00f3n en la Beagleboard se encuentra una mejora con respecto a KDE pero aun as\u00ed no superaba a XFCE el cual era el objetivo. Es una interfaz muy amigable y muy conocida por los usu arios antiguos de Ubuntu entonces esa es una ventaja sobre el XFCE a pesar de su rendimiento. $ sudo apt -get install gnome -panel 48 Fig. 20 Interfaz Gr\u00e1fica Gnome . Fuente: Propia 5.1.1.4 LXDE La interfaz LXDE es una interfaz ligera donde programas de proce samiento digital de se\u00f1ales tienen un mejor rendimiento y el sistema tiene un comportamiento m\u00e1s estable , teniendo en cuenta lo anterior se llevaron a cabo las primeras pruebas de env\u00edo MIDI a trav\u00e9s de red. $ sudo apt -get install lxde 49 Fig. 2 1 Interf az Gr\u00e1fica Lxde . Fuente: Propia 5.1.1.5 Unity La interfaz gr\u00e1fica Unity fue implementada \u00fanicamente en la Pandaboard ES debido a su procesador doble n\u00facleo , es una interfaz m\u00e1s amigable con el usuario pero a su vez consume una cantidad considerable de recursos del sistema . Se instala con el comando: $ sudo apt -get install ubuntu -desktop 50 Fig. 22 Interfaz gr\u00e1fica Unity . Fuente: Propia 5.1.2 Sistemas Embebidos Implementados Estos procesos se llevaron a cabo en los siguientes sistemas embebidos: Beagleboard C3, B eagleboard xM y Pandaboard ES. A con tinuaci\u00f3n se describe el procedimiento espec\u00edfico para cada uno: 5.1.2.1 Beagleboard C3 Para el desarrollo en este Sistema Embebido es importante tener un buen manejo de herramientas de cross -compilaci\u00f3n , debido a sus limitado s recursos de hardware es necesario conocer como optimizar el sistema , los resultados obtenidos fueron los siguientes: Las pruebas in\u00edciales se llevaron a cabo en la versi\u00f3n 11.04 de Ubuntu, se trabaj\u00f3 la cross -compilaci\u00f3n de Kernel y Root File System pre -compilados por el grupo de desarrollo de Ubuntu , para esto se ejecuta el comando : 51 $ ./ubuntu sync Al compilar la imagen en la tarjeta SD se instalaron paquetes de ini cio que hicieron tardar m\u00e1s de lo normal el inicio del sistema , por lo que la descompresi\u00f3n del sistema tarda m\u00e1s de lo esperado . Se intent\u00f3 arreglar e l problema desinstalando manualmente los paquetes pero sin obtener un mejor rendimiento del S.E. El sigu iente sistema operativo fue Ubuntu 11.10, aunque las mejoras obtenidas no fueron significativas para el funcionamiento de varios programas simult\u00e1neamente . La ventaja en cuanto a la versi\u00f3n 11.04 fue la implementaci\u00f3n de controladores de video dise\u00f1ados pa ra este sistema embebido. Se compila en la SD con el siguiente implement\u00f3 una compilaci\u00f3n paso -a-paso , utilizando un Kernel con \u00fanicamente los m\u00f3dulos necesarios para el arranque del sistema y de los perif\u00e9ricos. Se dise\u00f1o una imagen optimizada para el funcionamiento exclusivo en la Beagleboard C3. Estas im\u00e1genes son llamadas Ubuntu minima l y no incluyen interfaz gr\u00e1fica, el proces o de instalaci\u00f3n debe empezar desde la conf iguraci\u00f3n de la tarjeta de red hasta la instalaci\u00f3n de paquetes por medio de la terminal utilizando comandos shell. El Primer paso a seguir es descarga r y se descomprimir la imagen: ubuntu-11.04-r3-minimal-armel.tar.xz En esta carpeta se encuentra el script que ejecuta todo el proceso, en este punto se puede seleccionar Kernel y Root File System, pero es recomenda ble utiliza r los que est\u00e1n incluidos en la im agen: $ sudo ./setup_sdcard.sh --mmc /dev/sdX -uboot beagle_cx Al iniciar la Beagleboard se debe configura la red para poder descargar librer\u00edas, controladores de video y paquete s de desarrollo . 52 $ sudo if config Al realizar las pruebas con el Kinect se presenta una limitante de p rocesamiento , debido a que este requiere un mejor procesador, por lo cual este Sistema Embebido puede funcionar como un controlador MIDI inal\u00e1mbrico, pero la recepci\u00f3n de datos se debe hacer por medio de interfaces que no realicen procesamiento de im\u00e1gene s, por su limitaci\u00f3n de hardware. Fig. 2 3 Beagleboard C3. Fuente: Propia 5.1.2.2 Beagleboard xM Debido a l as limitaciones de hardware de la Beagleboard C3, surge la necesidad de adquirir un n uevo sistema embebido con un mejor p rocesador y memoria para obtener mejores resultados . Se llev\u00f3 un pro ceso de compilaci\u00f3n similar al de la Beagleboard C3 con la diferencia que este disminuye el tiempo de instalaci\u00f3n y el procesamiento en general es m\u00e1s eficiente por lo que se pudo probar m\u00e1s distribuciones de Ubuntu con diferentes interfaces gr\u00e1ficas. 53 Se trabaj\u00f3 con la image n pre compilada de Ubuntu 12.04, esta se tom\u00f3 alrededor de diez minutos en su descompresi\u00f3n e instalaci\u00f3n , se obtuvo un Ubuntu similar al de escritorio , exitosamente se pudo enviar mensajes MIDI por WiFi y el procesa miento de se\u00f1ales fue aceptable, p ero surge n problema s con los controladores del Kinect , no funcionaban de la forma esperada, por lo que este Sistema Operativo Embebido no posee controladores optimizado s para el chip de video, obteniendo latencia al momento de adquirir y procesar los datos. Fue necesario volv er a la versi\u00f3n 11.10 de Ubuntu, s u descompresi\u00f3n e instalaci\u00f3n fue exitosa y r\u00e1pida , su instalaci\u00f3n tard\u00f3 alrededor de diez minutos , se descargaron los controladores y paquetes necesa rios para hacer pruebas con el Kinect. Los resultados obtenidos no fueron \u00f3ptimos a pesar de contar con controladores de video optimizados para la Beagleboard xM y se dete rmin\u00f3 realizar un cambio de GUI, por lo que se crea la imagen espec\u00edfica con el coman do: $ sudo ./setup_sdcard.sh --mmc /dev/sdX --uboot beagle_xm Al incluir controladores de video se escoge la versi\u00f3n 11.10 de Ubuntu con el fin de optimizar el sistema , se descarga l a versi\u00f3n m\u00ednimal de esta versi\u00f3n y se implement \u00f3 un Kernel op timizad o, al contar con mejor procesador se decide instalar no solo la interfaz gr\u00e1fica si no todo el entorno de desarrollo, en este caso al obtener el mejor rendimiento con L XDE en la Beagleboard C3, se escoge e l entorno de desarrollo Lubuntu, con esto se obtien e un completo funcionamiento de los servicios, y no es necesario activar los m\u00f3dulos MIDI ni de red manualmente. $ sudo apt -get install lubuntu -desktop Se logr\u00f3 optimizar el sistema obteniendo mejores resultados del procesamiento de imagen y sonido, su latencia fue m\u00ednima con lo que la ad quisici\u00f3n de datos se pudo hacer en tiempo real, se probaron los ensambles de Pure Data con los drivers Freenect del Kinect y el resultado fue exitoso , se logr\u00f3 la captura de datos de profundidad convirti\u00e9ndolos en men sajes MIDI para posteriormente enviarlos por medio de WiFi. 54 Buscando implementar la \u00faltima generaci\u00f3n se sistemas embebidos se encuentra uno con mejor procesamiento a un costo considerablemente bajo teniendo en cuen ta su mejor a en cuanto a hardware. Fig. 2 4 Beagleboard xM. Fuente: Propia 5.1.2.3 Pandaboard ES Las caracter\u00edsticas de hardware de la Pandaboard son superiores a las de la Beagleboard , proporcionando una mejor rendimiento gracias al procesador doble n\u00facleo , debido a este no existe la necesidad d e utilizar im\u00e1genes co mpiladas manualmente, la idea era minimizar el proceso teniendo en cuenta todo el desarrollo ingenieril realizado en las dos Beagleboard son la base para poder implementar y entender otros tipos de sistemas m\u00e1s complet os. Se utiliza n im\u00e1genes pre -compiladas , la ventaja es que los paquetes innecesarios no afectan al sistema, si se quisiera compilar una interfaz gr\u00e1fica m\u00e1s ligera para optimizar m\u00e1s el sistema se podr\u00eda realizar el proceso manual de compilaci\u00f3n con los mismos comandos utilizados en los otros S.E. Para la instalaci\u00f3n y cross -compilaci\u00f3n del Ubuntu 12.10, se propone un nuevo sistema de instalaci\u00f3n que funciona exclusivamente para sistemas OMAP 4, 55 donde la creaci\u00f3n de la SD se hace desde el mismo S.E., utilizando una memo ria USB para iniciar el sistema y continuar el proceso de instalaci\u00f3n tal cual se har\u00eda en su versi\u00f3n para escritorio, al parecer es sencillo pero al ser tan rec iente no es compatible con mucha s librer\u00edas ya probados anterior mente , esta imagen solo se crea con el fin de conocer el nuevo proceso y ver el rendimiento de esta S.O. Fig. 25 Pandaboard ES. Fuente: Propia Despu\u00e9s de varias pruebas se decide implementar la versi\u00f3n 12.04 de Ubuntu con interfaz gr\u00e1fica Gnome y Unity , se logra ejecutar el tiempo real el Kinect y los cambio s son notorio s con respecto a la Beagleboard , obteniendo un procesamiento de se\u00f1ales m\u00e1s eficiente. [Ver Tabla 3] 56 Beagleboa rd C3 Beagleboard xM Pandaboard ES Procesador 720 MHz 1 GHz 1.2 GHz Tipo de Procesador ARMCortexA8 ARMCortexA8 Dual Core ARM Cortex -A9 Memoria RAM 256 MB 512 MB 1 GB GPU PowerVR SGX530 PowerVR SGX2D/3D PowerVR SGX540 @ 384 MHz Video DVI-D, S Video DVI-D, S Video DVI-D, HDMI (Full HD) Tipo de Memoria SD MicroSD SD Ethernet No Si Si WiFi No No Si Bluetooth No No Si Power Supply 5V 5V 5V Puertos de Sonido Conector 3.5 mm I/O Conector 3.5 mm I/O Conector 3.5 mm I/O Puertos USB 1 4 2 Costo US$ 125 US$ 149 US$ 162 Dimensiones 7.62 cm x 7.62 cm 8.25 cm x 8.25 cm 10 cm \u00d7 11 cm Tabla 3 Comparaci\u00f3n especificaciones sistemas embebidos [36][37] Despu\u00e9s de las diferentes pruebas se llega a la conclusi\u00f3n que la Pandaboard ES es la mejor opci\u00f3n por la relaci\u00f3n de costo -beneficio como se observa en la tabla 3, a pesar de eso no se d escarta la implementaci\u00f3n de m\u00e1s proyectos en la Beagleboard , a pesar de sus prestaci\u00f3n de hardware tambi\u00e9n demuestra una gran capacidad de desarrollo en el campo de la ingenier\u00eda de sonido. 5.2. Transmisi\u00f3n mensajes MIDI por WLAN En este proceso es necesari o conocer el funcionamiento y configuraci\u00f3n de los routers, de la red con IP est\u00e1tica y la cross -compilaci\u00f3n del software para transmitir MIDI por medio del protocolo UDP , como se presenta en la Figura 26. 57 Fig. 2 6 Transmisi\u00f3n Mensajes MIDI 5.2.1. Configuraci\u00f3n Router para una Red Local Inal\u00e1mbrica (WLAN) Los routers actuales son dise\u00f1ados para ser configurados por usuarios finales con o sin experiencia para la creaci\u00f3n de una red local inal\u00e1mbrica (WLAN), el primer paso es determinar si se desean d irecciones IP est\u00e1ticas o din\u00e1micas, las IPs din\u00e1micas brindan la posibilidad de tener un rango amplio de direcciones disponibles para la conexi\u00f3n de dispositivo WiFi, este asigna autom\u00e1ticamente estas direcciones para no tener conflicto de conexi\u00f3n. Las IPs est\u00e1t icas est\u00e1n limitadas a las IPs configuradas, esta configuraci\u00f3n tambi\u00e9n debe ser aplicada en el dispositivo asign\u00e1ndole una de las IPs configuradas previamente, provee mayor seguridad pero es menos pr\u00e1ctica y m\u00e1s complicada para un usuario final sin experiencia. Configuraci\u00f3n Router Configuraci\u00f3n de Red en Ubuntu Codificaci\u00f3n y env\u00edo de MIDI Implementaci\u00f3n y Pruebas de Transmisor Router Transmisi\u00f3n Mensajes MIDI por WLAN 58 5.2.2. Configuraci\u00f3n de Red en Ubuntu La configur aci\u00f3n se realiza con direcciones IPs din\u00e1micas en el router , se le asigna un a direcci\u00f3n fija al Sistema Embebido con el fin de implementar la funci\u00f3n de escritorio remoto como se muestra en la Figura 27 de forma r\u00e1pida y sencilla para evitar conectar una pantalla al puerto HDMI. Primero se debe conocer el rango el cual fue configurado el router y la puerta de enlace, luego se modifican las configuraciones de red del embebido , de forma gr\u00e1fica o por l\u00ednea de comando . En la ventana de conexiones se encuentran las pesta\u00f1as de Cableada o Inal\u00e1mbrica como se muestra en la Figura 5 3, dependiendo de la conexi\u00f3n del dispositivo se elegir\u00e1 uno de los dos, en cualquiera de los dos casos se selecciona la conexi\u00f3n activa y se edita IPv4, dentro de esta pesta\u00f1a se modifica el m \u00e9todo de Autom\u00e1tico a Manual y se agregan las opciones de: Direcci\u00f3n, M\u00e1scara de red y Puerta de enlace , se ingresa preferiblemente una de las ultimas direcciones de red del rango dis ponible para no tener conflictos con la direcci\u00f3n de los dem\u00e1s dispositivo; en M\u00e1scara de red se ingresa: \"255.255.255.0\" y al final la puerta de enlace que es la direcci\u00f3n IP del router. Para hacer la configuraci\u00f3n por l\u00ednea de comando es necesario modif icar el archivo interfaces $ sudo vim /etc/network/interfaces Si del archivo existen comandos como: iface , eth0, inet o dhcp , se deben borrar para evitar conflictos y se agregara las configuraciones de red, para esto se debe determinar la interf az de red que se quiera utilizar, ya sea eth0 para la interfaz cableada, o wlan0 para la inal\u00e1mbrica, dependiendo de eso el archivo cambiara, a continuaciones se muestra un ejemplo para la interfaz cableada: # Configuraci\u00f3n IP x. x.x.x netmask 255.255.255.0 59 Se cambian los valores deseados, donde Address es la direcci\u00f3n IP que se le quiere designar al dispositivo y Gateway es la puerta de enlace del router , una vez configurado se de ben reiniciar los servicios de red para que surta efecto con el siguiente comando: $ sudo /etc/init.d/networking restart Con esto se finaliza la configuraci\u00f3n de red, para comprobar que todo haya quedado correctamente configurado se ejecuta ifconfig para conocer el estado de las interfaces de red activas, en el cual se presentan los par\u00e1metros modificados previamente. Fig. 27 Implementaci\u00f3n escritorio remoto desde una Tablet . Fuente: Propia 60 5.2.3. Codificaci\u00f3n y env\u00edo de MIDI El protocolo de Datagrama de Usuario se implementa sin la necesidad de una conexi\u00f3n, func iona a trav\u00e9s de direcciones IP y ofrec e un enlace directo para enviar y recibir datagramas, por lo que se utiliza para enviar audio a trav\u00e9s de redes. La ventaja que ofrece el empaquetamiento de datos por medio de datagramas es que se maneja de forma independiente; y Al no requerir conexi\u00f3n se pueden enviar datos sin la necesidad de proporcionar direcci\u00f3n IP o nombre del equipo receptor, est\u00e9 posee la facultad de ser multicast, mientras el rece ptor posea el decodificador podr\u00e1 recibir los datos MIDI, solo se debe asignar un puerto para conocer qu\u00e9 puerto debe ser habilitado por el receptor, cada puerto cuenta con los 16 Canales MIDI predeterminados del protocolo, por lo que se cuenta con un gran n\u00famero de canales MIDI para enviar datos independientes. Fig. 28 Diagrama de flujo codificaci\u00f3n y envi\u00f3 MIDI 5.2.4. Implementaci\u00f3n y Pruebas Transmisor MIDI QmidiNet La compilaci\u00f3n de este software se realiza utilizando la herramienta GCC, al tener acceso a l c\u00f3digo fuente se puede portar la aplicaci\u00f3n a diferentes plataformas, se compila utilizando los comandos: Fig. 29 Diagrama conexi\u00f3n QmidiNet Mensajes MIDI Codificador UDP WLAN QmidiNet MIDI IN Router JACK Pure Data MIDI OUT 61 $ ./configure $ make La interfaz gr\u00e1fica permite escoger interfaz de transmisi\u00f3n: red al\u00e1mb rica o inal\u00e1mbrica , puerto UDP, n\u00famero de puertos y secuenciador MIDI, es recomendado utilizar ALSA. Fig. 30 Interfaz de configuraci\u00f3n QmidiNet. Fuente: Propia Una vez configurado se ingresa a JACK donde aparecen las conexiones MIDI de Sistema Embebido como lo muestra la Figura 26, en la interfaz s e pueden interconectar los software que posean entradas y salidas MIDI, como ejemplo se conecta la salida MIDI 1 de Pd a la entrada del puerto 0 de QmidiNet para enviar los datos generados de Pd hacia otro dispositivo. Fig. 31 Entradas y Salidas MIDI de Ubuntu. Fuente: Propia 62 5.3. Integraci\u00f3n Kinect Esta fase se divide en 3 partes las cuales son cross -compilaci\u00f3n de Pure Data Extended, integraci\u00f3n de los controladores del Kinect e integraci\u00f3n de Pure Data - Kinect, como lo descri be la Figura 32. Fig. 32 Integraci\u00f3n Kinect 5.3.1. Compilaci\u00f3n Pure Data Extended Pure Data tiene versiones disponibles para diferentes arquitecturas y Sistemas Operativos, en Ubuntu est\u00e1 incluido dentro de sus repositorios pero no la versi\u00f3n extended , la cual se debe implementar debido a sus d iferentes \"Externals\" , El diagrama de bloques de la Figura 33 describe el proceso de cross -compilaci\u00f3n: Integracion Pure Data -Freenect Integraci\u00f3n Controladores Kinect Compilaci\u00f3n Pure Data Extended Integraci\u00f3n Kinect 63 Fig. 33 Descripci\u00f3n proceso compilaci\u00f3n Pure Data Extended El primer paso es instalar todos los paque tes necesarios para poder compilar Pure Data Extended los cuales son: $ sudo c\u00f3digos fuente de Pd Extended, \"Externals\" de Pd Extended y Gem de la siguiente manera: Archivos Base Pd Extended Enlaces Externals Cross Compilaci\u00f3n Error Paquetes Instalaci\u00f3n 64 gem.git A partir de estas carpetas se debe crear una carpeta que enlace todo utilizando accesos directos de la siguiente mane ra: Cd pd-svn/ mv pd pd-original -s ../gem.git Gem cd externals ln -s ../../gem.git Gem Una vez enlazados el archivo Make para realizar la compilaci\u00f3n se encuentra en la siguiente carpeta: cd pure-data/packages/linux_m ake make install && make package La compilaci\u00f3n puede tardar dependiendo del Sistema Embebido entre dos y cinco horas, al final se obtendr\u00e1 el instalador as\u00ed que e l proceso solo debe ser ejecutado una vez mientras no se cambie de arquitectura. 65 Fig. 34 Interfaz gr\u00e1fica principal de Pd Extended . Fuente: Propia 5.3.2. Integraci\u00f3n Controladores Kinect Estos controladores se implementan en dos sistemas embebidos por cuesti\u00f3n de procesamiento, el Freenect puede ser ejecutado desde la Beagleboard xM y la Pandab oard ES. Los paquetes necesarios para compilar los dos controladores son los siguientes: $ sudo apt Controladores Los controladores freenect se compilan con la herramienta cmake19 previamente instalada , es importante con ceder los permisos necesarios pa ra que funcionen correctamente, para esto se implementan reglas de ejecuci\u00f3n. Fig. 35 Ventana de Comando de Compilaci\u00f3n Freenect , con el Kinect conectado a la Pandaboard ES . Fuente: Propia Dentro de la carpeta K inect se inicia la descarga y la Es una herramienta de compilaci\u00f3n multiplat aforma de c\u00f3digo abierto, dise\u00f1ada para compilar, comprobar y empaquetar so ftware 67 Al finalizar se agrega al usuario de Ubuntu a los siguientes grupos: $ sudo add user $USER video $ sudo add user $USER plugdev Se a\u00f1ade una regla de ejecuci\u00f3n para no tener la necesidad de ejecutarlo como s\u00faper usuario, para esto se edita el archivo \"51-kinect.rules\" se le agrega lo siguiente: por los controladores Freenect . Fuente: Propia 68 El controlador Freenect permite acceder al sistema multi -sensor de PrimeSense20, instala nuevos m\u00f3dulos en el Kernel y agrega librer\u00edas al sistema. La Figura 37 muestra como es implementado el chip PS1080 SoC21, este es sistema multi -sensor, capaz de sincronizar la imagen de profundidad con la de color y a la vez capturar sonido. Todos los algoritmos de adquisici\u00f3n de datos de profundidad se ejecutan dentro de este SoC, y con la facultad de enviarlos a otros sistemas por medio de un cable USB, gracias a esto puede ser implementado en dispositivos con capacidad limitada. [40] Fig. 37 Diagrama de control de PrimeSense [40] 20 Compa\u00f1\u00eda encargada de fabricar el sistema multi -sensor para el Kinect 21 Tecnolog\u00edas de fabricaci\u00f3n que integran todos o gran parte de los m\u00f3dulos de un sistema electr\u00f3nico en un \u00fanico circuito integrado o chip. 69 5.3.3. Integraci\u00f3n Pure Data -Kinect Para ejecutar los ejemplos de P ure Data dise\u00f1ados para estos controladores es necesario compilar dos \"Externals\" fundamentales: pix_freenect y pix_depth2rgba, los cuales se compilan utilizando los paquetes descargados de Pure Data y los m\u00f3dulos instalado por el freenect . El primero en compilar es el pix_freenect, al descargarlo hay que tener en cuenta que hay dos archivos Make el de inter\u00e9s es el Makefile_linux , los otros se eliminan y a est\u00e9 se le renombra como Makefile, a continuaci\u00f3n se edita y se le da la ruta de ub icaci\u00f3n de la carpeta de Pure Data Extended, Gem y Freenect. Al terminar se cierra y desde la terminal se ejecuta el comando : $ make Se copia el \"External\" creado y el archivo de ayuda del Pd con los siguientes comandos: $ Se compila el pix_depth2rgba de la misma manera, se modifica el archivo Make y se compila, al finalizar se copian las librer\u00edas y la ayuda de Pd: $ sudo /usr/lib/pd Ahora ya se pueden ver la imagen del Kinect a trav\u00e9s de Pd y su complemento gr\u00e1fico Gem. 70 Fig. 38 Ensamble implementado en Pd para la captura de datos en el eje Z y X En la primera secci\u00f3n se encuentra l a caja principal del programa pix_freenect la cual se muestra en la Figura 39, esta cuenta con entradas y salidas, en las entradas se tienen propiedades, aceler\u00f3metro y Gem. pd properties maneja qu\u00e9 tipo de imagen se desea mostrar, calidad de imagen, control de led, control del motor, etc. A la salida se encuentran los datos RGB e infrarrojos , adicional se puede adquirir los datos del aceler\u00f3metro en 3 ejes. Fig. 39 Secci\u00f3n principal ensamble En la segunda secci\u00f3n del ensamble la cual se e ncuentra en la Figura 39, se hace la activaci\u00f3n de la interfaz de Gem, se crea a partir de la caja de mensaje \"dimen 640 480, create, 1\" donde se puede modificar la resoluci\u00f3n de la ventana de Gem; 71 con la caja de mensajes \"destroy \" se elimina la interfaz c reada, adicionalmente esta la caja de pd android , la cual da acceso al TouchOSC para controlar el ensamble a partir de dispositivos Android. Fig. 40 Secci\u00f3n activaci\u00f3n Gem La tercera secci\u00f3n se divide entre los datos obtenidos en el eje X y los datos de profundidad en el eje Z como se muestra en la Figura 41. Fig. 41 Secci\u00f3n obtenci\u00f3n datos X y Z Las cajas de n\u00famero X y Z se utilizan para mostrar los valor es capturados en esos dos ejes respectivamente, los valores son enviados a las cajas pd MIDICTL y pd MIDINOTE respectivamente, las que se muestran en detalle en las figuras 42 y 43 72 Fig. 42 Configuraci\u00f3n MIDICTL Fig. 43 Configuraci\u00f3n MIDINOTE 73 5.4. Implementaci\u00f3n Controlador MIDI No Convencional La \u00faltima fase donde se llevan a cabo pruebas y se analizan los resultados par a sacar conclusiones acerca del funcionamiento del Kinect sobre Sistemas Embebidos , se describe en la Figura 44. Fig. 44 Descripci\u00f3n proceso de implementaci\u00f3n y prueba del sistema 5.4.1. Recepci\u00f3n y Decodificaci\u00f3n Para la recepci\u00f3n de los datos MIDI se utilizan el software ipMIDI, el cual es una versi\u00f3n de prueba para Windows, es un receptor de datagramas por medio del protocolo UDP, se encarga de decodificar los da tagramas generando nuevamente mensajes MIDI, est\u00e9 cuenta co n 20 puertos y cada puerto con 16 canales MIDI, con lo que se tiene un total de 32 0 canales MIDI independientes . Recepci\u00f3n Decodificaci\u00f3n Comprobaci\u00f3n Implementaci\u00f3n An\u00e1lisis de Resultados Conclusiones Producctos Implementaci\u00f3n Controlador MIDI No Convencional 74 Fig. 45 Diagrama de bloques recepci\u00f3n y decodificaci\u00f3n 5.4.2. Comprobaci\u00f3n La recepci\u00f3n es monitorizada con el software MIDI -OX, el cual se encarg a de analizar el puerto de entrada MIDI deseado y m ostrar la informaci\u00f3n de los datos MIDI recibidos, co mo tipo de mensajes o velocidad, la interfaz de usuario se muestra en la Figura 46. Para comprobar que el receptor est\u00e1 funcionando de forma correcta s e utiliza un celular con sistema operativo Android para enviar mensaje s MIDI desde la aplicaci\u00f3n TouchOSC, esto con el fin de asegurarse que las conexiones y los puertos de recepci\u00f3n sean los indicados. Fig. 46 Recepci\u00f3n de datos MIDI v\u00eda WiFi a MIDI -OX. Fuente: Propia WLAN Decodificador UDP Mensaje MIDI 75 Una vez se comprueba que el receptor est\u00e1 en funcio namiento se utiliza el Kmidimon para poder comprobar los tipos de mensajes que se est\u00e1n enviando desde el Pure Data o desde el VMPK que es un controlador MIDI virtual el cual se observa en la figura 57. Este es software similar a MIDI -OX pero para Linux. Fig. 47 Recepci\u00f3n de datos MIDI desde VMPK al Kmidimon. Fuente: Propia 5.4.3. Implementaci\u00f3n La implementaci\u00f3n se hace con el software FL Studio 22, el cual es un software amigable para la configuraci\u00f3n de los mensajes MIDI de control , se realiza por medio de detecci\u00f3n con el fin de optimizar la conexi\u00f3n. Se utiliza un sintetizador para la recepci\u00f3n de mensajes MIDI de Nota On/Off y el control de Faders con los mensajes de cambio de control. Las Figuras 48 muestran el funcionamiento desde la Pandaboard ES conectada remotamente a un computador de escritorio y a una Tablet 22 Es un software de producci\u00f3n capaz de grabar en m\u00faltiples pistas, secuenciador y mezclador para producciones profesionales de alta calidad . 76 Fig. 48 Implementaci\u00f3n Controlador MIDI no Convencional en Pandaboard ES . Fuente: Propia La Figura 49 muestra la panta lla principal del FL Studio y la configuraci\u00f3n del puerto de entrada MIDI por Ethernet La transmisi\u00f3n MIDI se lleva acabo exitosamente, con lo cual se logra la recepci\u00f3n de mensajes MIDI desde un Sistema Embebido a un computador utilizando los datos del K inect para el control del sistema. 77 Fig. 49 Interfaz principal FL Studio . Fuente: Propia Fig. 50 Captura de pantalla de la implementaci\u00f3n en el FL Studio . Fuente: Propia 78 La adquisicion de datos del Pure Data se puede observar en la Figura 51, donde a partir del desplazamiento de la persona en los ejes X y Z se generan mensajes MIDI de control y de nota On/Off que son adquiridos por el FL Studio como se observa en la Figura 50, en la que el cambio de control es asiganado al control principal de volum en y las notas On/Off al sintetizador POIZONE23. Fig. 51 Interfaz de captura de los datos del Kinect implementado en Pure Data . Fuente: Propia 23 Sintetizador substractivo dise\u00f1ado para realizar producciones profesional es, se puede implementar como complemento VST o como aplicaci\u00f3n Standalone. 79 6. AN\u00c1LISIS DE RESULTADOS Resultados obtenidos implementando el Sistema Embebido Pandaboard ES con sistema operativo Ubuntu 12.04 se presentan a continuaci\u00f3n : Los datos obtenidos por el computador receptor corresponden a los enviados a trav\u00e9s de Pure D ata como efectivamente se comprob\u00f3 con el MIDI -OX y Kmidimon, esta precisi\u00f3n se logr\u00f3 gracias a la segmentaci \u00f3n de imagen generada por el Kinect, el cual permite crear l\u00edmites de captura, en este caso, una distancia m\u00e1xima de 1.75m y una distancia m\u00ednima de 0.5m. El protocolo UDP es confiable y r\u00e1pido para su implementaci\u00f3n como transmisor MIDI , esto se observ\u00f3 en los resultados obtenidos donde el tiempo de respuesta fue instant\u00e1ne a. La renderizaci\u00f3 n de imagen realizada por la Pandaboard ES es \u00f3ptima y se muestra de una forma fluida, el usuario puede realizar movimientos que se ver\u00e1n proyectados en la pantalla o en la tablet de manera instant\u00e1nea por lo que el usuario puede monitorizar los datos en tiempo real. Con este tipo de sistemas de captura no convencionales se pueden tener imprecisi\u00f3n en los datos que el usuario desea enviar, esto debido a que el sistema de captura por medio de posici\u00f3n no es 100% preciso, a pesar de estos gracias a la habilidad del Kinect para crear l\u00edmites de captura, se puede asegurar que otros objetos no interfieran dentro del sistema. 80 7. CONCLUSIONES El documento presen ta el dise\u00f1o y desarrollo de un controlador MIDI no convencional utilizando el Kinect, implementado en el Sistema E mbebido Pandaboard ES. En el S.E. se implement\u00f3 la distribuci\u00f3n de Ubuntu, la cual permite la instalaci\u00f3n y configuraci\u00f3n de los programas y servicios con los cuales se realiza la transmisi\u00f3n de los datos en prot ocolo MIDI a un computador fijo adquiriendo los datos a partir de movimientos capturados por el Kinect. El desarrollo de la interfaz gr\u00e1fica para la interacci\u00f3n con el usuario fue un apoyo visual para monitorear los datos generados y capturados por el Kinect, el Pure Data fue una herramienta esencial para presentarle al usuario los datos de una forma ordenada y coherente de tal forma que pudiera interpretarlos. La portabilidad de hard ware y software demuestra de los sistemas embebidos son una herramienta de desarrollo eficiente , y el sistema operativo Ubuntu se encuentra en la capacidad de brindar las herramientas suficientes para el desarrollo de nuevas tecnolog\u00edas dentro de los Siste mas Embebidos aplicados a la Ingenier\u00eda de Sonido La implementaci\u00f3n de herramientas tecnol\u00f3gica como los Sistemas Embebidos o el Kinect, permiten el desarrollo de una gran variedad de dispositivos no disponibles en el mercado , adaptables a hardware o software existente. 81 8. PRODUCTOS A partir de la implementaci\u00f3n del proyecto se desarrollaron los siguientes productos: ARTICULOS EN EDICION Desarrollo de un Controlador MIDI no Convencional, Implementado en un Sistema Embebido, Utilizando el Kinect. El art\u00edculo presenta el desarrollo de un controlador MIDI no convencional implementado en un Sistema Embebido utilizando el Kinect. El dispositivo permite utilizar el protocolo MIDI para controlar hardware y/o software remoto v\u00eda WiFi por medio de la captura de m ovimientos. Con la utilizaci\u00f3n de este tipo herramientas tecnol\u00f3gicas se puede construir controladores no convencionales aplicados a la ingenier\u00eda de sonido, integrables a diferentes redes de comunicaci\u00f3n de forma pr\u00e1ctica, eficaz e innovadora. Controlador MIDI WiFi Implementado en un Sistema Embebido . El art\u00edculo presenta el desarrollo del proyecto de Investigaci\u00f3n, en el cual se dise\u00f1\u00f3 un sistema para realizar la transmisi\u00f3n por WiFi del protocolo MIDI, el cual utiliza herramientas de software libre y si stemas embebidos para su implementaci\u00f3n. Compresor de Formato de Audio Desarrollado en Pure Data, Implementado en un Sistema Embebido GRUPO DE INVESTIGACI\u00d3N : Ac\u00fastica Aplicada En el grupo de investigaci\u00f3n ING 006A -028 se desarroll\u00f3 un Sistema De Transmisi \u00f3n Inal\u00e1mbrica Para El Protocolo De Comunicaci\u00f3n Midi, Utilizando Sistemas Embebidos El proyecto consiste en dise\u00f1ar un sistema para realizar la transmisi\u00f3n por WiFi del protocolo MIDI, el cual utilice herramientas de software libre y sistemas embebidos . 82 9. RECOMENDACIONES Crear interfaz de usuario f\u00edsica para generar cambio s del e nsamble de Pure Data en de forma externa al sistema para tener un control especifico , ya fuera por medio de micro -controladores o por sensores inal\u00e1mbricos. Implementar c\u00e1maras alternativas al Kinect como el ASUS Xtion PRO LIVE el cual fue de desarrollado por el mismo grupo que desarrollo el Kinect, pero fue creado espec\u00edficamente para desarrollo y no para una consola de juegos. Buscar Sistema Embebidos y Sistema Operativos alt ernativos que pudieran ser \u00f3ptimos para la implementaci\u00f3n como controladores MIDI no convencionales . 83 BIBLIOGRAF\u00cdA [1] Abbott, Doug. Linux for Embedded and Real -Time Application. Newnes. 2003 [2] Rona, Jeffrey. The MIDI Companion: The Ins, Outs and Throughs. Hal Leonard, 1994 [3] Miles Huber, David. The MIDI Manual: A Practical Guide to MIDI in the Project Studio. 2012 [4] Camargo Bare\u00f1o, Carlos Iv\u00e1n. \" Transferencia tecnol\u00f3gica y de conocimientos en el dise\u00f1o de sistemas embebidos\". Universidad Nacional de Colombia. Bogot\u00e1, Colombia. 2011 [5] Milano, Dominic. Mind Over MIDI. H. Leonard Books. 1987 [6] Zhang, Zhengyou. \"Microsoft Kinect Sensor and Its Effect\" . University of Estados Unidos. [7] Fry, Casey. Getting Gralla, Preston. Anaya Multimedia. 2007 [11] Engst, Adam . Introducci\u00f3n a las redes inal\u00e1mbricas . Anaya Multimedia. 2005 [12] Varela, Carlos. Dominguez, Luis. Redes Inal\u00e1mbricas. Universidad de Valladolid. Vallad olid, Espa\u00f1a. 2002 [13] Werchau, Pablo Jara. Nazar, Patricia. Est\u00e1ndar IEEE 802.11 X de las WLAN. Universidad Tecnol\u00f3gica Nacional. Buenos Aires, Argentina. 84 [14] Capela, Rui Nuno. QmidiNet Diferent Frequencies: Bluetooth, WiFi, and WiMAX , 2007. [16] Steve Development .Auerbach Publications, 2005. [18] Rosas Jim\u00e9nez, Nelson Felipe. Dise\u00f1o E Implementaci\u00f3n De Un Sistema Embebido Para La Adquisici\u00f3n Y Transmisi\u00f3n De Se\u00f1ales Biom\u00e9dicas A Trav\u00e9s De La Red Celular . Universidad Nacional De Colombia. Bogot\u00e1, Colombia. 2011 [19] Amaro Soriano, Jos\u00e9 Enrique. Android: Programaci\u00f3n de dispositivos m\u00f3viles a trav\u00e9s de ejemplos. Marcombo, 2011 [20] Meier, Reto. Professional Android 4 Application Development. John Wiley & Sons, 2012 [21] Gargenta, Marko. Learning Android. O'Reilly Media, Inc., 2011 [22] Thomas, Keir. Ubuntu Pocket Guide and Reference. Ubuntu 2009 Helmke Book . Prentice Unleashed 11.10 Handbook. John Wiley & Sons, 2012 [26] Ray, Deborah S. Ray, Eric J. Unix and Linux. Peachpit Press, 2009 [27] Brinkmann, peter. -time audio on Android and iOS. O'Reilly Media, Inc., 2012 [28] Rosenberg Craig, Moses Bob. Future Human Interfaces to Computer Controlled Sound Systems . University of Washington, Seattle. of Lond res. Inglaterra. 2011 [31] Bartlett Greg. Embedded Controllers for Audio Devices . Pavo, Explorer [39] Yaghmour, Karim. Building O'Reilly 2008 86 [43] o f Embedded System Behavior Using Full-System Software Emulation. University of Maryland. California, Estados Unidos. 2000 [44] Yu, Tingting. Testing Embedded System Applications . University of Nebraska, Lincoln , Estados Unidos. 2010 [45] Huang, Fay. Wang , Reen -Cheng . Arts and Sean, Jared St. Kinect Hacks: Tips & Tools for Motion and Pattern Detection. O'Reilly Media, 2012 [47] Helmke, Matthew - Hudson, Ubuntu Unleashed 2012: Arduino, and MakerBot. O'Reilly Media, Inc., 2012 [49] Webb, Jarrett - Ashley, James. Beginning Kinect Programming with Microsoft t he An Introduction Programming [52] Running: and Running . O'Reil ly Media, Inc., 2010. Books [54] Noble, . O'Reilly Media, Things Talk: Practical Methods for Connecting Objects. O'Reilly Media, Inc., 2007 [56] Harke, Werner. Dom\u00f3tica para Viviendas y Edificios . Marcombo, 2010 [57] Huidobro Moya, Jos\u00e9 Manuel . Mill\u00e1n Tejedor, Ram\u00f3n Jes\u00fas . Dom\u00f3tica: edificios inteligentes . Creaciones Copyright, 2004 87 [58] Shneiderman, Ben. Plaisant, Catherine . Dise\u00f1o de interfaces de usuario: estrategias para una interacci\u00f3n persona -computadora efectiva . Pearson Educaci\u00f3n, 2005 [59] Raskin, Jef. The Human Int erface: New Directions for Designing Interactive Systems. Addison [60] Wong , Ronnie Anthony . Assessment of Open Source Business Strategies in the Domain of Embedded Systems . University of Oulu. Oulu, Finlandia. 2011 [61] Granlund, G\u00f6sta H. Knutsson, Hans. Signal Processing for Computer Vision . Springer, 1994 [62] Ngan, King Ngi. Li, Hongliang. Video Segmentation and . Springer, 2011 [63] , Yu-Jin. Advances in Image And Video Segmentation Idea Inc (IGI), 2006 [64] Belbachir, Smart Cameras. Springer, 2009 [65] Bradski, Kaehler, Adrian. Learning OpenCV: Computer Vision with the OpenCV Library. Perception Thomas S. Real-Time Vision -Computer Interacti on. Springer, Udo . . Source Incorporated, [70] Bigun, Josef. Vision with Direction: A Systematic Introduction to Image Processing and Computer Vision . Springer, 2 006 [71] Dal Mutto, Carlo. Zanuttigh, Pietro. Cortelazzo, Guido M. Time -of-Flight Cameras and Microsoft Kinect. Springer, 2012 [72] Fisher, R. 60 GHz WPAN Standardization within IEEE 802.15.3c 2007 88 [73] Kim, Yong Soo. Kim, Juho . Security enhanced IEEE 802.1x authentication method for router. 2012 [74] Diameter accounting [75] Guo, Chuanxiong. Guo, Zihua. management vertical between WWAN and WLAN . 2003 Adults 2011 [78] Machida E. Human motion tracking of mobile robot with Kinect 3D sensor. Tokyo Metropolitan Coll. of Ind. Technol., Tokyo, Japan , 2012. [79] Noonan, P.J. -Wolfson optical tracking system using the Microsoft Kinect. Univ. of Manchester, Manchester, 2011 [80] Hui Li. Static Hand Gesture Recognition Based on design. Dept. of & Henan Univ. of Pingding shan, China . 2010 [82] Chen Qiu embedded image information processing system design. Dept. of Comput. Sci. Eng., Kinect ICMC - LRM (Mobile Robots Lab.), USP - Univ. of Sao Paulo, Sao Carlos, Brazil, 2012 [84] Yihua Lou. A Multi -User Interaction System Based on Kinect and Wii Lab. of Software Dev. Environ., Beihang Univ., Beijing, C hina, 2012. 89 GLOSARIO TERMINAL: Es una forma de acceder al sistema sin utilizar la interfaz gr\u00e1fica, realizar todo tipo de tareas en formato texto. EXTERNAL: Complementos de librer\u00edas de Pure Data. COMPILACI\u00d3N: Proceso de traducci\u00f3n de un c\u00f3digo a datos que puedan ser ejecutados por una computadora. CROSS COMPILACI\u00d3N: Proceso de traducci\u00f3n de un c\u00f3digo de datos de un sistema a otro. MULTICAST: En espa\u00f1ol \"Multidifusi\u00f3n\", es el env\u00edo de la informaci\u00f3n en una red a m\u00faltiples destinos simult\u00e1neamente. COMAND OS SHELL: Sistemas de comandos utilizados por el sistema UNIX que permite administrar el sistema sin entorno gr\u00e1fico. KERNEL: o N\u00facleo, es el encargado de conectar el hardware con el software y gestionar los recursos de manera adecuada. ROOT FILE SYSTEM (R FS): Es el conjunto de archivos fundamentales para ejecutar un sistema operativo. S.E.: Sistema Embebido S.O.E.: Sistema Operativo Embebido . FREENECT : Controlador para Kinect desarrollado por la comunidad Open Kinect TOUCHOSC: Superficie de control MIDI y OSC que utiliza el protocolo UDP para el env\u00edo de datos por medio de WiFi, desarrollado para Android e iOS SOCKETS : Mecanismo que permite la conexi\u00f3n entre distintos procesos OMAP: Procesador multin\u00fa cleo ARM desarrollado para diferentes aplicaciones embeb idas, fabricado po r Texas Instruments HDMI (High -Definition Multimedia Interface ): Conector de audio y v\u00eddeo digital cifrado sin compresi\u00f3n de alta definici\u00f3n. IPV4 : Cuarta versi\u00f3n del protocolo de comunicaci\u00f3n de datos digitales clasificado funcionalmente en la Capa de Red . 90 UDP (User Datagram Protocol ): Protocolo basado en el intercambio de datagramas a trav\u00e9s de la red , sin necesidad de establecer previamente una conexi\u00f3n . SISTEMA DOMOTICO : Sistemas aplicados al control y la automatizaci\u00f3n inteligente de una vivienda, aportando servicios de gesti\u00f3n energ\u00e9tica, seguridad, bienestar o comunicaci\u00f3n . 91 ANEXO A : Fotos e Im\u00e1genes Complementarias Fig. 52 Pandaboard ES conectada remotamente a Samsung Galaxy Tab 10.1 . Fuente: Propia Fig. 53 Interfaz del editor conexiones de red . Fuente: Propia 92 Fig. 54 Configuraci\u00f3n de control remoto MIDI de FL Studio. Fuente: Propia Fig. 5 5 Conexi\u00f3n Pandaboard ES con el Kinect . Fuente: Propia 93 Fig. 56 Interfaz de usuario de TouchOSC para Samsung Galaxy Tab 10.1 . Fuente: Propia Fig. 57 Controlador MIDI Virtual VMPK . Fuente: Propia 94 Fig. 5 8 Ensamble de recepci\u00f3n OSC desde la aplicaci\u00f3n TouchOSC. Fuente: Propia 95 ANEXO B : Anexos digitales Los siguientes archivos se encuentran en el CD anexado al documento: A1. Video prueba del Controlador MIDI no Convencional . \"Tesis.mp4 \" A2. Videos demostrativos diferentes fases de desarrollo y productos realizados en el proceso. \"Compresor.mp4 \" y \"ControladorMidi.mp4 \" "}