{"title": "PDF", "author": "PDF", "url": "https://www.uoc.edu/pdf/masters/oficiales/img/913.pdf", "hostname": "PDF", "description": "PDF", "sitename": "PDF", "date": "PDF", "cleaned_text": "Rafael Camps Par\u00e9 Software libre U Formaci\u00f3n de PosgradoBases de datos 71Z799014MOOscar P\u00e9rez MoraCarme 71Z799014MO 2 Bases de datos David Meg\u00edas Jim\u00e9nez Jordi Mas Hern\u00e1ndez Rafael Camps Par\u00e9 Coordinador Coordinador Autor Ingeniero de Inform\u00e1tica por la UAB. Mag\u00edster en T\u00e9cnicas Avanzadas de Automatizaci\u00f3n de Procesos por la UAB. Doctor en Inform\u00e1tica por la UAB. Profesor de los Estudios de Inform\u00e1tica y Multimedia de la UOC.Coordinador general de Softcatal\u00e0 y desarrollador del procesador de textos libre Abiword. Miembro fundador de Softcatal\u00e0 y de la red telem\u00e1tica RedBBS. En calidad de consultor, ha trabajado en empresas como Menta, Tel\u00e9polis, Vodafone, Lotus, eresMas, Amena y Terra Espa\u00f1a.Profesional inform\u00e1tico en varias empresas. Ha sido profesor universitario en la Facultad de Inform\u00e1tica de Barcelona de la Universidad Polit\u00e9cnica de Catalu\u00f1a. Actualmente est\u00e1 adscrito a la Escuela Universitaria Polit\u00e9cnica de Vilanovai la Geltr\u00fa. Luis Alberto Casillas Santill\u00e1n Dolors Costal Costa Marc Gibert Ginest\u00e0 Autor Autora Autor Licenciado en Inform\u00e1tica (1995), maestro en Sistemas (1998), doctorante en Ingenier\u00eda y Tecnolog\u00eda (2003), est\u00e1 estudiando el doctorado en la UOC. Profesor universitario desde marzo de 1995. Investigador en Inteligencia Artificial desde 1998. Consultor Universitario para cuestiones educativas.Doctora en Inform\u00e1tica por la Universidad Polit\u00e9cnica de Catalu\u00f1a. Profesora titular del Departamento de Lenguajes y Sistemas Inform\u00e1ticos de la Universidad Polit\u00e9cnica de Catalu\u00f1a, asignada a la Facultad de Inform\u00e1tica de Barcelona.Ingeniero en Inform\u00e1tica por la Universidad Ramon Llull. Socio fundador y jefe de proyectos de Cometa Technologies, empresa dedicada a dar soluciones en tecnolog\u00edas de la informaci\u00f3n, basadas en el uso de est\u00e1ndares y herramientas de c\u00f3digo abierto. Profesor del M\u00e1ster en Seguridad en Tecnolog\u00edas de la Informaci\u00f3n en Enginyeria y Arquitectura La Salle y consultor del Master Internacional en Software Libre de la UOC. Carme Mart\u00edn Escofet Oscar P\u00e9rez Mora Autora Autor Licenciada en Inform\u00e1tica por la Universidad Polit\u00e9cnica de Catalu\u00f1a. Profesora de la asignatura Introducci\u00f3n a las bases de datos en la Facultad de Inform\u00e1tica de Barcelona, y de la asignatura Sistemas orientados a bases de datos en la Facultad de Matem\u00e1ticas y Estad\u00edstica. Tambi\u00e9n ha sido profesora de las asignaturas Dise\u00f1o de sistemas y Gesti\u00f3n de sistemas inform\u00e1ticos en la Escuela Universitaria Polit\u00e9cnica de Vilanova i la Geltr\u00fa.Ingeniero en Comunicaciones y Electr\u00f3nica por la Universidad de Guadalajara (M\u00e9xico) y Maestro en Sistemas de Informaci\u00f3n. Ha participado en diversas publicaciones e impartido cursos especializados. Miembro Fundador del Marichi del SUTUdeG y del Grupo Linux de Occidente A. C. (www.glo.org.mx). Organizador del Festival GNU/Linux y Software Libre (http://www.festivaldesoftwarelibre.org). Primera edici\u00f3n: mayo 2005 \u00a9 Fundaci\u00f3 per a la Universitat Oberta de Catalunya Av. Tibidabo, 39-43, 08035 BarcelonaMaterial realizado por Eureca Media, SL Camps Par\u00e9, Luis Alberto Casillas Santill\u00e1n, Dolors Costal Costa, Marc MoraDep\u00f3sito legal: B-15.562-2005 ISBN: 84-9788-269-5 Se garantiza permiso para copiar, distribuir y mo dificar este documento seg\u00fan los t\u00e9rminos de la GNU Free Documentation License , Version 1.2 o cualquiera posterior publicada por la Free Software Foundation , sin secciones invariantes ni textos de cubierta delantera o trasera. Se dispone de una copia de la licencia en el apartado \"GNU Free Documentation License\" de este documento. FUOC 71Z799014MO 3 Bases de datos Agradecimientos Los autores agradecen a la Fundaci\u00f3n para la Universitat Oberta de Catalunya (http://www.uoc.edu) la financiaci\u00f3n de la primera edici\u00f3n de esta obra, en- marcada en el M\u00e1ster Internacional en Software Libre ofrecido por la citada instituci\u00f3n. El autor \u00d3scar P\u00e9rez Mora desea hacer co nstar el agradecimiento siguiente: \"A Jos\u00e9 P\u00e9rez Arias, gracias po r haber sido mi padre\", en memoria de su padre fa- llecido durante la realiz aci\u00f3n de este material. FUOC 71Z799014MO 5 Bases de datos Introducci\u00f3n Las bases de datos son el m\u00e9todo prefer ido para el almace namiento estructu- rado de datos. Desde las grandes aplicac iones multiusuario, hasta los tel\u00e9fonos m\u00f3viles y las agendas electr\u00f3nicas utilizan tecnolog\u00eda de bases de datos para ase- gurar la integridad de los datos y facilitar la labor tanto de usuarios como de los programadores que las desarrollaron. Desde la realizaci\u00f3n del primer modelo de datos, pasando por la administra- ci\u00f3n del sistema gestor, hasta llegar al de sarrollo de la aplicaci\u00f3n, los conceptos y la tecnolog\u00eda asociados son muchos y muy heterog\u00e9neos. Sin embargo, es im- prescindible conocer los aspectos clave de cada uno de estos temas para tener \u00e9xito en cualquier proyec to que implique trabajar con bases de datos. En este curso trataremos de dar una visi\u00f3n completa de los conceptos relacio- nados con los sistemas gestores de bases de datos. En los primeros cap\u00edtulos ve- remos los aspectos involucrados en los motores de estos almacenes de datos, su evoluci\u00f3n hist\u00f3rica y los di stintos tipos de organizaci \u00f3n y abs-tracci\u00f3n que han ido surgiendo desde su conceptualizaci\u00f3n hasta nuestros d\u00edas. A continuaci\u00f3n profundizaremos en el modelo llamado relacional (el m\u00e1s usa- do en nuestros d\u00edas), proporcionando los m\u00e9todos y herramientas que nos per- mitan representar necesidades de almacenamiento y consulta de datos en este modelo. En el siguiente cap\u00edtulo estudiar emos a fondo el lenguaje de consultas estructurado SQL, imprescindible para tr abajar con bases de datos relacionales, ya sea directamente o a trav\u00e9s de cualquier lenguaje de programaci\u00f3n. El dise\u00f1o de bases de datos tiene tamb i\u00e9n un cap\u00edtulo dedicado a aprender a modelar y representar gr\u00e1ficamente una ba se de datos, a detectar los posibles problemas de dise\u00f1o antes de que \u00e9stos af ecten a la aplicaci\u00f3n, y a construir ba- ses de datos \u00f3ptimas para los distintos casos de relaciones entre entidades que formar\u00e1n nuestra base de datos. Una vez sentadas estas bases, estaremos en disposici\u00f3n de examinar detenida- mente dos de los sistemas gestores de bases de datos de software libre m\u00e1s usa-dos y populares actualmente. As\u00ed pues, ap renderemos el uso, administraci\u00f3n y particularidades de MySQL y PostgreSQL mediante ej emplos y casos pr\u00e1cticos. Tambi\u00e9n veremos las herramientas de co nsulta y administra ci\u00f3n gr\u00e1ficas para estos dos sistemas gestores de bases de datos, que nos permitir\u00e1n mejorar nues- tra productividad en el trabajo diario con ellos. A continuaci\u00f3n, veremos los m\u00e9todos de acceso a estos sistemas gestores de bases de datos desde algunos lenguajes de programaci\u00f3n. En cada caso, comentaremos FUOC 71Z799014MO 6 Bases de datos las mejores pr\u00e1cticas para cada uno, as\u00ed como sus particularidades, e introducire- mos algunos conceptos relacionados con la programaci\u00f3n en bases de datos como la persistencia, tratamiento de errores, etc. Finalmente, creemos que la mejor forma de finalizar este curso es mediante un caso de estudio completo que aborde lo s temas tratados en todos los cap\u00edtulos, en el orden en que se producir\u00edan en la realidad de un proyecto y primando la pr\u00e1ctica sobre la teor\u00eda. As\u00ed pues, este curso trata de proporcionar al estudiante una visi\u00f3n completa de los aspectos implicados en el trabajo co n bases de datos. Aunque no profundi- zaremos en algunos temas muy especializados como el dise\u00f1o interno de un sis- tema gestor de bases de datos, profun dizaremos t\u00e9cnicamente en los temas m\u00e1s necesarios. FUOC 71Z799014MO 7 Bases de datos Objetivos Los objetivos que el estudiante deber\u00e1 alcanzar al finalizar el curso Bases de datos son los siguientes: Comprender los diferentes modelos de bases de datos, y en concreto do- minar el modelo relacional. Ser capaz de realizar el modelo de un a base de datos relacional, a partir de la especificaci\u00f3n de requ erimientos de un proyecto, comprendiendo y apli- cando los conceptos y tran sformaciones implicados. Conocer el uso y administraci\u00f3n de do s de los gestores de bases de datos relacionales m\u00e1s populares en el \u00e1mbi to del software libre: PostgreSQL y MySQL. Tener experiencia en el desarrollo de aplicaciones en conexi\u00f3n con bases de datos en varios lenguajes. FUOC 71Z799014MO 8 Bases de datos Contenidos M\u00f3dulo did\u00e1ctico 1 Introducci\u00f3n a las bases de datosRafael Camps Par\u00e91. Concepto y origen de las BD y de los SGBD2. Evoluci\u00f3n de los SGBD3. Objetivos y funcio nalidad de los SGBD 4. Arquitectura de los SGBD 5. Modelos de BD6. Lenguajes y usuarios7. Administraci\u00f3n de BD M\u00f3dulo did\u00e1ctico 2 El modelo relacional y el \u00e1lgebra relacionalDolors Costal Costa 1. Introducci\u00f3n al modelo relacional 2. Estructura de los datos3. Operaciones del modelo relacional4. Reglas de integridad5. El \u00e1lgebra relacional M\u00f3dulo did\u00e1ctico 3 El lenguaje SQL Carme Mart\u00edn Escofet1. Sentencias de definici\u00f3n2. Sentencias de manipulaci\u00f3n3. Sentencias de control4. Sublenguajes especializados M\u00f3dulo did\u00e1ctico 4 Introducci\u00f3n al dise\u00f1o de bases de datos Dolors Costal Costa1. Introducci\u00f3n al dise\u00f1o de bases de datos2. Dise\u00f1o conceptual: el modelo ER3. Dise\u00f1o l\u00f3gico: la transformaci\u00f3n de l modelo ER en el modelo relacional M\u00f3dulo did\u00e1ctico 5 Bases de datos en MySQLLuis Alberto Casillas Sa ntill\u00e1n; Marc Gibert Gi nest\u00e0; Oscar P\u00e9rez Mora 1. Caracter\u00edsticas de MySQL 2. Acceso a un servidor MySQL 3. Creaci\u00f3n y manipulaci\u00f3n de tablas FUOC 71Z799014MO 9 Bases de datos 4. Consultas 5. Administraci\u00f3n de MySQL 6. Clientes gr\u00e1ficos M\u00f3dulo did\u00e1ctico 6 Bases de datos en PostgreSQL Marc Gibert Ginest\u00e0; Oscar P\u00e9rez Mora1. Caracter\u00edsticas de PostgreSQL 2. Introducci\u00f3n a la orientaci\u00f3n a objetos 3. Acceso a un servidor PostgreSQL 4. Creaci\u00f3n y manipulaci\u00f3n de tablas 5. Manipulaci\u00f3n de datos 6. Funciones y disparadores 7. Administraci\u00f3n de PostgreSQL 8. Cliente gr\u00e1fico: pgAdmin3 M\u00f3dulo did\u00e1ctico 7 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos Marc Gibert Ginest\u00e0 1. Conexi\u00f3n y uso de bases de datos en lenguaje PHP 2. Conexi\u00f3n y uso de bases de datos en lenguaje Java M\u00f3dulo did\u00e1ctico 8 Caso de estudio Marc Gibert Ginest\u00e0 1. Presentaci\u00f3n del caso de estudio 2. El modelo relacional y el \u00e1lgebra relacional 3. El lenguaje SQL 4. Introducci\u00f3n al dise\u00f1o de bases de datos 5. Bases de datos en MySQL 6. Bases de datos en PostgreSQL 7. Desarrollo de aplicaciones en conexi\u00f3n con bases de datos Ap\u00e9ndice GNU Free Documentation LicenseIntroducci\u00f3n a las bases de datos Rafael Camps Par\u00e9 FUOC 71Z799014MO Introducci\u00f3n a las bases de datos \u00cdndice Introducci\u00f3n ............................................................................................... 5 Objetivos ...................................................................................................... 5 1. Concepto y origen de las BD y de los SGBD ................................... 7 2. Evoluci\u00f3n de los SGBD ........................................................................ 9 2.1. Los a\u00f1os sesenta y setenta: sistemas centralizados ........................... 9 2.2. Los a\u00f1os ochenta: SGBD relacionales................................................ 9 2.3. Los a\u00f1os noventa: distribuci\u00f3n, C/S y 4GL....................................... 10 2.4. Tendencias actuales ........................................................................... 13 3. Objetivos y servicios de los SGBD ..................................................... 15 3.1. Consultas no predefinidas y complejas............................................. 15 3.2. Flexibilidad e independen cia............ ............. .......... .......... .......... ...... 15 3.3. Problemas de la redundancia ............................................................ 16 3.4. Integridad de los datos ...................................................................... 18 3.5. Concurrencia de usuarios .................................................................. 18 3.6. Seguridad ........................................................................................... 21 3.7. Otros objetivos................................................................................... 21 4. Arquitectura de los SGBD .................................................................. 22 4.1. Esquemas y niveles ............................................................................ 22 4.2. Independencia de los datos ............................................................... 25 4.3. Flujo de datos y de control................................................................ 27 5. Modelos de BD ....................................................................................... 29 6. Lenguajes y usuarios ............................................................................ 32 7. Administraci\u00f3n de BD ........................................................................ 35 Resumen ....................................................................................................... 36 Actividades .................................................................................................. 37 Ejercicios de autoevaluaci\u00f3n .................................................................. 37 ........................................................................................................ 38 Bibliograf\u00eda ................................................................................................. 39 FUOC 71Z799014MO 5 Introducci\u00f3n a las bases de datos Introducci\u00f3n a las bases de datos Introducci\u00f3n Empezaremos esta unidad did\u00e1ctica viendo cu\u00e1les son los objetivos de los sistemas de gesti\u00f3n de las bases de datos (SGBD) y, a continuaci\u00f3n, daremos una visi\u00f3n general de la arquitectura , el funcionamiento y el entorno de estos sistemas. Objetivos En los materiales did\u00e1cticos de esta unid ad encontrar\u00e9is las herramientas para ad - quirir una visi\u00f3n global del mundo de las BD y de los SGBD, as\u00ed como para alcanzar los siguientes objetivos: 1.Conocer a grandes rasgos la evoluci\u00f3n de los SGBD desde los a\u00f1os sesenta hasta la actualidad. 2.Distinguir los principales objetivos de los SGBD actuales y contrastarlos con los sistemas de fi cheros tradicionales. 3.Saber explicar mediante ejemplos lo s problemas que intenta resolver el concepto de transacci\u00f3n . 4.Relacionar la idea de flexibilidad en los cambios con la independencia l\u00f3 - gica y f\u00edsica de los datos, as\u00ed como con la arquitectura de tres niveles. 5.Distinguir los principales modelos de BD. 6.Conocer a grandes rasgos el funcionamiento de un SGBD. 7.Saber relacionar los diferentes tipos de lenguajes con los diferentes tipos de usuarios. FUOC 71Z799014MO 7 Introducci\u00f3n a las bases de datos 1. Concepto y origen de las BD y de los SGBD Las aplicaciones inform\u00e1ticas de los a\u00f1os sesenta acostumbraban a darse total - mente por lotes ( batch ) y estaban pensadas para un a tarea muy espec\u00edfica rela - cionada con muy pocas entidades tipo. Cada aplicaci\u00f3n (una o va rias cadenas de programas) utilizaba ficheros de mo - vimientos para actualizar (creando una copia nueva) y/o para consultar uno o dos ficheros maestros o, excepcionalmente, m\u00e1s de dos. Cada programa trata - ba como m\u00e1ximo un fichero maestro, que sol\u00eda estar sobre cinta magn\u00e9tica y, en consecuencia, se trabajaba con acceso secuencial. Cada vez que se le quer\u00eda a\u00f1adir una aplicaci\u00f3n que requer\u00eda el us o de algunos de los datos que ya exis - t\u00edan y de otros nuevos, se dise\u00f1aba un fichero nuevo con todos los datos ne - cesarios (algo que provocaba redundancia) para evitar que los programas tuviesen que leer muchos ficheros. A medida que se fueron introduciendo las l\u00edneas de comunicaci\u00f3n, los termi - nales y los discos, se fueron escribie ndo programas que permit\u00edan a varios usuarios consultar los mismos ficheros on-line y de forma simult\u00e1nea. M\u00e1s ade - lante fue surgiendo la necesidad de hacer las actua lizaciones tambi\u00e9n on-line . A medida que se integraban las aplicaciones, se tuvieron que interrelacionar sus ficheros y fue necesario eliminar la redundancia. El nuevo conjunto de fi - cheros se deb\u00eda dise\u00f1ar de modo que estuviesen interrelacionados; al mismo tiempo, las informaciones redundantes (como por ejemplo, el nombre y la di - recci\u00f3n de los clientes o el nombre y el precio de lo s productos), que figuraban en los ficheros de m\u00e1s de una de las aplic aciones, deb\u00edan estar ahora en un solo lugar. El acceso on-line y la utilizaci\u00f3n eficiente de la s interrelaciones exig\u00edan estruc - turas f\u00edsicas que diesen un acceso r\u00e1pido, como por ejemplo los \u00edndices, las multilistas, las t\u00e9cnicas de hashing , etc. Estos conjuntos de ficher os interrelacionados , con estructuras complejas y compartidos por varios procesos de forma simult\u00e1nea (unos on-line y otros por lotes), recibieron al pr incipio el nombre de Data Banks , y despu\u00e9s, a inicios de los a\u00f1os setenta, el de Data Bases . Aqu\u00ed los denominamos bases de datos (BD) . El software de gesti\u00f3n de ficheros era demasiado elemental para dar satisfac - ci\u00f3n a todas estas necesidades. Por ejemplo, el tratamiento de las interrelaciones no estaba previsto, no era posible que va rios usuarios actualizaran datos simul - t\u00e1neamente, etc. La utilizaci\u00f3n de estos conjuntos de ficheros por parte de los programas de aplicaci\u00f3n era excesivamente compleja, de modo que, especial - mente durante la segunda mitad de los a\u00f1 os setenta, fue saliendo al mercado Aplicaciones inform\u00e1ticas de los a\u00f1os sesenta La emisi\u00f3n de facturas, el control de pedidos pendientes de servir, el mantenimiento del fichero de productos o la n\u00f3mina del personal eran algunas de las aplicaciones inform\u00e1ticas habituales en los a\u00f1os sesenta. Integraci\u00f3n de aplicaciones Por ejemplo, se integra la aplicaci\u00f3n de facturas, la de pedidos pendientes y la gesti\u00f3n del fichero de productos. FUOC 71Z799014MO 8 Introducci\u00f3n a las bases de datos software m\u00e1s sofisticado: los Data Base Management Systems , que aqu\u00ed denomi - namos sistemas de gesti\u00f3n de BD (SGBD) . En otras palabras, una base de datos es un conjunto estructurado de datos que representa entidades y sus interrelaciones . La representaci\u00f3n ser\u00e1 \u00fanica e inte - grada, a pesar de que de be permitir utilizacione s varias y simult\u00e1neas. Los ficheros tradicionales y las BD Aunque de forma muy simplificada, podr\u00edamos en umerar las principales diferencias entre los ficheros tradicionales y las BD tal y como se indica a continuaci\u00f3n: 1)Entidades tipos: Ficheros: tienen registros de una sola entidad tipo. BD: tienen datos de varias entidades tipo. 2)Interrelaciones: Ficheros: el sistema no interrelaciona ficheros. BD: el sistema tiene previstas herrami entas para interrelacionar entidades. 3)Redundancia: Ficheros: se crean ficheros a la medida de cada aplicaci\u00f3n, con todos los datos necesarios aunque algunos sean redundantes respecto de otros ficheros. BD: todas las aplicaciones trabajan con la mism a BD y la integraci\u00f3n de los datos es b\u00e1sica, de modo que se evita la redundancia. 4)Usuarios Ficheros: sirven para un solo usuario o una sola aplicaci\u00f3n. Dan una sola visi\u00f3n del mundo real. BD: es compartida por muchos usuarios de distintos tipos. Ofrece varias visiones del mundo real.Con todo lo que hemos dicho hasta ah ora, podr\u00edamos definir el t\u00e9rmino BD; una base de datos de un SI es la representaci\u00f3n integrada de los con - juntos de entidades instancia correspo ndientes a las diferentes entidades tipo del SI y de sus interrelaciones. Esta representaci\u00f3n inform\u00e1tica (o conjunto estructurado de datos) de be poder ser utilizada de forma com - partida por muchos usuarios de distintos tipos. FUOC 71Z799014MO 9 Introducci\u00f3n a las bases de datos 2. Evoluci\u00f3n de los SGBD Para entender mejor qu\u00e9 son los SGBD, haremos un repaso de su evoluci\u00f3n desde los a\u00f1os sesenta hasta nuestros d\u00edas. 2.1. Los a\u00f1os sesenta y sete nta: sistemas centralizados Los primeros SGBD -en los a\u00f1os sesenta todav\u00eda no se les denominaba as\u00ed- estaban orientados a facilit ar la utilizaci\u00f3n de grande s conjuntos de datos en los que las interrelaciones eran compleja s. El arquetipo de aplicaci\u00f3n era el Bill of materials o Parts explosion , t\u00edpica en las industrias del autom\u00f3vil, en la cons - trucci\u00f3n de naves espaciales y en campos similares. Estos sistemas trabajaban exclusivamente por lotes ( batch ). Al aparecer los terminales de teclado, conectados al ordenador central mediante una l\u00ednea telef\u00f3nica, se em piezan a construir grandes aplicaciones on-line tran - saccionales (OLTP) . Los SGBD estaban \u00edntimamente ligados al software de co - municaciones y de gesti\u00f3n de transacciones. Aunque para escribir los programas de aplicaci\u00f3n se utilizaban lenguajes de alto nivel como Cobol o PL/I, se dispon \u00eda tambi\u00e9n de instrucciones y de subru - tinas especializadas para tratar las BD que requer\u00edan que el programador cono - ciese muchos detalles del dise\u00f1o f\u00edsico, y que hac\u00edan que la programaci\u00f3n fuese muy compleja. Puesto que los programas estaban relacion ados con el nivel f\u00edsico, se deb\u00edan modificar continuamente cuando se hac\u00ed an cambios en el dise\u00f1o y la organi - zaci\u00f3n de la BD. La preocupaci\u00f3n b\u00e1si ca era maximizar el rendimiento: el tiempo de respuesta y las transacciones por segundo. 2.2. Los a\u00f1os ochenta: SGBD relacionales Los ordenadores minis , en primer lugar, y despu\u00e9s los ordenadores micros , extendieron la inform\u00e1tica a pr\u00e1cticamente todas las empresas e instituciones. Los SGBD de los a\u00f1os sesenta y setenta (IMS de IBM, IDS de Bull, DMS de Univac, etc.) eran sistemas totalmente centralizados , como corres - ponde a los sistemas operativos de aquellos a\u00f1os, y al hardware para el que estaban hechos: un gran ordenado r para toda la empresa y una red de terminales sin inteligencia ni memoria. El Data Base / Data Comunications IBM denominaba Data Base/ Data Comunications (DB/DC) el software de comunicaciones y de gesti\u00f3n de transacciones y de datos. Las aplicaciones t\u00edpicas eran la reserva/compra de billetes a las compa\u00f1\u00edas a\u00e9reas y de ferrocarriles y, un poco m\u00e1s tarde, las cuentas de clientes en el mundo bancario. FUOC 71Z799014MO 10 Introducci\u00f3n a las bases de datos Esto exig\u00eda que el desarrollo de aplic aciones fuese m\u00e1s sencillo. Los SGBD de los a\u00f1os setenta eran demasiado complejo s e inflexibles, y s\u00f3lo los pod\u00eda uti - lizar un personal muy cualificado. Todos estos factores hacen que se extien da el uso de los SGBD. La estandariza - ci\u00f3n, en el a\u00f1o 1986, del lenguaje SQL produjo una aut\u00e9ntica explosi\u00f3n de los SGBD relacionales. Los ordenadores personales Durante los a\u00f1os ochenta aparecen y se extienden muy r\u00e1pidamente los ordenadores perso - nales. Tambi\u00e9n surge software para estos equipos monousuario (por ejemplo, dBase y sus de - rivados, Access), con los cuales es muy f\u00e1cil crear y utilizar conjuntos de datos, y que se denominan personal data bases . Notad que el hecho de denomi nar SGBD estos primeros sis - temas para PC es un poco forzado, ya que no aceptaban estructuras complejas ni interrela - ciones, ni pod\u00edan ser utilizados en una red que sirviese simult\u00e1neamente a muchos usuarios de diferentes tipos. Sin embargo, algunos, co n el tiempo, se han ido convirtiendo en aut\u00e9n - ticos SGBD. 2.3. Los a\u00f1os noventa: distribuci\u00f3n, C/S y 4GL Al acabar la d\u00e9cada de los ochenta, lo s SGBD relacionales ya se utilizaban pr\u00e1c - ticamente en todas las empresas. A pesar de todo, hasta la mitad de los noven - ta, cuando se ha necesitado un rendim iento elevado se han seguido utilizando los SGBD prerrelacionales. A finales de los ochenta y principios de los noventa, las empresas se han en - contrado con el hecho de que sus departamentos han ido comprando orde - nadores departamentales y personales, y han ido haciendo aplicaciones con BD. El resultado ha sido que en el seno de la empresa hay numerosas BD y varios SGBD de diferentes tipos o proveedores. Este fen\u00f3meno de multiplica - ci\u00f3n de las BD y de los SGBD se ha visto incrementado por la fiebre de las fusiones de empresas. Esta distribuci\u00f3n ideal se consigue cu ando las diferentes BD son soportadas por una misma marca de SGBD, es decir, cuando hay homogeneidad. Sin em -La aparici\u00f3n de los SGBD relacionales* supone un avance importante para facilitar la programaci\u00f3n de aplicaciones con BD y para conseguir que los programas sean in dependientes de los aspe ctos f\u00edsicos de la BD. La necesidad de tener una visi\u00f3n global de la empresa y de interrelacio - nar diferentes aplicaciones que utiliz an BD diferentes , junto con la fa - cilidad que dan las redes para la intercomunicac i\u00f3n entre ordenadores, ha conducido a los SGBD actuales, que permiten que un programa pue - da trabajar con diferentes BD como si se tratase de una sola. Es lo que se conoce como base de datos distribuida . * Oracle aparece en el a\u00f1o 1980. FUOC 71Z799014MO 11 Introducci\u00f3n a las bases de datos bargo, esto no es tan senc illo si los SGBD son hetero g\u00e9neos. En la actualidad, gracias principalmente a la estandariz aci\u00f3n del lenguaje SQL, los SGBD de marcas diferentes pueden darse servicio unos a otros y colaborar para dar ser - vicio a un programa de apli caci\u00f3n. No obstante, en general, en los casos de he - terogeneidad no se llega a poder dar en el programa que los utiliza la apariencia de que se trata de una \u00fanica BD. Figura 1 Adem\u00e1s de esta distribuci\u00f3n \"impuesta\", al querer tratar de forma integrada distintas BD preexistentes, tambi\u00e9n se puede hacer una distribuci\u00f3n \"desea - da\", dise\u00f1ando una BD distribuida f\u00edsica mente, y con ciertas partes replicadas en diferentes sistemas. Las razones b\u00e1sicas por las que interesa esta distribu - ci\u00f3n son las siguientes: 1) Disponibilidad . La disponibilidad de un si stema con una BD distribuida puede ser m\u00e1s alta, porque si queda fuera de servicio uno de los sistemas, los de - FUOC 71Z799014MO 12 Introducci\u00f3n a las bases de datos m\u00e1s seguir\u00e1n funcionando. Si los datos re sidentes en el sistema no disponible est\u00e1n replicados en otro sistema, contin uar\u00e1n estando disponibles. En caso con - trario, s\u00f3lo estar\u00e1n disponibles los datos de los dem\u00e1s sistemas. 2) Coste . Una BD distribuida puede reducir el coste. En el caso de un sistema centralizado, todos los equipos usuarios, que pueden estar distribuidos por dis - tintas y lejanas \u00e1reas geogr\u00e1ficas, est\u00e1 n conectados al sistema central por medio de l\u00edneas de comunicaci\u00f3n. El coste tota l de las comunicaciones se puede redu - cir haciendo que un usuario tenga m\u00e1 s cerca los datos que utiliza con mayor frecuencia; por ejemplo, en un ordenador de su propia oficina o, incluso, en su ordenador personal. Por ejemplo, un programa de aplicaci\u00f3n que un usuario ejecuta en su PC (que est\u00e1 conectado a una red) pide ciertos datos de una BD que reside en un equipo UNIX donde, a su vez, se ejecuta el SG BD relacional que la gestiona. El progra - ma de aplicaci\u00f3n es el client e y el SGBD es el servidor. Un proceso cliente puede pedir servicios a varios servidores. Un servidor puede recibir peticiones de muchos clientes. En general, un proceso A que hace de cliente, pidiendo un servicio a otro proceso B puede hacer tambi\u00e9n de servidor de un servicio que le pida otro proceso C (o incluso el B, que en esta petici\u00f3n ser\u00eda el cliente). Incluso el cliente y el servidor pueden residir en un mismo sis - tema. Figura 2La tecnolog\u00eda que se utiliza habitualme nte para distribuir datos es la que se conoce como entorno (o arquitectura) cliente/servidor (C/S) . Todos los SGBD relacionales del mercado han sido adaptados a este entorno. La idea del C/S es senc illa. Dos procesos diferent es, que se ejecutan en un mismo sistema o en sistemas separados, act\u00faan de forma que uno tiene el papel de cliente o peticionario de un servicio, y el otro el de ser- vidor o proveedor del servicio. Otros servicios Notad que el servicio que da un servidor de un sistema C/S no tiene por qu\u00e9 estar relacionado con las BD; puede ser un servicio de impresi\u00f3n, de env\u00edo de un fax, etc., pero aqu\u00ed nos interesan los servidores que son SGBD. FUOC 71Z799014MO 13 Introducci\u00f3n a las bases de datos La facilidad para disponer de distribuci\u00f3n de datos no es la \u00fanica raz\u00f3n, ni si - quiera la b\u00e1sica, del gran \u00e9xito de los entornos C/S en los a\u00f1os noventa. Tal vez el motivo fundamental ha sido la fl exibilidad para construir y hacer crecer la configuraci\u00f3n inform\u00e1tica global de la empresa, as\u00ed como de hacer modifi - caciones en ella, mediante hardware y software muy est\u00e1ndar y barato. El \u00e9xito de las BD, incluso en sistemas personales , ha llevado a la aparici\u00f3n de los Fourth Generation Languages (4GL) , lenguajes muy f\u00e1ciles y potentes, es - pecializados en el desarro llo de aplicaciones fundam entadas en BD. Proporcio - nan muchas facilidades en el momento de definir, generalmente de forma visual, di\u00e1logos para introducir, modificar y consultar datos en entornos C/S. 2.4. Tendencias actuales Los tipos de datos que se pueden definir en los SGBD relacionales de los a\u00f1os ochenta y noventa so n muy limitados. La incorporaci\u00f3n de tecnolog\u00edas multimedia -imagen y sonido- en los SI hace necesario que los SGBD relacio - nales acepten atributos de estos tipos. Sin embargo, algunas aplicaciones no tien en suficiente con la incorporaci\u00f3n de tipos especializados en multimedia. Necesitan tipos complejos que el desarro - llador pueda definir a medi da de la aplicaci\u00f3n. En definitiva, se necesitan tipos abstractos de datos: TAD . Los SGBD m\u00e1s recientes ya incorporaban esta posi - bilidad, y abren un amplio mercado de TA D predefinidos o librer\u00edas de clases. Esto nos lleva a la orientaci\u00f3n a objetos (OO) . El \u00e9xito de la OO al final de los a\u00f1os ochenta, en el desarrollo de software b\u00e1sico, en las aplicaciones de inge - nier\u00eda industrial y en la construcci\u00f3n de interfaces gr\u00e1ficas con los usuarios, ha hecho que durante la d\u00e9cada de los no venta se extendiese en pr\u00e1cticamente todos los campos de la inform\u00e1tica. En los SI se inicia tambi\u00e9n la adopci\u00f3n , t\u00edmida de momento, de la OO. La uti - lizaci\u00f3n de lenguajes como C++ o Java re quiere que los SGBD relacionales se adapten a ellos con interfaces adecuadas. La r\u00e1pida adopci\u00f3n de la web a los SI hace que los SGBD incorporen recursos para ser servidores de p\u00e1 ginas web, como por ejemplo la inclusi\u00f3n de SQL en guiones HTML, SQL incorporado en Java, etc. Notad que en el mundo de la web son habituales los da tos multimedia y la OO.Hoy d\u00eda, los SGBD relacionales es t\u00e1n en plena transformaci\u00f3n para adaptarse a tres tecnolog\u00edas de \u00e9xit o reciente, fuertemente relacionadas: la multimedia, la de or ientaci\u00f3n a objetos (OO) e Internet y la web.C/S, SQL y 4GL... ... son siglas de moda desde el principio de los a\u00f1os noventa en el mundo de los sistemas de informaci\u00f3n. Nos puede interesar,... ... por ejemplo, tener en la entidad alumno un atributo foto tal que su valor sea una tira de bits muy larga, resultado de la digitalizaci\u00f3n de la fotograf\u00eda del alumno. FUOC 71Z799014MO 14 Introducci\u00f3n a las bases de datos Durante estos \u00faltimos a\u00f1os se ha empezado a extender un tipo de aplicaci\u00f3n de las BD denominado Data Warehouse , o almac\u00e9n de datos , que tambi\u00e9n produce algunos cambios en los SGBD relacionales del mercado. A lo largo de los a\u00f1os que han trabajado con BD de distintas aplicaciones, las empresas han ido acumulando gran cantidad de datos de todo tipo. Si estos datos se analizan convenientemente pueden dar informaci\u00f3n valiosa*. Por lo tanto, se trata de mantener un a gran BD con informaci\u00f3n proveniente de toda clase de aplicaciones de la empresa (e, incluso, de fuera). Los datos de este gran almac\u00e9n, el Data Warehouse , se obtienen por una replicaci\u00f3n m\u00e1s o menos elaborada de la s que hay en las BD que se ut ilizan en el trabajo cotidia - no de la empresa. Estos almacenes de datos se ut ilizan exclusivamente para ha - cer consultas, de forma especial para que lleven a cabo estudios* los analistas financieros, los analis tas de mercado, etc. Actualmente, los SGBD se adaptan a este tipo de aplicaci\u00f3n, incorporando, por ejemplo, herramientas como las siguientes: a)La creaci\u00f3n y el mantenim iento de r\u00e9plicas, con una cierta elaboraci\u00f3n de los datos. b)La consolidaci\u00f3n de datos de or\u00edgenes diferentes. c)La creaci\u00f3n de estructuras f\u00edsicas que soporten eficientemente el an\u00e1lisis multidimensional.* Por ejemplo, la evoluci\u00f3n del mercado en relaci\u00f3n con la pol\u00edtica de precios. * Con frecuencia se trata de estad\u00edsticas multidimensionales. FUOC 71Z799014MO 15 Introducci\u00f3n a las bases de datos 3. Objetivos y servicios de los SGBD Los SGBD que actualmente est\u00e1n en el mercado pretenden satisfacer un con - junto de objetivos directamente deducibles de lo que hemos explicado hasta ahora. A continuaci\u00f3n los comentaremos, pero sin entrar en detalles que ya se ver\u00e1n m\u00e1s adelante en otras asignaturas. 3.1. Consultas no predefinidas y complejas El objetivo fundamental de los SGBD es permitir que se hagan consultas no predefinidas (ad hoc ) y complejas . Consultas que afectan a m\u00e1s de una entidad tipo Se quiere conocer el n\u00famero de alumnos de m\u00e1s de veinticinco a\u00f1os y con nota media superior a siete que est\u00e1n matriculad os actualmente en la asignatura Bases de datos I . De cada alumno matriculado en menos de tres asignaturas, se quiere obtener el nombre, el n\u00famero de matr\u00edcula, el nombre de las asignaturas y el nombre de profesores de estas asignaturas. El usuario debe formular la consulta con un lenguaje sencillo (que se quede, obviamente, en el nivel l\u00f3gico), que el sistema debe interpretar directamente. Sin embargo, esto no significa que no se puedan escribir programas con con - sultas incorporadas (por ejempl o, para procesos repetitivos). La soluci\u00f3n est\u00e1ndar para alcanzar es te doble objetivo (consultas no prede - finidas y complejas) es el lenguaje SQL , que explicaremos en otro m\u00f3dulo did\u00e1ctico. 3.2. Flexibilidad e independencia La complejidad de las BD y la necesidad de irlas adaptando a la evoluci\u00f3n del SI hacen que un objetivo b\u00e1sico de los SGBD sea dar flexibilidad a los cambios . Interesa obtener la m\u00e1xima independencia posible entre los datos y los proce - sos usuarios para que se pueda llevar a cabo todo tipo de cambios tecnol\u00f3gicos Los usuarios podr\u00e1n hacer consultas de cualquier tipo y complejidad directamente al SGBD. El SGBD te ndr\u00e1 que responder inmediatamente sin que estas consultas est\u00e9n preestabl ecidas; es decir, sin que se tenga que escribir, compilar y ejecutar un programa espec\u00edfico para cada con - sulta.Ficheros tradicionales En los ficheros tradicionales, cada vez que se quer\u00eda hacer una consulta se ten\u00eda que escribir un programa a medida. FUOC 71Z799014MO 16 Introducci\u00f3n a las bases de datos y variaciones en la descripci\u00f3n de la BD, sin que se deban modificar los progra - mas de aplicaci\u00f3n ya escritos ni cambiar la forma de escribir las consultas (o ac - tualizaciones) directas. En el mundo de los ficheros ya hab\u00eda independencia f\u00edsica en un cierto grado, pero en el mundo de las BD acostumbra a ser mucho mayor. Ejemplos de independencia l\u00f3gica 1)El personal administrativo de secretar\u00eda podr\u00eda tener una visi\u00f3n de la entidad alumno sin que fuese necesario que existiese el atributo nota. Sin embargo, los usuari os profesores (o los programas dirigidos a ellos) podr\u00edan tener un a visi\u00f3n en la que ex istiese el atributo nota pero no el atributo fecha de pago . 2)Decidimos ampliar la lo ngitud del atributo nombre y lo aumentamos de treinta a cin - cuenta caracteres, pero no ser\u00eda necesario mo dificar los programas que ya tenemos escritos si no nos importa que los valore s obtenidos tengan s\u00f3lo los pr imeros treinta caracteres del nombre. 3.3. Problemas de la redundancia En el mundo de los ficheros tradicionales, cada aplicaci\u00f3n utilizaba su fichero. Sin embargo, puesto que se daba mucha coincidencia de datos entre aplicacio -Para conseguir esta independencia, tanto los usuarios que hacen con - sultas (o actualizacione s) directas como los pr ofesionales inform\u00e1ticos que escriben programas que las lle van incorporadas, deben poder des - conocer las caracter\u00edsticas f\u00edsicas de la BD con que trabajan. No necesi - tan saber nada sobre el soporte f\u00edsico, ni estar al corriente de qu\u00e9 SO se utiliza, qu\u00e9 \u00edndices hay, la compresi \u00f3n o no compresi\u00f3n de datos, etc. De este modo, se pueden hacer camb ios de tecnolog\u00eda y cambios f\u00edsicos para mejorar el rendimiento sin afec tar a nadie. Este tipo de indepen - dencia recibe el nombre de independencia f\u00edsica de los datos . Sin embargo, con la independenci a f\u00edsica no tenemos suficiente. Tam- bi\u00e9n queremos que los usuarios (los programadores de aplicaciones o los usuarios directos) no tengan qu e hacer cambios cuando se modifica la descripci\u00f3n l\u00f3gica o el esquema de la BD (por ejemplo, cuando se a\u00f1a - den/suprimen entidades o interrelaciones, atributos, etc. Y todav\u00eda m\u00e1s: queremos que diferent es procesos usuarios puedan tener diferentes visiones l\u00f3gi cas de una misma BD, y que estas visiones se pue - dan mantener lo m\u00e1s independientes posibles de la BD, y entre ellas mis - mas. Este tipo de independencia se denomina independencia l\u00f3gica de los datos , y da flexibilidad y elasticidad a los cambios l\u00f3gicos.Independencia l\u00f3gica de los datos Por ejemplo, el hecho de suprimir el atributo fecha de nacimiento de la entidad alumno y a\u00f1adir otra entidad aula no deber\u00eda afectar a ninguno de los programas existentes que no utilicen el atributo fecha de nacimiento . Las diferentes visiones l\u00f3gicas de una BD se ver\u00e1n en el apartado 4 de esta unidad did\u00e1ctica. Independencia l\u00f3gica Los sistemas de gesti\u00f3n de ficheros tradicionales no dan ninguna independencia l\u00f3gica. Los SGBD s\u00ed que la dan; uno de sus objetivos es conse-guir la m\u00e1xima posible, pero dan menos de lo que ser\u00eda deseable. FUOC 71Z799014MO 17 Introducci\u00f3n a las bases de datos nes, se produc\u00eda tambi\u00e9n mucha redundan cia entre los ficheros. Ya hemos dicho que uno de los objetivos de los SGBD es facilitar la eliminaci\u00f3n de la redun - dancia . Seguramente pens\u00e1is que el problema de la re dundancia es el espacio perdido. Antiguamente, cuando el precio del byte de disco era muy elevado, esto era un problema grave, pero actu almente pr\u00e1cticamente nunc a lo es. \u00bfQu\u00e9 problema hay, entonces? Simplemente, lo que to dos hemos sufrido m\u00e1s de una vez; si tenemos algo apuntado en dos lugares diferentes no pasar\u00e1 demasiado tiempo hasta que las dos anotaciones dejen de ser coherentes, porque habremos mo - dificado la anotaci\u00f3n en uno de los lu gares y nos habremos olvidado de hacer - lo en el otro. As\u00ed pues, el verdadero problema es el grave riesgo de inco nsistencia o incohe - rencia de los datos; es decir, la p\u00e9rdida de integridad que las actu alizaciones pueden provocar cuando existe redundancia. Por lo tanto, convendr\u00eda evitar la redund ancia. En principio, nos conviene hacer que un dato s\u00f3lo figure una vez en la BD . Sin embargo, esto no siempre ser\u00e1 cier - to. Por ejemplo, para repres entar una interrelaci\u00f3n entr e dos entidades, se suele repetir un mismo atributo en las dos, para que una haga referencia a la otra. Otro ejemplo podr\u00eda ser el disponer de r\u00e9plicas de los datos por razones de fia - bilidad, disponibilidad o co stes de comunicaciones. La duplicaci\u00f3n de datos es el tipo de redundancia m\u00e1s habitual, pero tambi\u00e9n tenemos redundancia cuando guardamos en la BD datos derivados (o calcula - dos) a partir de otros datos de la misma BD. De este modo podemos responder r\u00e1pidamente a consultas globales, ya que nos ahorramos la lectura de gran cantidad de registros. En los casos de datos derivados, para que el resultado del c\u00e1lculo se mantenga consistente con los datos elementales, es necesario rehacer el c\u00e1lculo cada vez que \u00e9stos se modifican. El usuario (y a sea programador o no) puede olvidarse de hacer el nuevo c\u00e1lculo; por ello convendr\u00e1 que el mismo SGBD lo haga autom\u00e1ticamente.El SGBD debe permitir que el dise\u00f1a dor defina datos redundantes, pero entonces tendr\u00eda que ser el mismo SGBD el que hiciese autom\u00e1ticamen - te la actualizaci\u00f3n de los datos en todos los lugares donde estuviesen repetidos.Consultad el apartado 1 de esta unidad did\u00e1ctica. \u00bfPor qu\u00e9 queremos evitar la redundancia? \u00bfQu\u00e9 problema nos comporta? Para recordar lo que se ha dicho sobre datos replicados, consultad el subapartado 2.3 de esta unidad did\u00e1ctica. Datos derivados Es frecuente tener datos num\u00e9ri- cos acumulados o agregados: el importe total de todas las matr\u00ed-culas hechas hasta hoy, el n\u00fa-mero medio de alumnos por asignatura, el saldo de la caja de la oficina, etc. FUOC 71Z799014MO 18 Introducci\u00f3n a las bases de datos 3.4. Integridad de los datos Nos interesar\u00e1 que los SGBD aseguren el mantenimiento de la calidad de los datos en cualquier circunstancia. Acabamos de ver que la redundancia puede provocar p\u00e9rdida de integrid ad de los datos, pero no es la \u00fanica causa posible. Se podr\u00eda perder la correcci\u00f3n o la cons istencia de los datos por muchas otras razones: errores de progra mas, errores de operaci\u00f3n humana, aver\u00eda de disco, transacciones incompletas por corte de alimentaci\u00f3n el\u00e9ctrica, etc. En el subapartado anterior hemos visto que podrem os decir al SGBD que nos lle - ve el control de las actualizaciones en el caso de las redundancias, para garanti - zar la integridad. Del mismo modo, podremos darle otras reglas de integridad -o restricciones- para que asegure que los programas las cumplen cuando efec - t\u00faan las actualizaciones. Aparte de las reglas de integridad que el dise\u00f1ador de la BD puede definir y que el SGBD entender\u00e1 y har\u00e1 cumplir, el mi smo SGBD tiene reglas de integridad inherentes al modelo de datos que utiliza y que siempre se cumplir\u00e1n. Son las denominadas reglas de integridad del modelo . Las reglas definibles por parte del usuario son las reglas de integridad del usuario . El concepto de integridad de los datos va m\u00e1s all\u00e1 de prevenir que los programas usuarios almacenen da - tos incorrectos. En casos de errores o desastres, tambi\u00e9n podr\u00edamos perder la integridad de los datos. El SGBD no s debe dar las herramientas para recons - truir o restaurar los datos estropeados. 3.5. Concurrencia de usuariosCuando el SGBD detecte que un pr ograma quiere hacer una operaci\u00f3n que va contra las reglas establecidas al definir la BD, no se lo deber\u00e1 per - mitir, y le tendr\u00e1 que devo lver un estado de error. Al dise\u00f1ar una BD para un SI concreto y escribir su esquema, no s\u00f3lo de - finiremos los datos, sino tambi\u00e9n las reglas de integridad que queremos que el SGBD haga cumplir. Los procesos de restauraci\u00f3n (restore o recovery ) de los que todo SGBD dispone pueden reconstruir la BD y darle el estado consistente y correc - to anterior al incidente. Esto se acostumbra a hacer gracias a la obten - ci\u00f3n de copias peri\u00f3dicas de los datos (se denominan copias de seguridad o back-up ) y mediante el mantenimiento continuo de un diario ( log) donde el SGBD va anotando todas las escrituras que se hacen en la BD. Un objetivo fundamental de los SGBD es permitir que varios usuarios puedan acceder concurrentemente a la misma BD.Reglas de integridad Por ejemplo, podremos declarar que el atributo DNI debe ser clave o que la fecha de nacimiento debe ser una fecha correcta y, adem\u00e1s, se debe cumplir que el alumno no pueda tener menos de dieciocho a\u00f1os ni m\u00e1s de noventa y nueve, o que el n\u00fa-mero de alumnos matriculados de una asignatura no sea supe-rior a veintisiete, etc. Reglas de integridad del modelo Por ejemplo, un SGBD relacional nunca aceptar\u00e1 que una tabla tenga filas duplicadas, un SGBD jer\u00e1rquico nunca aceptar\u00e1 que una entidad tipo est\u00e9 definida como hija de dos entidades tipo diferentes, etc. Usuarios concurrentes Actualmente ya no son raros los SI que tienen, en un instante determinado, miles de sesiones de usuario abiertas simult\u00e1neamente. No hace falta pensar en los t\u00edpicos siste-mas de los consorcios de com-pa\u00f1\u00edas a\u00e9reas o casos similares, sino en los servidores de p\u00e1gi-nas web. FUOC 71Z799014MO 19 Introducci\u00f3n a las bases de datos Cuando los accesos concurrentes son todo s de lectura (es decir, cuando la BD s\u00f3lo se consulta), el problema que se produce es simplement e de rendimiento, causado por las limitaciones de los soportes de que se dispone: pocos mecanis - mos de acceso independientes, movimien to del brazo y del giro del disco de - masiado lentos, buffers locales demasiado peque\u00f1os, etc. Cuando un usuario o m\u00e1s de uno est\u00e1n actualizando los datos, se pueden pro - ducir problemas de interferencia que tengan como consecuencia la obten - ci\u00f3n de datos err\u00f3neos y la p\u00e9 rdida de integridad de la BD. Para tratar los acce sos concurrentes , los SGBD utilizan el concepto de transac - ci\u00f3n de BD, concepto de especial utilid ad para todo aquello que hace referen - cia a la integridad de los dato s, como veremos a continuaci\u00f3n. Ejemplos de transacciones 1)Imaginemos un programa pensado para llevar a cabo la operaci\u00f3n de transferencia de di - nero de una cuenta X a otra Y. Supongamos qu e la transferencia efect\u00faa dos operaciones: en primer lugar, el cargo a X y despu\u00e9s, el abono a Y. Este programa se debe ejecutar de forma que se hagan las dos operaciones o ninguna, ya que si por cualquier raz\u00f3n (por ejemplo, por interrupci\u00f3n del flujo el\u00e9ctrico) el programa ej ecutase s\u00f3lo el cargo de dinero a X sin abonar - los a Y, la BD quedar\u00eda en un estado incorrecto. Queremos que la ejecuci\u00f3n de este programa sea tratada por el SGBD como una transacci\u00f3n de BD. 2)Otro ejemplo de programa que querr\u00edamos que tuviera un comportamiento de tran - sacci\u00f3n podr\u00eda ser el que aumentara el 30% de la nota de todos los alumnos. Si s\u00f3lo au - mentara la nota a unos cuantos alum nos, la BD quedar\u00eda incorrecta. Para indicar al SGBD que damos por acabada la ejecuci\u00f3n de la transacci\u00f3n, el programa utilizar\u00e1 la operaci\u00f3n de COMMIT . Si el programa no puede acabar normalmente (es decir, si el conjunto de operaciones se ha hecho s\u00f3lo de for - ma parcial), el SGBD tendr\u00e1 que deshacer todo lo que la transacci\u00f3n ya haya hecho. Esta operaci\u00f3n se denomina ROLLBACK . Acabamos de observar la utilidad del concepto de transacci\u00f3n para el manteni - miento de la integridad de los datos en caso de interrupci\u00f3n de un conjunto de operaciones l\u00f3gicamente unitario. Sin embargo, entre transacciones que se ejecutan concurrentemente se pueden producir pr oblemas de interferencia que hagan obtener resultados err\u00f3neos o que comporten la p\u00e9rdida de la inte - gridad de los datos. Consecuencias de la interferencia entre transacciones 1)Imaginemos que una transacci\u00f3n que transfier e dinero de X a Y se ejecuta concurrente - mente con una transacci\u00f3n que observa el saldo de las cuentas Y y X, en este orden, y nos muestra su suma. Si la ejecuci\u00f3n de forma co ncurrente de las dos transacciones casualmente Denominamos transacci\u00f3n de BD o, simplemente, transacci\u00f3n un con - junto de operaciones simples que se ejecutan como una unidad. Los SGBD deben conseguir que el conjunto de operaciones de una transacci\u00f3n nunca se ejecute parcialmente. O se ejecut an todas, o no se ejecuta ninguna. FUOC 71Z799014MO 20 Introducci\u00f3n a las bases de datos es tal que la transferencia se ejecuta entre la ej ecuci\u00f3n de las dos lecturas de la transacci\u00f3n de suma, puede producir resu ltados incorrectos. Adem\u00e1s, si los decide escribir en la BD, \u00e9sta que - dar\u00e1 inconsistente (consultad la figura 3). 2)Si simult\u00e1neamente con el generoso programa que aumenta la nota de los alumnos en un 30%, se ejecuta un programa qu e determina la nota media de todos los alumnos de una de - terminada asignatura, se podr\u00e1 encontrar a alumno s ya gratificados y a otros no gratificados, algo que producir\u00e1 resultados err\u00f3neos. Estos son s\u00f3lo dos ejemplos de las diferentes consecuencias negativas que puede tener la in - terferencia entre transacciones en la integridad de la BD y en la correcci\u00f3n del resultado de las consultas. Figura 3 Cuando se provocan bloqueos, se producen esperas, retenciones y, en conse - cuencia, el sistema es m\u00e1s lento. Los SGBD se esfuerzan en minimizar estos efectos negativos. Recordad que esta asignatura es s\u00f3lo introductoria y que m\u00e1s adelante, en otras asignaturas, estudiar\u00e9is con m\u00e1s detalle los temas que, como el de la con - currencia, aqu\u00ed s\u00f3 lo introducimos. Nos interesar\u00e1 que el SGBD ejecute las transacciones de forma que no se interfieran; es decir, que queden aisladas unas de otras. Para conse - guir que las transaccione s se ejecuten como si estuviesen aisladas, los SGBD utilizan distintas t\u00e9cn icas. La m\u00e1s conocida es el bloqueo (lock). El bloqueo de unos datos en beneficio de una transacci\u00f3n consiste en po - ner limitaciones a los acce sos que las dem\u00e1s transacciones podr\u00e1n hacer a estos datos. Bloqueos en la transferencia de dinero Por ejemplo, si la transacci\u00f3n de transferencia de dinero modifica el saldo de la cuenta X, el SGBD bloquea esta cuenta de forma que, cuando la transacci\u00f3n de suma quiera leerla, tenga que esperar a que la transacci\u00f3n de transferencia acabe; esto se debe al hecho de que al acabar una transac-ci\u00f3n, cuando se efect\u00faan las operaciones COMMIT o ROLLBACK se liberan los objetos que ten\u00eda bloqueados. FUOC 71Z799014MO 21 Introducci\u00f3n a las bases de datos 3.6. Seguridad El t\u00e9rmino seguridad se ha utilizado en diferentes se ntidos a lo largo de la his - toria de la inform\u00e1tica. Estas cuestiones siempre han sido import antes en los SI militares, las agencias de informaci\u00f3n y en \u00e1mbito s similares, pero durante los a\u00f1os noventa han ido adquiriendo importancia en cualquier SI donde se almacene n datos sobre per - sonas. Recordad que en el Estado espa \u00f1ol tenemos una ley*, que exige la pro - tecci\u00f3n de la confidenci alidad de estos datos. Los SGBD permiten definir autorizaciones o derechos de acceso a diferentes niveles: al nivel global de toda la BD, al nivel entidad y al nivel atributo. Estos mecanismos de seguridad requieren que el usuario se pueda identificar. Se acostumbra a utilizar c\u00f3digos de usua rios (y grupos de usuarios) acompa\u00f1a - dos de contrase\u00f1as ( passwords ), pero tambi\u00e9n se utiliz an tarjetas magn\u00e9ticas, identificaci\u00f3n por reconocimiento de la voz, etc. Nos puede interesar almacenar la inform aci\u00f3n con una codificaci\u00f3n secreta; es decir, con t\u00e9cnicas de encriptaci\u00f3n (como m\u00ednimo se deber\u00edan encriptar las contrase\u00f1as). Muchos de los SGBD actu ales tienen prevista la encriptaci\u00f3n. Pr\u00e1cticamente todos los SGBD del mercado dan una gran variedad de herra - mientas para la vigilancia y la administraci\u00f3n de la seguridad. Los hay que, in - cluso, tienen opciones (con precio separado) para los SI con unas exigencias alt\u00edsimas, como por ejemplo los militares. 3.7. Otros objetivos Acabamos de ver los objetivos fundamentales de los SGBD actuales. Sin em - bargo, a medida que los SGBD evoluc ionan, se imponen nuevos objetivos adaptados a las nuevas necesidades y las nuevas tecnolog\u00edas. Como ya hemos visto, en estos momentos podr\u00edamos ci tar como objetivos nuevos o recientes los siguientes: 1)Servir eficientemente los Data Warehouse . 2)Adaptarse al desarrollo orientado a objetos. 3)Incorporar el tiempo como un elemento de caracterizaci\u00f3n de la informaci\u00f3n. 4)Adaptarse al mundo de Internet.Actualmente, en el campo de los SGBD, el t\u00e9rmino seguridad se suele uti - lizar para hacer referencia a los tema s relativos a la confidencialidad, las autorizaciones, los derechos de acceso, etc. * Ley Org\u00e1nica 15/1999, de 13 de diciembre, de Protecci\u00f3n de Datos de Car\u00e1cter Personal. (BOE n\u00fam. 298, de 12/12/1999, p\u00e1gs. 43088-43099). Derechos de acceso Por ejemplo, el usuario SECRE3 podr\u00eda tener autorizaci\u00f3n para consultar y modificar todas las entidades de la BD, excepto el valor del atributo nota de los alumnos , y no estar autorizado a hacer ning\u00fan tipo de supre-si\u00f3n o inserci\u00f3n. Para recordar las tendencias actuales sobre SGBD, pod\u00e9is revisar el subapartado 2.4. de esta unidad did\u00e1ctica. FUOC 71Z799014MO 22 Introducci\u00f3n a las bases de datos 4. Arquitectura de los SGBD 4.1. Esquemas y niveles Para trabajar con nuestras BD, los SGBD necesitan conocer su estructura (qu\u00e9 entidades tipo habr\u00e1, qu\u00e9 atributos tendr\u00e1n, etc.). El esquema de la BD es un elemento fundamental de la arquitectura de un SGBD que permite independizar el SGBD de la BD; de este modo, se puede cambiar el dise\u00f1o de la BD (su esquem a) sin tener que hacer ning\u00fan cambio en el SGBD. Anteriormente, ya hemos ha blado de la distinci\u00f3n entre dos niveles de repre - sentaci\u00f3n inform\u00e1tica: el nivel l\u00f3gico y el f\u00edsico. El nivel l\u00f3gico nos oculta los detalles de c\u00f3mo se almacenan los datos, c\u00f3mo se mantienen y c\u00f3mo se acce de f\u00edsicamente a ellos. En este nivel s\u00f3lo se habla de entidades, atributos y reglas de integridad. Por cuestiones de rendim iento, nos podr\u00e1 interesar describir elementos de ni- vel f\u00edsico como, por ejemplo, qu\u00e9 \u00edndices te ndremos y qu\u00e9 caracter\u00edsticas pre - sentar\u00e1n, c\u00f3mo y d\u00f3nde (en qu\u00e9 espaci o f\u00edsico) queremos que se agrupen f\u00edsicamente los registros, de qu\u00e9 tama\u00f1o deben ser las p\u00e1ginas, etc. En el periodo 1975-1982, ANSI intentaba establecer las bases para crear est\u00e1n - dares en el campo de las BD. El comit\u00e9 conocido como ANSI/SPARC recomen - d\u00f3 que la arquitectura de los SGBD prev iese tres niveles de descripci\u00f3n de la BD, no s\u00f3lo dos*.Los SGBD necesitan que les demos un a descripci\u00f3n o definici\u00f3n de la BD. Esta descripci\u00f3n re cibe el nombre de esquema de la BD , y los SGBD la tendr\u00e1n continua mente a su alcance. De acuerdo con la arquit ectura ANSI/SPARC, deb\u00eda haber tres niveles de esquemas (tres niveles de abstracci\u00f3 n). La idea b\u00e1sica de ANSI/SPARC consist\u00eda en descomponer el nivel l\u00f3gico en dos: el nivel externo y el nivel conceptual . Denomin\u00e1bamos nivel interno lo que aqu\u00ed hemos denominado nivel f\u00edsico .* De hecho, en el a\u00f1o 1971, el comit\u00e9 CODASYL ya hab\u00eda propuesto los tres niveles de esquemas. FUOC 71Z799014MO 23 Introducci\u00f3n a las bases de datos De este modo, de acuerdo con ANSI/SPARC, habr\u00eda los tres niveles de esque - mas que mencionamos a continuaci\u00f3n: a)En el nivel externo se sit\u00faan las diferentes visiones l\u00f3gicas que los procesos usuarios (programas de aplicaci\u00f3n y usuari os directos) tendr\u00e1n de las partes de la BD que utilizar\u00e1n. Esta s visiones se denominan esquemas externos . b)En el nivel conceptual hay una sola descripci\u00f3n l\u00f3gica b\u00e1sica, \u00fanica y glo - bal, que denominamos esquema conceptual , y que sirve de referencia para el resto de los esquemas. c)En el nivel f\u00edsico hay una sola descripci\u00f3n f\u00edsica , que denominamos esque - ma interno . Figura 4 El esquema conceptual corresponde a la s necesidades del conjunto de la em - presa o del SI, por lo que se escribir\u00e1 de forma centralizad a durante el denomi - nado dise\u00f1o l\u00f3gico de la BD. Sin embargo, cada aplicaci\u00f3n podr\u00e1 tene r su visi\u00f3n partic ular, y seguramente parcial, del esquema conceptual. Los usua rios (programas o usuarios directos) ver\u00e1n la BD mediante esquemas externos apropiados a sus necesidades. Estos esquemas se pueden considerar redefi niciones del esquema conceptual, con las partes y los t\u00e9rminos que convengan para las ne cesidades de las aplicacio - nes (o grupos de aplicaciones). Algunos sistemas los denominan subesquemas .En el esquema conceptual se describir\u00e1n las entidades tipo, sus atribu - tos, las interrelaciones y las rest ricciones o reglas de integridad.Nota Es preciso ir con cuidado para no confundir los niveles que se describen aqu\u00ed con los descritos en el caso de los ficheros, aunque reciban el mismo nombre. En el caso de las BD, el esquema interno corresponde a la parte f\u00edsica, y el externo a la l\u00f3gica; en el caso de los ficheros, sucede lo contrario. FUOC 71Z799014MO 24 Introducci\u00f3n a las bases de datos Ejemplo de esquema externo Imaginemos una BD que en el esquema conceptu al tiene definida, entre muchas otras, una entidad alumno con los siguientes atributos: numatri, nombre, apellido, numDNI, direccion, fe - chanac, telefono . Sin embargo, nos puede interesar que unos determinados programas o usua - rios vean la BD formada de acuerdo con un esquema externo que tenga definidas dos entidades, denominadas estudiante y persona . a)La entidad estudiante podr\u00eda tener definido el atributo numero-matricula (definido como derivable directamente de numatri ), el atributo nombre-pila (de nombre ), el atributo apellido y el atributo DNI (de numDNI ). b)La entidad persona podr\u00eda tener el atributo DNI (obtenido de numDNI ), el atributo nombre (formado por la concatenaci\u00f3n de nombre y apellido ), el atributo direccion y el atributo edad (que deriva din\u00e1micamente de fechanac ). El esquema de nivel interno responde a las cuestiones de re ndimiento (espacio y tiempo) planteadas al hacer el dise\u00f1o f\u00edsico de la BD y al ajustarlo* posterior - mente a las necesi dades cambiantes. De acuerdo con la arquitectura ANSI/SPARC, para crear una BD hace falta de - finir previamente su esquema conceptu al, definir como m\u00ednimo un esquema externo y, de forma eventual, definir su esquema interno. Si este \u00faltimo esque - ma no se define, el mismo SGBD tendr\u00e1 que decidir los detalles de la organi - zaci\u00f3n f\u00edsica. El SGBD se encargar\u00e1 de hacer las correspondencias ( mappings ) entre los tres niveles de esquemas. Esquemas y niveles en los SGBD relacionales En los SGBD relacionales (es decir, en el mundo de SQL) se utiliza una terminolog\u00eda ligera - mente diferente. No se separan de forma clara tre s niveles de descripci\u00f3n. Se habla de un solo esquema - schema- , pero en su interior se incluyen desc ripciones de los tres niveles. En el schema se describen los elementos de aquello que en la arquitectura ANSI/SPARC se denomi - na esquema conceptua l (entidades tipo, atributos y restricciones) y las vistas - view- , que corres - ponden aproximadamente a los esquemas externos. El modelo relacional en que est\u00e1 inspirado SQL se limita al mundo l\u00f3gico. Por ello, el es - t\u00e1ndar ANSI-ISO de SQL no habla en absoluto del mundo f\u00edsico o interno; lo deja en ma - nos de los SGBD relacionales del mercado. Sin embargo, estos SGBD proporcionan la posibilidad de incluir dentro del schema descripciones de estructuras y caracter\u00edsticas f\u00ed - sicas (\u00edndice, tablespace , cluster , espacios para excesos, etc.).Al definir un esquema externo , se citar\u00e1n s\u00f3lo aquellos atributos y aquellas entidades que interesen; lo s podremos redenominar, podremos definir datos derivados o redefinir un a entidad para que las aplicaciones que utilizan este esquema externo crean que son dos, definir combina - ciones de entidades para que parezcan una sola, etc. El esquema interno o f\u00edsico contendr\u00e1 la descripci\u00f3n de la organiza - ci\u00f3n f\u00edsica de la BD: ca minos de acceso (\u00edndices, hashing , apuntado - res, etc.), codificaci\u00f3n de los datos, gesti\u00f3n del espaci o, tama\u00f1o de la p\u00e1gina, etc. * En ingl\u00e9s, el ajuste se conoce con el nombre de tuning . \u00bfQu\u00e9 hay que hacer para crear una BD? FUOC 71Z799014MO 25 Introducci\u00f3n a las bases de datos 4.2. Independencia de los datos En este subapartado veremos c\u00f3mo la arquitectura de tres niveles que acaba - mos de presentar nos proporciona los dos tipos de independencia de los datos: la f\u00edsica y la l\u00f3gica. De acuerdo con la arquitectura ANSI/SPARC, habr\u00e1 independencia f\u00edsica cuan - do los cambios en el esquema interno no afecten al esquema conceptual ni a los esquemas externos. Figura 5 Es obvio que cuando cambiemos unos datos de un soporte a otro, o los cam - biemos de lugar dentro de un soporte, no se ver\u00e1n afectados ni los programas de aplicaci\u00f3n ni los usuarios directos, ya que no se modificar\u00e1 el esquema con - ceptual ni el externo. Sin embargo, ta mpoco tendr\u00edan que verse afectados si cambi\u00e1semos, por ejemplo, el m\u00e9todo de acceso a unos registros determina - dos*, el formato o la codificaci\u00f3n, etc. Ninguno de estos casos deber\u00eda afectar al mundo exterior, sino s\u00f3lo a la BD f\u00edsica, el esquema interno, etc. Si hay independencia f\u00edsica de los datos, lo \u00fanico que variar\u00e1 al cambiar el es - quema interno son las correspondencias entre el esquema conceptual y el in - terno. Obviamente, la mayor\u00eda de los cambios del es quema interno obligar\u00e1n a rehacer la BD real (la f\u00edsica). Hay independencia f\u00edsica cuando los cambios en la organizaci\u00f3n f\u00edsica de la BD no afectan al mundo exteri or (es decir, los programas usuarios o los usuarios directos).Los dos tipos de independencia de los datos se han explicado en el subapartado 3.2 de esta unidad did\u00e1ctica. * Por ejemplo, eliminando un \u00edndice en \u00e1rbol-B o sustituy\u00e9ndolo por un hashing . FUOC 71Z799014MO 26 Introducci\u00f3n a las bases de datos Figura 6 Dados los dos niveles l\u00f3gicos de la ar quitectura ANSI/SPA RC, diferenciaremos las dos situaciones siguientes: 1) Cambios en el esquema conceptual . Un cambio de este tipo no afectar\u00e1 a los esquemas externos que no hagan re ferencia a las entidades o a los atribu - tos modificados. 2) Cambios en los esquemas externos . Efectuar cambios en un esquema ex - terno afectar\u00e1 a los usuarios que utilic en los elementos modificados. Sin em - bargo, no deber\u00eda afectar a los dem\u00e1s usuarios ni al esquema conceptual, y tampoco, en consecuencia, al esquema interno y a la BD f\u00edsica. Usuarios no afectados por los cambios Notad que no todos los cambios de elementos de un esquema externo afectar\u00e1n a sus usua - rios. Veamos un ejemplo de ello: antes hemos visto que cuando elimin \u00e1bamos el atributo apellido del esquema conceptual, deb\u00edamos modifi car el esquema externo donde defin\u00edamos nombre , porque all\u00ed estaba definido como concatenaci\u00f3n de nombre y apellido . Pues bien, un programa que utilizase el atributo nombre no se ver\u00eda afectado si modific\u00e1semos el esquema externo de modo que nombre fuese la concatenaci\u00f3n de nombre y una cadena constante (por ejemplo, toda en blanco). Como resultado, habr\u00eda desaparecido el apellido de nombre , sin que hubiera sido necesario modificar el programa. Los SGBD actuales proporcionan bastante independencia l\u00f3gica, pero menos de la que har\u00eda falta, ya que las exigencias de cambios constantes en el SI piden gra - dos muy elevados de flexibilidad. Los sist emas de ficheros tradicionales, en cam - bio, no ofrecen ninguna independencia l\u00f3gica.Hay independencia l\u00f3gica cuando los usuarios* no se ven afectados por los cambios en el nivel l\u00f3gico.* Programas de aplicaci\u00f3n o usuarios directos. Si eliminamos... ... el atributo apellido , por ejemplo, no se ver\u00e1n afectados los esquemas externos (ni los usuarios) que no hagan referencia a este atributo. Si se alarga el atributo direcci\u00f3n al esquema conceptual, no ser\u00e1 necesa rio modificar el esquema externo donde se ha definido la direcci\u00f3n y obviamente, tampoco resultar\u00e1n afectados los programas y los usuarios que la utilicen. FUOC 71Z799014MO 27 Introducci\u00f3n a las bases de datos 4.3. Flujo de datos y de control Para entender el funcionamiento de un SGBD, a continuaci\u00f3n veremos los principales pasos de la ejecuci\u00f3n de un a consulta sometida al SGBD por un programa de aplicaci\u00f3n. Explicaremos la s l\u00edneas generales del flujo de datos y de control entre el SGBD, los programas de usuario y la BD. Recordad que el SGBD, con la ayuda de l SO, lee p\u00e1ginas (bloques) de los so - portes donde est\u00e1 almace nada la BD f\u00edsica, y las lleva a un \u00e1rea de buffers o me - morias cach\u00e9 en la memoria principal. El SGBD pasa registros desde los buffers hacia el \u00e1rea de trabajo del mismo programa. Supongamos que la consulta pide los datos del alumno que tiene un determi - nado DNI. Por lo tanto, la respuesta que el programa obtendr\u00e1 ser\u00e1 un solo re - gistro y lo recibir\u00e1 dentro de un \u00e1rea de trabajo propia*. Figura 7 El proceso que se sigue es el siguiente: a)Empieza con una llamada (1) del programa al SGBD, en la que se le env\u00eda la operaci\u00f3n de consulta. El SGBD debe ve rificar que la sintaxis de la operaci\u00f3n * Por ejemplo, una variable con estructura de tupla. Ejecuci\u00f3n de una consulta En la figura vemos representa- da la BD, los tres niveles de esquemas, el \u00e1rea de los buffers , el SGBD y el programa de aplicaci\u00f3n que le hace la consulta. FUOC 71Z799014MO 28 Introducci\u00f3n a las bases de datos recibida sea correcta, que el usuario de l programa est\u00e9 auto rizado a hacerla, etc. Para poder llevar a cabo todo esto, el SGBD se basa (2) en el esquema ex - terno con el que trabaja el progra ma y en el esquema conceptual. b)Si la consulta es v\u00e1lida, el SGBD determina, consultando el esquema interno (3), qu\u00e9 mecanismo debe seguir para re sponderla. Ya sabemos que el programa usuario no dice nada respecto a c\u00f3mo se debe hacer f\u00edsicamente la consulta. Es el SGBD el que lo debe determinar. Casi siempre hay varias formas y diferentes caminos para responder a una consulta*. Supongamos que ha elegido aplicar un hashing al valor del DNI, que es el par\u00e1metro de la consulta, y el resultado es la direcci\u00f3n de la p\u00e1gina donde se encuentra (entre muchos otros) el registro del alumno buscado. c)Cuando ya se sabe cu\u00e1l es la p\u00e1gina, el SGBD comprobar\u00e1 (4) si por suerte esta p\u00e1gina ya se encuentra en aquel momento en el \u00e1rea de los buffers (tal vez como resultado de una consulta anterior de este usuario o de otro). Si no est\u00e1, el SGBD, con la ayuda del SO, la busca en disco y la carga en los buffers (5). Si ya est\u00e1, se ahorra el acceso a disco. d)Ahora, la p\u00e1gina deseada ya est\u00e1 en la memoria principal. El SGBD extrae, de entre los distintos registros que la p\u00e1gina puede contener, el registro bus - cado, e interpreta la codificaci\u00f3n y el resultado seg\u00fan lo que diga el esquema interno. e)El SGBD aplica a los datos las eventual es transformaciones l\u00f3gicas que im - plica el esquema externo (tal vez cortan do la direcci\u00f3n por la derecha) y las lleva al \u00e1rea de trabajo del programa (6). f)A continuaci\u00f3n, el SGBD retorna el co ntrol al programa (7) y da por termi - nada la ejecuci\u00f3n de la consulta.* Por ejemplo, siempre tiene la posibilidad de hacer una b\u00fasqueda secuencial. Diferencias entre SGBD Aunque entre diferentes SGBD puede haber enormes diferen-cias de funcionamiento, suelen seguir el esquema general que acabamos de explicar. FUOC 71Z799014MO 29 Introducci\u00f3n a las bases de datos 5. Modelos de BD Una BD es una representaci\u00f3n de la realid ad (de la parte de la realidad que nos interesa en nuestro SI). Dicho de otro modo, una BD se puede considerar un modelo de la realidad. El componente fundamental utilizado para modelar en un SGBD relacional son las tablas (denominadas relaciones en el mundo te\u00f3ri - co). Sin embargo, en ot ros tipos de SGBD se ut ilizan otros componentes. Todo modelo de BD nos proporciona tres tipos de herramientas: a) Estructuras de datos con las que se puede construi r la BD: tablas, \u00e1rboles, etc. b)Diferentes tipos de restricciones (o reglas) de integridad que el SGBD ten - dr\u00e1 que hacer cumplir a los datos: dominios, claves, etc. c)Una serie de operaciones para trabajar con los da tos. Un ejemplo de ello, en el modelo relacional, es la operaci\u00f3 n SELECT, que sirve para seleccionar (o leer) las filas que cumplen alguna condic i\u00f3n. Un ejemplo de operaci\u00f3n t\u00edpica del modelo jer\u00e1rquico y del modelo en red podr\u00eda ser la que nos dice si un de - terminado registro tiene \"hijos\" o no. Evoluci\u00f3n de lo s modelos de BD De los cuatro modelos de BD que hemo s citado, el que apareci\u00f3 primero, a principios de los a\u00f1os sesenta, fue el modelo jer\u00e1rquico . Sus estructuras son registros interrelacionados en forma de \u00e1rboles. El SGBD cl\u00e1sico de este mode - lo es el IMS/DL1 de IBM. A principios de los setenta surgieron SGBD basados en un modelo en red . Como en el modelo jer\u00e1rquico, hay regist ros e interrelaciones, pero un registro ya no est\u00e1 limitado a ser \"hijo\" de un solo registro tipo. El comit\u00e9 CODASYL- DBTG propuso un est\u00e1ndar basado en este modelo, que fue adoptado por mu - chos constructores de SGBD*. Sin embargo, encontr\u00f3 la oposici\u00f3n de IBM, la empresa entonces dominante. La prop uesta de CODASYL-DBTG ya defin\u00eda tres niveles de esquemas.El conjunto de componentes o herramientas conceptuales que un SGBD proporciona para mode lar recibe el nombre de modelo de BD . Los cuatro modelos de BD m\u00e1s utilizados en los SI son el modelo rela - cional , el modelo jer\u00e1rquico , el modelo en red y el modelo relacional con objetos .Las tablas o relaciones se estudiar\u00e1n en la unidad did\u00e1ctica \"El modelo relacional y el \u00e1lgebra relacional\" de este curso. \u00a1Cuidado con las confusiones! Popularmente, en especial en el campo de la inform\u00e1tica personal, se denomina BD a lo que aqu\u00ed denominamos SGBD . Tampoco se debe confundir la BD considerada como modelo de la realidad con lo que aqu\u00ed denominamos mode- lo de BD. El modelo de BD es el conjunto de herramientas conceptuales (piezas) que se utilizan para construir el modelo de la realidad. * Por ejemplo, IDS de Bull, DMS de Univac y DBMS de Digital. FUOC 71Z799014MO 30 Introducci\u00f3n a las bases de datos Durante los a\u00f1os ochenta apareci\u00f3 una gran cantidad de SGBD basados en el modelo relacional propuesto en 1969 por E.F. Codd, de IBM, y pr\u00e1cticamente todos utilizaban como lenguaje nativo el SQL**. El modelo relacional se basa en el concepto matem\u00e1tico de relaci\u00f3n , que aqu\u00ed podemos considerar de mo - mento equivalente al t\u00e9rmino tabla (formada por filas y columnas). La mayor parte de los SI que actualmente est\u00e1n en funcionamiento utilizan SGBD rela - cionales, pero algunos siguen utilizando los jer\u00e1rquicos o en red (especialmen - te en SI antiguos muy grandes). Figura 8 As\u00ed como en los modelos prerrelacionales (jer\u00e1rquico y en red), las estructuras de datos constan de dos elementos b\u00e1sicos (los registros y las interrelaciones), en el modelo relacional constan de un solo elemento: la ta bla, formada por fi - las y columnas. Las interre laciones se deben modelizar utilizando las tablas. Otra diferencia importante entre los mo delos prerrelacionales y el modelo re - lacional es que el modelo relacional se limita al nivel l\u00f3gico (no hace absolu - tamente ninguna consideraci\u00f3n sobre las representaciones f\u00edsicas). Es decir, nos da una independencia f\u00edsica de datos total. Esto es as\u00ed si hablamos del mo - delo te\u00f3rico, pero los SGBD del mercado nos prop orcionan una independen - cia limitada. Estos \u00faltimos a\u00f1os se est\u00e1 extendiendo el modelo de BD re lacional con ob - jetos . Se trata de ampliar el modelo rela cional, a\u00f1adi\u00e9ndole la posibilidad de que los tipos de datos sean tipos abstractos de datos, TAD. Esto acerca los sis - temas relacionales al paradigma de la OO. Los primeros SGBD relacionales ** Por ejemplo, Oracle, DB2 de IBM, Informix, Ingres, Allbase de HP y SQL-Server de Sybase. El modelo relacional se estudia con detalle en la unidad did\u00e1ctica \"El modelo relacional y el \u00e1lgebra relacional\" de este curso. FUOC 71Z799014MO 31 Introducci\u00f3n a las bases de datos que dieron esta posibilidad fueron Oracle (versi\u00f3n 8), Informix (versi\u00f3n 9) e IBM/DB2/UDB (versi\u00f3n 5). Hablamos de modelos de BD, pero de hecho se acostumbran a denominar modelos de datos , ya que permiten modelarlos. Sin embargo, hay modelos de datos que no son utilizados por los SGBD del mercado: s\u00f3lo se usan durante el proceso de an\u00e1lisis y dise\u00f1o, pero no en las realizaciones. Los m\u00e1s conocidos de estos tipo s de modelos son los modelos sem\u00e1nticos y los funcionales . \u00c9stos nos proporcionan herramientas muy potentes para des - cribir las estructuras de la informaci\u00f3 n del mundo real, la sem\u00e1ntica y las in - terrelaciones, pero normalmente no disponen de operaciones para tratarlas. Se limitan a ser herramientas de descripci\u00f3n l\u00f3gica. Son muy utilizados en la eta - pa del dise\u00f1o de BD y en herramientas CASE. El m\u00e1s extendido de estos mo - delos es el conocido como modelo ER (entity-relationship ), que estudiaremos m\u00e1s adelante. Actualmente, la pr\u00e1ctica m\u00e1s extendid a en el mundo profesional de los desa - rrolladores de SI es la utilizaci\u00f3n del mo delo ER durante el an\u00e1lisis y las prime - ras etapas del dise\u00f1o de lo s datos, y la utilizaci\u00f3n de l modelo relacional para acabar el dise\u00f1o y construir la BD con un SGBD. En esta asignatura hablamos s\u00f3lo de BD con modelos de datos estructurados, que son los que normalmente se utilizan en los SI empresariales. Sin embargo, hay SGBD especializados en tipos de aplicaciones concretas que no siguen ninguno de estos modelos. Por ejemplo, los SGBD documentales o los de BD geogr\u00e1ficas. La evoluci\u00f3n de los modelos... ... a lo largo de los a\u00f1os los ha ido alejando del mundo f\u00edsico y los ha acercado al mundo l\u00f3gico; es decir, se han alejado de las m\u00e1quinas y se han acercado a las personas. FUOC 71Z799014MO 32 Introducci\u00f3n a las bases de datos 6. Lenguajes y usuarios Para comunicarse con el SGBD, el usuario, ya sea un programa de aplicaci\u00f3n o un usuario directo, se vale de un le nguaje. Hay muchos lenguajes diferentes, seg\u00fan el tipo de usuarios para los que es t\u00e1n pensados y el tipo de cosas que los usuarios deben poder expresar con ellos: a)Habr\u00e1 usuarios inform\u00e1ticos muy expe rtos que querr\u00e1n escribir procesos complejos y que necesita r\u00e1n lenguajes complejos. b)Sin embargo, habr\u00e1 usuarios finales no inform\u00e1ticos, ocasionales (espor\u00e1 - dicos), que s\u00f3lo har\u00e1n consultas. Estos usuarios necesitar\u00e1n un lenguaje muy sencillo, aunque d\u00e9 un rendimient o bajo en tiempo de respuesta. c)Tambi\u00e9n podr\u00e1 haber usuarios finales no inform\u00e1ticos, dedicados o especia - lizados. Son usuarios cotidianos o, incl uso, dedicados exclusivamente a trabajar con la BD*. Estos usuarios necesitar\u00e1n lengua jes muy eficientes y compactos, aunque no sea f\u00e1cil aprenderlos. Tal vez ser\u00e1n lenguajes especializados en tipos concretos de tareas. El lenguaje SQL , que es el m\u00e1s utilizado en las BD relacionales, tiene verbos -ins - trucciones- de tres tipos diferentes: 1) Verbos del tipo DML ; por ejemplo, SELECT para hacer consultas, e INSERT , UPDATE y DELETE para hacer el mantenimiento de los datos. 2) Verbos del tipo DDL ; por ejemplo, CREATE TABLE para definir las tablas, sus columnas y las restricciones. 3)Adem\u00e1s, SQL tiene verbos de control del entorno , como por ejemplo COMMIT y ROLLBACK para delimitar transacciones.Hay lenguajes especializados en la escr itura de esquemas; es decir, en la descripci\u00f3n de la BD. Se conocen gen\u00e9ricamente como DDL o data de - finition language . Incluso hay lenguajes espec\u00ed ficos para esquemas inter - nos, lenguajes para esqu emas conceptuales y lenguajes para esquemas externos. Otros lenguajes est\u00e1n espe cializados en la utilizac i\u00f3n de la BD (consul - tas y mantenimiento) . Se conocen como DML o data management lan - guage . Sin embargo, lo m\u00e1s frecuente es que el mismo lenguaje disponga de construcciones para la s dos funciones, DDL y DML.\u00bfQu\u00e9 deber\u00eda poder decir el usuario al SGBD? Por un lado, la persona que hace el dise\u00f1o debe tener la posibilidad de describir al SGBD la BD que ha dise\u00f1ado. Por otro lado, debe ser posible pedirle al sistema que rellene y actualice la base de datos con los datos que se le den. Adem\u00e1s, y obviamente, el usuario debe disponer de medios para hacerle consultas. * Por ejemplo, personas dedicadas a introducir datos masivamente. El lenguaje SQL se explicar\u00e1 en la unidad did\u00e1ctica \"El lenguaje SQL\" de este curso. FUOC 71Z799014MO 33 Introducci\u00f3n a las bases de datos En cuanto a los aspectos DML , podemos diferenciar do s tipos de lenguajes: a)Lenguajes muy declarativos (o impl\u00edcitos), con los que se especifica qu\u00e9 se quiere hacer sin explicar c\u00f3mo se debe hacer. b)Lenguajes m\u00e1s expl\u00edcitos o procedimentales , que nos exigen conocer m\u00e1s cuestiones del funcionamiento del SGBD para detallar paso a paso c\u00f3mo se de - ben realizar las operacio nes (lo que se denomina navegar por la BD). Como es obvio, los aspectos DDL (las descripciones de los datos) son siempre declarativos por su propia naturaleza. Los lenguajes utilizados en los SGBD prer relacionales eran procedimentales. SQL es b\u00e1sicamente declarativo, pero tiene posibilidades procedimentales. Tanto los 4GL como las herramientas visuales (con frecuencia unidas en una sola herramienta) traducen lo que hace el usuario a instrucciones SQL por dis - tintas v\u00edas: En el caso de los 4GL, la traducci\u00f3n se suele hacer mediante la compilaci\u00f3n. En el caso de las herramientas visuales , se efect\u00faa por medio del int\u00e9rprete de SQL integrado en el SGBD. Si queremos escribir un programa de aplicaci\u00f3n que trabaje con BD, segura - mente querremos utilizar nuestro lenguaje habitual de programaci\u00f3n*. Sin embargo, generalmente estos lenguajes no tienen instrucciones para realizar el acceso a las BD. Entonces tene mos las dos opciones siguientes: Aunque casi todos los SGBD del mercado tienen SQL como lenguaje na - tivo, ofrecen otras posi bilidades, como por ejem plo herramientas visuales: 1) Lenguajes 4GL (4th Generation Languages )* de muy alto nivel, que suelen combinar elementos proced imentales con elementos declarati - vos. Pretenden facilitar no s\u00f3lo el tr atamiento de la BD , sino tambi\u00e9n la definici\u00f3n de men\u00fas, pantallas y di\u00e1logos. 2) Herramientas o interfaces visuales ** muy f\u00e1ciles de utilizar, que permiten usar las BD siguiendo el esti lo de di\u00e1logos con ventanas, iconos y rat\u00f3n, puesto de moda por las apli caciones Windows. No s\u00f3lo son \u00fatiles a los usuarios no inform\u00e1ticos, sino que facilitan mucho el trabajo a los usuarios inform\u00e1ticos: pe rmiten consultar y actualizar la BD, as\u00ed como definirla y actualizar su definici \u00f3n con mucha facilidad y claridad.Lenguajes declarativos y procedimentales El aprendizaje y la utilizaci\u00f3n de los lenguajes procedimen-tales acostumbran a ser m\u00e1s dif\u00edciles que los declarativos, y por ello s\u00f3lo los utilizan usuarios inform\u00e1ticos. Con los procedimentales se pueden escribir procesos m\u00e1s eficientes que con los declarativos. * Empezaron a aparecer al final de los a\u00f1os ochenta. ** Han proliferado en los a\u00f1os noventa. * Pascal, C, Cobol, PL/I, Basic, MUMPS, Fortran, Java, etc. FUOC 71Z799014MO 34 Introducci\u00f3n a las bases de datos 1)Las llamadas a funciones : en el mercado hay librer\u00edas de funciones espe - cializadas en BD (por ejem plo, las librer\u00edas ODBC). S\u00f3lo es preciso incluir lla - madas a las funciones deseadas dentro del programa escrit o con el lenguaje habitual. Las funciones ser\u00e1n las que se encargar\u00e1n de enviar las instrucciones (generalmente en SQL) en ti empo de ejecuci\u00f3n al SGBD. 2)El lenguaje hospedado : otra posibilidad consiste en incluir directamente las instrucciones del lengua je de BD en nuestro programa. Sin embargo, esto exige utilizar un precompilador especia lizado que acepte en nuestro lenguaje de programaci\u00f3n habitual las instruccio nes del lenguaje de BD. Entonces se dice que este lenguaje (casi siempre SQ L) es el lenguaje hospedado o incorpo - rado ( embedded ), y nuestro lenguaje de programaci\u00f3n (Pascal, C, Cobol, etc.) es el lenguaje anfitri\u00f3n ( host). FUOC 71Z799014MO 35 Introducci\u00f3n a las bases de datos 7. Administraci\u00f3n de BD Los administradores de BD son los responsables de l correcto funcionamiento de la BD y velan para que siempre se ma ntenga \u00fatil. Intervienen en situaciones problem\u00e1ticas o de emergenc ia, pero su responsabilid ad fundamental es velar para que no se produzcan incidentes. A continuaci\u00f3n damos una lista de tareas t\u00edpicas del ABD: 1)Mantenimiento, administraci\u00f3n y cont rol de los esquem as. Comunicaci\u00f3n de los cambios a los usuarios. 2)Asegurar la m\u00e1xima disponibilidad de los datos; por ejemplo, haciendo co - pias ( back-ups ), administrando diarios ( journals la BD, etc. 3)Resoluci\u00f3n de emergencias. 4)Vigilancia de la integridad y de la calidad de los datos. 5)Dise\u00f1o f\u00edsico, estrategia de camino s de acceso y reestructuraciones. 6)Control del rendimiento y decisiones relativas a la s modificaciones en los esquemas y/o en los par\u00e1metros de l SGBD y del SO, para mejorarlo. 7)Normativa y asesoramiento a los programadores y a los usuarios finales so - bre la utilizaci\u00f3n de la BD. 8)Control y administraci\u00f3n de la segurida d: autorizaciones, restricciones, etc. La tarea del ABD no es sencilla. Los SGBD del mercado procuran reducir al m\u00ednimo el volumen de estas tareas, pero en siste - mas muy grandes y cr\u00edticos se llega a tener gr upos de ABD de m\u00e1s de diez personas. Buena parte del software que acompa\u00f1a el SGBD est\u00e1 orientado a facilitar la gran diversidad de tareas controladas por el ABD: monitores del rendimient o, monitores de la se guridad, verificadores de la consistencia entre \u00edndices y datos, reorganizadore s, gestores de las copias de seguridad, etc. La mayor\u00eda de estas herramie ntas tienen interfaces visuales para facilitar la tarea del ABD.Hay un tipo de usuario especial: el que realiza tareas de administraci\u00f3n y control de la BD. Una empresa o in stituci\u00f3n que tenga SI construidos en torno a BD necesita que alguien lleve a cabo una serie de funciones centralizadas de gesti\u00f3n y administra ci\u00f3n, para asegurar que la explota - ci\u00f3n de la BD es la correcta. Este conjunto de funcio nes se conoce con el nombre de administraci\u00f3n de BD (ABD) , y los usuarios que hacen este tipo especial de trabajo se denominan administradores de BD . FUOC 71Z799014MO 36 Introducci\u00f3n a las bases de datos Resumen En esta unidad hemos hecho una introd ucci\u00f3n a los conceptos fundamentales del mundo de las BD y de los SGBD. He mos explicado la ev oluci\u00f3n de los SG - BD, que ha conducido de una estructura centralizada y poco flexible a una dis - tribuida y flexible, y de una utilizaci\u00f3 n procedimental que requer\u00eda muchos conocimientos a un uso declarativo y sencillo. Hemos revisado los objetivos de los SGBD actuales y algunos de los servicios que nos dan para conseguirlos. Es espe cialmente importante el concepto de transacci\u00f3n y la forma en que se utiliza para velar por la integridad de los datos. La arquitectura de tres niveles aporta una gran flexibilidad a los cambios, tanto a los f\u00edsicos como a los l\u00f3gicos. Hemos visto c\u00f3mo un SGBD puede fun - cionar utilizando los tres esquemas propios de esta arquitectura. Hemos explicado que los componentes de un modelo de BD son las estruc - turas, las restricciones y las operaciones. Los diferentes modelos de BD se dife - rencian b\u00e1sicamente por sus estructura s. Hemos hablado de los modelos m\u00e1s conocidos, especialmente del modelo relacional, que est\u00e1 basado en tablas y que estudiaremos m\u00e1s adelante. Cada tipo de usuario del SGBD puede utilizar un leng uaje apropiado para su trabajo. Unos usuarios con una tarea importante y dif\u00edcil son los administra - dores de las BD .El modelo relacional se estudiar\u00e1 en la unidad\"El modelo relacional y el \u00e1lgebra relacional\" de este curso. FUOC 71Z799014MO 37 Introducci\u00f3n a las bases de datos Actividades 1.Comparad la lista de los objetivos de los SGBD qu e hemos dado aqu\u00ed con la que se da en otros libros, y haced otra lista co n las diferencias que encontr\u00e9is. 2.Buscad informaci\u00f3n t\u00e9cnica y comercial de lo s fabricantes de SGBD sobre sus productos y a partir de aqu\u00ed intentad reconocer los conc eptos que hemos introducido en esta unidad. 3.Leed alg\u00fan informe \"Estado de l arte\" sobre SGBD de los que se publican (normalmente cada a\u00f1o) en la revista Byte y en Datamation . Ejercicios de autoevaluaci\u00f3n 1.\u00bfQu\u00e9 ventajas aportaron los SGBD relacion ales con respecto a los prerrelacionales? 2.Para mejorar la disponibilidad y el coste, hemos decidido que una cierta parte de una BD que est\u00e1 situada en el ordenador central de la empresa estar\u00e1 duplicada (replicada) en un or - denador situado en una oficina alejada (conecta do permanentemente por v\u00eda telef\u00f3nica). Los programas que actualizan la BD, \u00bftendr\u00edan que preocuparse de ac tualizar tambi\u00e9n la r\u00e9plica? \u00bfPor qu\u00e9? 3.Hemos programado una transacci\u00f3n para consultar cu\u00e1ntos alumnos cursan una asigna - tura. Si este n\u00famero es inferior a quince, se nos informar\u00e1 de cu\u00e1ntos hay y en una lista, en una hoja de papel o en la pantalla nos aparecer \u00e1n todos ellos. Sin embargo, si es superior o igual a quince, simplemente dir\u00e1 cu\u00e1ntos hay. Supongamos que de forma concurrente con esta transacci\u00f3n se podr\u00e1n esta r ejecutando otras que inserten nuevos alumnos o que los su - priman. \u00bfQu\u00e9 problema se podr\u00e1 producir si el SGBD no a\u00edsla totalmente las transacciones? 4.De las siguientes afirmaciones, decid cu\u00e1les son ciertas y cu\u00e1les son falsas: a)El modelo ER es m\u00e1s conocido como modelo relacional . b)Los SGBD no permiten la redundancia. c)El DML es un lenguaje declarativo. d)El DDL es un lenguaje pensado para escribir programas de consulta y actualizaci\u00f3n de BD. e)En un ordenador que act\u00faa como servidor de BD, con dos RAID y tres discos duros y con un SGBD actual, no es necesario que los encarg ados de realizar los programas para consultar esta BD sepan en qu\u00e9 discos est\u00e1. f)Cuando un programa quiere acceder a unos dato s mediante un \u00edndice, lo debe decir al SGBD.Lectura recomendada Consultad las obras de la bibliograf\u00eda que encontrar\u00e9is al final de esta unidad. FUOC 71Z799014MO 38 Introducci\u00f3n a las bases de datos Solucionario Ejercicios de autoevaluaci\u00f3n 1.Los SGBD relacionales aporta ron una programaci\u00f3n m\u00e1s sencilla: los lenguajes son m\u00e1s sencillos y no dependen tanto de las caracter\u00edsticas f\u00edsicas de la BD. Se da m\u00e1s flexibilidad a los cambios (m\u00e1s independencia f\u00edsica de los datos). El programador se debe preocupar mu - cho menos de las cuestiones de rendimiento, pues de ello ya se ocupa el SGBD. Incluyen len - guajes declarativos de consulta para usuarios no inform\u00e1ticos. 2.Si la actualizaci\u00f3n no se hace en los dos lugares, la redundancia nos puede comportar proble - mas de consistencia de los datos. El administrador de la BD de ber\u00eda poder describir qu\u00e9 quiere que est\u00e9 replicado y c\u00f3mo quiere que se haga el mantenimiento de la r\u00e9 plica. El SGBD deber\u00eda encargarse de mantener la r\u00e9plica actualizada corre ctamente. Si la actualizaci\u00f3n de la r\u00e9plica la tuviesen que hacer los programas de aplicaci\u00f3n, podr\u00eda suceder que alguno de ellos no lo hiciese, o incluso que la actualizaci\u00f3n la hiciese (mal) un usuario directo, sin escribir un programa. Y todav\u00eda m\u00e1s, los programas de aplicaci\u00f3n y los us uarios directos deber\u00edan ser totalmente ajenos a estos temas f\u00edsicos (rendimiento, disponibilidad, etc.), ya que de este modo se podr\u00edan cambiar las decisiones, como por ejemplo variar la pol\u00edtica de r\u00e9plicas, sin que se tuviesen que modificar los programas ni avisar a nadie. Simplemente debe intervenir el ABD mediante el lenguaje de descripci\u00f3n del nivel f\u00edsico. Actualmente, los SG BD del mercado ya dan este nivel de indepen - dencia. 3.Supongamos que la transacci\u00f3n consulta al SG BD cu\u00e1ntos alumnos hay, y el SGBD cuenta trece. El programa preparar\u00e1 una l\u00ednea de cabecera de list a que indique que hay trece alum - nos, y a continuaci\u00f3n los most rar\u00e1. Sin embargo, entre el mo mento en que fabrica esta cabe - cera y el momento de empezar a leer a los alumnos uno por uno para mostrarlos, otras transacciones (que se ejecutan concurrentemente con \u00e9sta) eliminan a dos alumnos. Enton - ces, el programa nos mostrar\u00e1 s\u00f3lo a on ce, a pesar de que hab\u00eda anunciado trece. Y si las transacciones concurrentes que hacen actualizaciones hubiesen insertado tres alum - nos, la cabecera dir\u00eda que hay trece, y mostrar\u00ed a en realidad diecis\u00e9is (\u00a1y no tendr\u00eda que mos - trar nunca m\u00e1s de quince!). Estos problemas de concurrencia pueden surgir si el SGBD no lleva un control que evite las interferencias. 4. a) Falsa, b) Falsa, c) Falsa, d) Falsa, e) Cierta, f) Falsa. Glosario administrador de BD Tipo de usuario especial que realiza funciones de administraci\u00f3n y control de la BD, que ase - guran que la explotaci\u00f3n de la BD es correcta. base de datos Conjunto estructurado de datos que representa entidades y sus interrelaciones. La represen - taci\u00f3n ser\u00e1 \u00fanica e integrada, a pesar de que debe permitir diversas utilizaciones. sigla: BD BD Ved: base de datos . cliente/servidor Tecnolog\u00eda habitual para distribu ir datos. La idea es que dos procesos diferentes, que se pue - den ejecutar en un mismo sistema o en sistem as separados, act\u00faan de modo que uno act\u00faa de cliente o peticionario de un servicio y el otro, como servidor. Un proceso cliente puede pedir servicios a distintos servidores. Un servid or puede recibir petici ones de muchos clien - tes. En general, un proceso A que act\u00faa como cliente pidiendo un servicio a otro proceso B puede hacer tambi\u00e9n de servidor de un servicio que le pida otro proceso C. sigla: C/S C/S Ved: cliente/servidor . data definition language Lenguaje especializado en la escritura de esquemas; es deci r, en la descripci\u00f3n de BD. Sigla: DDL data manipulation language Lenguaje especializado en la utilizaci\u00f3n de BD (consultas y mantenimiento). Sigla: DML FUOC 71Z799014MO 39 Introducci\u00f3n a las bases de datos DDL Ved: data definition language. DML Ved: data manipulation language . esquema Descripci\u00f3n o definici\u00f3n de la BD. Esta descripci\u00f3 n est\u00e1 separada de los programas y es utilizada por el SGBD para saber c\u00f3mo es la BD con la que debe trabajar. La ar quitectura ANSI/SPARC recomienda tres niveles de esquem as: el externo (visi\u00f3n de los us uarios), el conceptual (visi\u00f3n global) y el f\u00edsico (descripci\u00f3n de caracter\u00edsticas f\u00edsicas). SGBD Ved: sistema de gesti\u00f3n de BD . sistema de gesti\u00f3n de BD Software que gestiona y controla BD. Sus principales funciones son facilitar la utilizaci\u00f3n de la BD a muchos usuarios simult\u00e1neos y de tipos diferentes, independiz ar al usuario del mun - do f\u00edsico y mantener la integridad de los datos. sigla: SGBD SQL Ved: structured query language . structured query language Lenguaje especializado en la descripci\u00f3n (DDL) y la utilizaci\u00f3n (DML) de BD relacionales. Creado por IBM al final de los a\u00f1os setenta y estandarizado por ANSI-ISO en 1985 (el \u00faltimo est\u00e1ndar de SQL es de 1999). En la actualidad lo utilizan pr\u00e1cticamente todos los SGBD del mercado. sigla: SQL transacci\u00f3n Conjunto de operaciones (de BD) que queremos que se ejecuten como un todo (todas o ninguna) y de forma aislada (sin interferencias) de otros conjuntos de operaciones que se ejecuten concu - rrentemente. Bibliograf\u00eda Bibliograf\u00eda b\u00e1sica Date, C.J. (2001). Introducci\u00f3n a los sistemas de bases de datos (7\u00aa ed.). Prentice Hall. Silberschatz, A; Korth, H.F; Sudarshan, bases de datos (3.a ed.). Madrid: McGraw-Hill. La introducci\u00f3n de este libro es similar a la que hemos hecho aqu\u00ed. Bibliograf\u00eda complementaria Para actualizar vuestra visi\u00f3n global de los SGBD del mercado, pod\u00e9is consultar en Internet las p\u00e1ginas de los fabricantes de SGBD; por ejemplo: I n f o r m i x : http://www.informix.com O r a c l e : http://www.oracle.com I B M : http://www.ibm.com Computer Associates : http://www.ca.com M i c r o s o f t : http://www.microsoft.com N C R : http://www.ncr.com El modelo relacional y el \u00e1lgebra relacional Dolors Costal Costa FUOC 71Z799014MO El modelo relacional y el \u00e1lgebra relacional \u00cdndice Introducci\u00f3n ............................................................................................... 5 Objetivos ...................................................................................................... 6 1. Introducci\u00f3n al modelo relacional .................................................. 7 2. Estructura de los datos ....................................................................... 9 2.1. Visi\u00f3n informal de una relaci\u00f3n........................................................ 92.2. Visi\u00f3n formal de una relaci\u00f3n........................................................... 10 2.3. Diferencias entre relaciones y ficheros.............................................. 12 2.4. Clave candidata, clave primaria y clave alternativa de las relaciones................................................................................. 14 2.5. Claves for\u00e1neas de las relaciones....................................................... 152.6. Creaci\u00f3n de las relaciones de una base de datos............................... 18 3. Operaciones del modelo relacional ................................................. 19 4. Reglas de integridad ............................................................................ 21 4.1. Regla de integridad de unicidad de la clave primaria ....................... 22 4.2. Regla de integridad de entidad de la clave primaria ......................... 234.3. Regla de integridad referencial .......................................................... 24 4.3.1. Restricci\u00f3n.............................................................................. 264.3.2. Actualizaci\u00f3n en cascada........................................................ 274.3.3. Anulaci\u00f3n............................................................................... 29 4.3.4. Selecci\u00f3n de la po l\u00edtica de mantenimiento de la integridad referencial .................................................... 30 4.4. Regla de integridad de dominio ........................................................ 31 5. El \u00e1lgebra relacional ........................................................................... 33 ............................................................................... 39 5.1.4. Producto cartesiano................................................................ 40 5.2. Operaciones espec\u00edficamente relacionales ........................................ 41 5.2.1. Selecci\u00f3n................................................................................. 415.2.2. Proyecci\u00f3n.............................................................................. 425.2.3. Combinaci\u00f3n ......................................................................... 43 5.3. Secuencias de operaciones del \u00e1lgebra relacional ............................. 46 5.4. Extensiones: combinaciones externas............................................... 47 FUOC 71Z799014MO El modelo relacional y el \u00e1lgebra relacional Resumen ....................................................................................................... 51 Ejercicios de autoevaluaci\u00f3n .................................................................. 53 ........................................................................................................ 56 Bibliograf\u00eda ................................................................................................. 58 FUOC 71Z799014MO 5 El modelo relacional y el \u00e1lgebra relacional Introducci\u00f3n Esta unidad did\u00e1ctica est\u00e1 dedicada al estudio del modelo de datos relacional y del \u00e1lgebra relacional. El concepto de modelo de datos se ha presentado en otra unidad did\u00e1ctica. En \u00e9sta se profundiza en un modelo de datos concreto: el modelo relacional , que actualmente tiene una gran relevancia . Sus conceptos fundamentales est\u00e1n bien asentados y, adem\u00e1s, los sistemas de gesti\u00f3n de bases de datos relaciona- les son los m\u00e1s extendidos en su utiliz aci\u00f3n pr\u00e1ctica. Por estos motivos pensa- mos que es importante conocerlo. El estudio del modelo relacional sirve, adem\u00e1s, de base para los contenidos de otra unidad, dedicada al lenguaje SQL. Este lenguaje permite definir y mani- pular bases de datos relacionales. Los fundamentos del modelo relacional re- sultan imprescindibles para cons eguir un buen dominio del SQL. En esta unidad se analizan tambi\u00e9n las operaciones del \u00e1lgebra relacional , que sirven para hacer consultas a una base de datos. Es preciso conocer estasoperaciones porque nos permiten saber qu \u00e9 servicios de consulta debe propor- cionar un lenguaje relacional. Otra apor taci\u00f3n del \u00e1lgebra relacional es que fa- cilita la comprensi\u00f3n de algunas de las construccion es del lenguaje SQL que se estudiar\u00e1n en otra unidad did\u00e1ctica de este curso. Adem\u00e1s, constituye la base para el estudio del tratamiento de las consultas que efec t\u00faan los SGBD in- ternamente (especialmente en lo que resp ecta a la optimizaci\u00f3n de consultas). Este \u00faltimo tema queda fuera del \u00e1mbito del presente curso, pero es relevante para estudios m\u00e1s avanzados sobre bases de datos.Consultad el concepto de modelo de datos en la unidad did\u00e1ctica \"Introducci\u00f3n a las bases de datos\" de este curso. Las construcciones del SQL se estudian en la unidaddid\u00e1ctica \"El lenguaje SQL\". FUOC 71Z799014MO 6 El modelo relacional y el \u00e1lgebra relacional Objetivos En los materiales did\u00e1cticos de esta unidad encontrar\u00e9is las herramientas in- dispensables para alcanzar los siguientes objetivos: 1.Conocer los fundamentos del mo delo de datos relacional. 2.Saber distinguir las caract er\u00edsticas que debe tener un sistema de gesti\u00f3n de bases de datos relacional para que sea coherente con los fundamentos del modelo relacional. 3.Comprender las ventajas del modelo re lacional que derivan del alto grado de independencia de los datos que pr oporciona, y de la simplicidad y la uniformidad del modelo. 4.Conocer las operaciones del \u00e1lgebra relacional. 5.Saber utilizar las operacio nes del \u00e1lgebra relacional para consultar una base de datos. FUOC 71Z799014MO 7 El modelo relacional y el \u00e1lgebra relacional 1. Introducci\u00f3n al modelo relacional Un sistema de gesti\u00f3n de ba ses de datos relacional (SGBDR) da apoyo a la definici\u00f3n de datos mediante la estructura de los datos del modelo relacional,as\u00ed como a la manipulaci\u00f3n de estos datos con las operaciones del modelo; adem\u00e1s, asegura que se satisfacen las regl as de integridad que el modelo rela- cional establece. Los principios del modelo de datos relaci onal fueron establecidos por E.F. Codd en los a\u00f1os 1969 y 1970. De todos modos, hasta la d\u00e9cada de los ochenta no se empezaron a comercializar los primeros SGBD relacionales con rendimientos aceptables. Cabe se\u00f1alar que los SGBD re lacionales que se comercializan actual- mente todav\u00eda no soportan todo lo que esta blece la teor\u00eda relacional hasta el \u00fal- timo detalle. El principal objetivo del modelo de datos relacional es facilitar que la base de datos sea percibida o vista por el usuario como una estructura l\u00f3gica que consis- te en un conjunto de relaciones y no como una estructura f\u00edsica de implemen- taci\u00f3n. Esto ayuda a conseguir un alto grado de independencia de los datos. Un objetivo adicional de l modelo es conseguir que esta estructura l\u00f3gica con la que se percibe la base de datos sea simple y uniforme. Con el fin de proporcionar simplicidad y uniformidad , toda la informaci\u00f3n se representa de una \u00fanica manera: mediante valore s expl\u00edcitos que contienen las rela- ciones (no se utilizan conceptos como por ejemplo apuntadores entre las relaciones). Con el mismo prop\u00f3sito, todos los valo res de datos se conside- ran at\u00f3micos; es decir, no es posible descomponerlos. Hay que precisar que un SGBD relacional, en el nivel f\u00edsico, puede emplear cualquier estructura de da tos para implementar la es tructura l\u00f3gica formadaEl modelo relacional es un modelo de datos y, como tal, tiene en cuen- ta los tres aspectos si guientes de los datos: 1)La estructura , que debe permitir represen tar la informaci\u00f3n que nos interesa del mundo real. 2)La manipulaci\u00f3n , a la que da apoyo mediante las operaciones de ac- tualizaci\u00f3n y consul ta de los datos. 3)La integridad , que es facilitada mediante el establecimiento de re- glas de integridad; es decir, cond iciones que los da tos deben cumplir.El concepto de modelo de datos se ha explicado en la unidad did\u00e1ctica \"Introducci\u00f3n a las basesde datos\"de este curso. El concepto de SGBD ha sido presentado en la unidad did\u00e1ctica \"Introducci\u00f3n a las bases de datos\" de este curso. FUOC 71Z799014MO 8 El modelo relacional y el \u00e1lgebra relacional por las relaciones. En part icular, a nivel f\u00edsico, el sistema puede utilizar apun- tadores, \u00edndices, etc. Sin embargo, esta implementaci \u00f3n f\u00edsica queda oculta al usuario. En los siguientes apartados estudiaremos la estructura de los datos, las operacio- nes y las reglas de integridad del modelo relacional. Hay dos formas posibles de enfocar el estudio de los contenidos de este m\u00f3dulo. La primera consiste en se-guirlos en orden de exposici\u00f3n. De este modo, se van tratando todos los elemen- tos de la teor\u00eda del modelo relacional de forma muy precisa y en un orden l\u00f3gico. Otra posibilidad, sin embargo, es empezar con la lectura del resumen fi- nal del m\u00f3dulo y leer despu\u00e9s todo el re sto de los contenidos en el orden nor- mal. El resumen describe los aspectos m\u00e1s relevantes de la te or\u00eda relacional que se explican y, de este modo, proporci ona una visi\u00f3n global de los contenidos del m\u00f3dulo que, para algunos estudiante s, puede ser \u00fatil comprender antes de iniciar un estudio detallado. FUOC 71Z799014MO 9 El modelo relacional y el \u00e1lgebra relacional 2. Estructura de los datos La estructura de los datos del modelo re lacional se basa, pues, en el concepto de relaci\u00f3n . 2.1. Visi\u00f3n informal de una relaci\u00f3n En primer lugar, presentaremos el concepto de relaci\u00f3n de manera informal. Se puede obtener una buena idea intuitiva de lo que es una relaci\u00f3n si la visuali- zamos como una tabla o un fichero. En la figura 1 se muestra la visualizaci\u00f3ntabular de una relaci\u00f3n que contiene datos de empleados. Cada fila de la tabla contiene una colecci\u00f3n de valores de da tos relacionados entre s\u00ed; en nuestro ejemplo, son los datos correspondientes a un mismo empleado. La tabla tieneun nombre ( EMPLEADOS ) y tambi\u00e9n tiene un nombre cada una de sus colum- nas (DNI, nombre, apellido y sueldo ). El nombre de la ta bla y los de las columnas ayudan a entender el significado de los valores que contiene la tabla. Cada co- lumna contiene valores de un cierto dominio; por ejemplo, la columna DNI contiene valores del dominio n\u00famerosDNI . Figura1El modelo relacional proporciona una estructura de los datos que con- siste en un conjunto de relaciones con objeto de representar la informa- ci\u00f3n que nos interesa del mundo real. Conjunto de relaciones Una base de datos relacional consta de un conjunto de relaciones, cada una de las cuales se puede visualizar de este modo tan sencillo. La estructura de los datos del modelo relacional resulta f\u00e1cil de entender para el usuario. FUOC 71Z799014MO 10 El modelo relacional y el \u00e1lgebra relacional Si definimos las relaciones de forma m\u00e1 s precisa, nos daremos cuenta de que presentan algunas caracter\u00edsticas importan tes que, en la visi\u00f3n superficial que hemos presentado, quedan ocultas. Esta s caracter\u00edsticas son las que motivan que el concepto de relaci\u00f3n sea totalmente diferente del de ficher o, a pesar de que, a primera vista, relaciones y ficheros puedan parecer similares. 2.2. Visi\u00f3n formal de una relaci\u00f3n A continuaci\u00f3n definimos formalmente las relaciones y otros conceptos que est\u00e1n vinculados a ellas, como por ejemplo dominio, esquema de relaci\u00f3n , etc. Los dominios pueden ser de dos tipos: 1) Dominios predefinidos , que corresponde a los tipos de datos que normal- mente proporcionan los lenguajes de bases de datos, como por ejemplo los en-teros, las cadenas de caracteres, los reales, etc. 2) Dominios definido s por el usuario , que pueden ser m\u00e1 s espec\u00edficos. Toda definici\u00f3n de un dominio debe consta r, como m\u00ednimo, del nombre del domi- nio y de la descripci\u00f3n de los va lores que forman parte de \u00e9ste. Si consideramos la representaci\u00f3n tabu lar anterior (figura 1), el esquema co- rresponder\u00eda a la cabecera de la tabla y la extensi\u00f3n corresponder\u00eda al cuerpo: Figura 2Un dominio D es un conjunto de valores at\u00f3micos. Por lo que respecta al modelo relacional, at\u00f3mico significa indivisible; es decir, que por muy complejo o largo que sea un valor at\u00f3mico, no tiene una estructuraci\u00f3ninterna para un SGBD relacional. Un relaci\u00f3n se compone del esquema (o intensi\u00f3n de la relaci\u00f3n) y de la extensi\u00f3n . Dominio definido por el usuario Por ejemplo, el usuario puede definir un dominio para las edades de los empleados que se denomine dom_edad y que contenga los valores enteros que est\u00e1n entre 16 y 65. Empleados DNI nombre apellido sueldo 40.444.255 Juan Garc\u00eda 2.00033.567.711 Marta Roca 2.50055.898.425 Carlos Buend\u00eda 1.500Esquema Extensi\u00f3n El esquema de la relaci\u00f3n consiste en un nombre de relaci\u00f3n R y un conjunto de atributos { A1, A2, ..., An}. FUOC 71Z799014MO 11 El modelo relacional y el \u00e1lgebra relacional Nombre y conjunto de at ributos de la relaci\u00f3n EMPLEADOS Si tomamos como ejemplo la figura 1, el nombre de la relaci\u00f3n es EMPLEADOS y el conjunto de atributos es { DNI, nombre, apellido, sueldo }. Tomaremos la convenci\u00f3n de denotar el esquema de la relaci\u00f3n de la forma siguiente: R( A1, A2, ..., An), donde R es el nombre la relaci\u00f3n y A1, A2, ..., An es una ordenaci\u00f3n cualquiera de los atributos que pertenecen al conjunto {A1, A2, ..., An}. Denotaci\u00f3n del esquema de la relaci\u00f3n EMPLEADOS El esquema de la relaci\u00f3n de la figura 1 se pod r\u00eda denotar, por ejemplo, como EMPLEA- DOS(DNI, nombre, apellido, sueldo ), o tambi\u00e9n, EMPLEADOS (nombre, apellido, DNI, sueldo ), porque cualquier ordenaci\u00f3n de sus atributos se considera v\u00e1li da para denotar el esquema de una relaci\u00f3n. Dominio del atributo DNI Seg\u00fan la figura 1, el atributo DNI corresponde al papel que ejerce el dominio n\u00famerosDNI en el esquema de la relaci\u00f3n EMPLEADOS y, entonces, dominio( DNI) = n\u00famerosDNI . Conviene observar que cada atributo es \u00fanico en un esquema de relaci\u00f3n, por- que no tiene sentido que un mismo domi nio ejerza dos veces el mismo papel en un mismo esquema. Por consiguiente , no puede ocurrir que en un esquema de relaci\u00f3n haya dos atributos con el mismo nombre. En cambio, s\u00ed que se puede repetir un nombre de atributo en relaciones diferentes. Los dominios de los atributos, por el contrario, no de ben ser necesariamen te todos diferentes en una relaci\u00f3n. Ejemplo de atributos diferentes con el mismo dominio Si tomamos como ejemplo el esquema de relaci\u00f3n PERSONAS(DNI, nombre, apellido, telcasa, teltrabajo ), los atributos telcasa y teltrabajo pueden tener el mismo dominio: dominio( telcasa )= = tel\u00e9fono y dominio( teltrabajo ) = tel\u00e9fono . En este caso, el dominio tel\u00e9fono ejerce dos papeles diferentes en el esquema de relaci\u00f3n: el de indicar el tel\u00e9fono particular de un a persona y el de indicar el del trabajo. Para simplificar, tomare mos la convenci\u00f3n de referirnos a una tupla ti = {<A1:vi1>, <A2:vi2>, ..., <An:vin>} que pertenece a la extensi\u00f3 n del esquema denotado como R(A1, A2, ..., An), de la forma siguiente: ti = <vi1, vi2, ..., vin>. Un atributo Ai es el nombre del papel que ejerce un dominio D en un es- quema de relaci\u00f3n. D es el dominio de Ai y se denota como dominio ( Ai). La extensi\u00f3n de la relaci\u00f3n de esquema R( A1, A2, ..., An) es un con- junto de tuplas ti (i = 1, 2, ..., m ), donde cada tupla ti es, a su vez un con- junto de pares ti = {<A1:vi1>, <A2:vi2> ... >An:vin>} y, para cada par <Aj:vij>, se cumple que vij es un valor de dominio( Aj), o bien un valor especial que denominaremos nulo. Algunos autores... ... denominan tablas , columnas y filas a las relaciones, los atributos y las tuplas, respectivamente. FUOC 71Z799014MO 12 El modelo relacional y el \u00e1lgebra relacional Si denotamos el esquema de la relaci\u00f3n representada en la figura 1 como EM- PLEADOS( DNI, nombre, apellido, sueldo ), el conjunto de tuplas de su extensi\u00f3n ser\u00e1 el de la figura siguiente: Figura 3 Si en una tupla ti = <vi1, vi2, ..., vin>, el valor vij es un valor nulo , entonces el valor del atributo Aj es desconocido para la tupla ti de la relaci\u00f3n, o bien no es aplicable a esta tupla. Ejemplo de valor nulo Podr\u00edamos tener un atributo telcasa en la relaci\u00f3n EMPLEADOS y se podr\u00eda dar el caso de que un empleado no tuviese tel\u00e9fono en su casa, o bien que lo tuviese, pero no se conociese su n\u00famero. En las dos situaciones, el valor del atributo telcasa para la tupla correspondiente al empleado ser\u00eda el valor nulo. Grado de la relaci\u00f3n EMPLEADOS El grado de la relaci\u00f3n de esquema EMPLEADOS( DNI, nombre, apellido, sueldo ), es 4. Cardinalidad de la relaci\u00f3n EMPLEADOS Observando la figura 3 se deduce que la cardin alidad de la relaci\u00f3n EMPLEADOS es 3. 2.3. Diferencias entre relaciones y ficheros A primera vista, relaciones y ficheros resultan similares. Los registros y los campos que forman los ficheros se parecen a las tuplas y a los atributos de lasrelaciones, respectivamente.El grado de una relaci\u00f3n es el n\u00famero de atributos que pertenecen a su esquema. La cardinalidad de una relaci\u00f3n es el n\u00famero de tuplas que pertenecen a su extensi\u00f3n. Esta figura... ... nos muestra la extensi\u00f3n de EMPLEADOS en forma de conjunto, mientras que las figuras anteriores nos la mostraban en forma de filasde una tabla. La representa-ci\u00f3n tabular es m\u00e1s c\u00f3moda, pero no refleja la definici\u00f3n de extensi\u00f3n con tanta exactitud. FUOC 71Z799014MO 13 El modelo relacional y el \u00e1lgebra relacional A pesar de esta similitud superficial, la visi\u00f3n formal de relaci\u00f3n que hemos pre- sentado establece algunas caracter\u00edsticas de las relaciones que las hacen diferen-tes de los ficheros cl\u00e1sicos. A continua ci\u00f3n describimos estas caracter\u00edsticas: 1) Atomicidad de los valores de los atributos : los valores de los atributos de una relaci\u00f3n deben ser at\u00f3micos; es deci r, no deben tener estructura interna. Esta caracter\u00edstica provie ne del hecho de que los atributos siempre deben to- mar un valor de su dominio o bien un valor nulo, y de que se ha establecido que los valores de los dominios deben se r at\u00f3micos en el modelo relacional. El objetivo de la atomicidad de los va lores es dar simplicidad y uniformidad al modelo relacional. 2) No-repetici\u00f3n de las tuplas : en un fichero cl\u00e1sico puede ocurrir que dos de los registros sean exactamente iguales; es decir, que contengan los mismos da- tos. En el caso del modelo relacional, en cambio, no es posible que una relaci\u00f3n contenga tuplas repetidas. Esta caracter \u00edstica se deduce de la misma definici\u00f3n de la extensi\u00f3n de una relaci\u00f3n. La extens i\u00f3n es un conjunto de tuplas y, en un conjunto, no puede haber elementos repetidos. 3) No-ordenaci\u00f3n de las tuplas: de la definici\u00f3n de la extensi\u00f3n de una rela- ci\u00f3n como un conjunto de tuplas se deduce tambi\u00e9n que estas tuplas no esta-r\u00e1n ordenadas, teniendo en cuenta que no es posible que haya una ordenaci\u00f3n entre los elementos de un conjunto. La finalidad de esta caracter\u00edstica es conseguir que, mediante el modelo rela- cional, se puedan representar los hechos en un nivel abstracto que sea inde-pendiente de su estructura f\u00edsica de implementaci\u00f3n. M\u00e1s concretamente, aunque los SGBD relacionales deban proporcionar una implementaci\u00f3n f\u00edsicaque almacenar\u00e1 las tuplas de las relaciones en un orden concreto, esta ordena- ci\u00f3n no es visible si nos situamos en el nivel conceptual. Ejemplo de no-ordenaci\u00f3n de las tuplas En una base de datos relacional , por ejemplo, no tiene sentid o consultar la \"primera tupla\" de la relaci\u00f3n EMPLEADOS . 4) No-ordenaci\u00f3n de los atributos : el esquema de una relaci\u00f3n consta de un nombre de relaci\u00f3n R y un conjunto de atributos { A1, A2, ..., An}. As\u00ed pues, no hay un orden entre los atributos de un esquema de relaci\u00f3n, teniendo encuenta que estos atributo s forman un conjunto. Como en el caso anterior, el objetivo de esta caracter\u00edstica es representar los he- chos en un nivel abstracto, independie ntemente de su implementaci\u00f3n f\u00edsica. Ejemplo de no-ordenaci\u00f3n de los atributos El esquema de relaci\u00f3n EMPLEADOS( DNI, nombre, apellido, sueldo ) denota el mismo esquema de relaci\u00f3n que EMPLEADOS( nombre, apellido, DNI, sueldo ). El concepto de extensi\u00f3n de una relaci\u00f3n se ha explicado en el subapartado 2.2. de esta unidad did\u00e1ctica. El concepto de esquema de una relaci\u00f3n se ha explicado en el subapartado 2.2. de esta unidad did\u00e1ctica. FUOC 71Z799014MO 14 El modelo relacional y el \u00e1lgebra relacional 2.4. Clave candidata, clave primaria y clave alternativa de las relaciones Toda la informaci\u00f3n que contiene una base de datos debe poderse identificar de alguna forma. En el caso particular de las bases de datos que siguen el mo- delo relacional, para identi ficar los datos que la base de datos contiene, se pue- den utilizar las claves cand idatas de las relaciones. A continuaci\u00f3n definimos qu\u00e9 se entiende por clave candidata , clave primaria y clave alternativa de una re- laci\u00f3n. Para hacerlo, ser\u00e1 nece sario definir el concepto de superclave . Una superclave, por lo tanto, nos permit e identificar todas las tuplas que con- tiene la relaci\u00f3n. Algunas superclaves de la relaci\u00f3n EMPLEADOS En la relaci\u00f3n de esquema EMPLEADOS( DNI, NSS, nombre, apellido, tel\u00e9fono ), algunas de las superclaves de la relaci\u00f3n ser\u00edan los siguientes subconjuntos de atributos: { DNI, NSS, nombre, apellido, tel\u00e9fono }, {DNI, apellido }, {DNI} y {NSS}. Es decir, C cumple que la eliminac i\u00f3n de cualquiera de sus atributos da un conjunto de atributos que no es supercla ve de la relaci\u00f3n. Intuitivamente, una clave candidata permite identificar cual quier tupla de una relaci\u00f3n, de manera que no sobre ning\u00fan atributo para hacer la identificaci\u00f3n. Claves candidatas de EMPLEADOS En la relaci\u00f3n de esquema EMPLEADOS( DNI, NSS, nombre, apellido, tel\u00e9fono ), s\u00f3lo hay dos cla- ves candidatas: { DNI} y {NSS}. El dise\u00f1ador de la base de datos es qu ien elige la clave primaria de entre las claves candidatas.Una s uperclave de una relaci\u00f3n de esquema R( A1, A2, ..., An) es un subconjunto de los atributos del es quema tal que no puede haber dos tuplas en la extensi\u00f3n de la relaci\u00f3n que tengan la misma combinaci\u00f3n de valores para los atributos del subconjunto. Una clave candidata de una relaci\u00f3n es una superclave C de la rela- ci\u00f3n que cumple que ning\u00fan subconjunto propio de C es superclave. Habitualmente, una de las claves candidatas de una relaci\u00f3n se designa clave primaria de la relaci\u00f3n. La clave primaria es la clave candidata cu- yos valores se utilizar\u00e1n para identi ficar las tuplas de la relaci\u00f3n.Por ejemplo, ... ... si se almacena informaci\u00f3n sobre los empleados de una empresa, es preciso tener la posibilidad de distinguir qu\u00e9 datos corresponden a cada uno de los diferentes empleados. Observad que... ... toda relaci\u00f3n tiene, por lo menos, una superclave, quees la formada por todos los atributos de su esquema. Esto se debe a la propiedad que cumple toda relaci\u00f3n de no tener tuplas repetidas. En el ejemplo de EMPLEA- DOS( DNI, NSS, nombre , apellido , tel\u00e9fono , tel\u00e9fono }. Notad que, ... ... puesto que toda relaci\u00f3n tiene por lo menos una super-clave, podemos garantizarque toda relaci\u00f3n tiene como m\u00ednimo una clave candidata. Relaci\u00f3n con una clave candidata Si una relaci\u00f3n s\u00f3lo tiene una clave candidata, entonces esta clave candidata debe ser tambi\u00e9n su clave primaria. Ya que todas las relacionestienen como m\u00ednimo una clave candidata, podemos garanti-zar que, para toda relaci\u00f3n, ser\u00e1 posible designar una clave primaria. FUOC 71Z799014MO 15 El modelo relacional y el \u00e1lgebra relacional Utilizaremos la convenci\u00f3n de subrayar los atributos que forman parte de la clave primaria en el esquema de la relaci\u00f3n. As\u00ed pues, R( A1, A2, ..., Ai, ..., An) indica que los atributos A1, A2, ..., Ai forman la clave primaria de R. Elecci\u00f3n de la clave primaria de EMPLEADOS En la relaci\u00f3n de esquema EMPLEADOS (DNI, NSS, nombre, apellido, tel\u00e9fono ), donde hay dos claves candidatas, { DNI} y {NSS}, se puede elegir co mo clave primaria { DNI}. Lo indicaremos subrayando el atributo DNI en el esquema de la relaci\u00f3n EMPLEADOS( DNI, NSS, nombre, ape- llido, tel\u00e9fono ). En este caso, la clave { NSS} ser\u00e1 una clave alternativa de EMPLEADOS . Es posible que una clave candidata o una clave primaria conste de m\u00e1s de un atributo. Clave primaria de la relaci\u00f3n DESPACHOS En la relaci\u00f3n de esquema DESPACHOS( edificio , n\u00famero , superficie ), la clave primaria est\u00e1 for- mada por los atributos edificio y n\u00famero . En este caso, podr\u00e1 ocurrir que dos despachos dife- rentes est\u00e9n en el mismo edificio, o bien qu e tengan el mismo n\u00famero, pero nunca pasar\u00e1 que tengan la misma combinaci\u00f3n de valores para edificio y n\u00famero . 2.5. Claves for\u00e1neas de las relaciones Hasta ahora hemos estudiado las relacion es de forma individual, pero debe- mos tener en cuenta que una base de datos relacional normalmente contiene m\u00e1s de una relaci\u00f3n, para poder representar distintos tipos de hechos que su- ceden en el mundo real. Por ejemplo, podr\u00edamos tener una peque\u00f1a base de datos que contuviese dos relaciones: una denominada EMPLEADOS , que alma- cenar\u00eda datos de los empleados de una empresa, y otra con el nombre DESPA- CHOS , que almacenar\u00eda los datos de lo s despachos que tiene la empresa. Debemos considerar tambi\u00e9n que entre los distintos hechos que se dan en el mundo real pueden existir lazos o v\u00edncul os. Por ejemplo, los empleados que tra- bajan para una empresa pueden estar vinc ulados con los despachos de la empre- sa, porque a cada empleado se le asigna un despacho concreto para trabajar. En el modelo relacional, para reflejar es te tipo de v\u00ednculos, tenemos la posibi- lidad de expresar conexiones entre las distintas tuplas de las relaciones. Por ejemplo, en la base de datos anterior, que tiene las relaciones EMPLEADOS y DESPACHOS , puede ser necesario conectar tuplas de EMPLEADOS con tuplas de DESPACHOS para indicar qu\u00e9 despacho ti ene asignado ca da empleado. En ocasiones, incluso puede ser necesario reflejar lazos entre tuplas que pertene- cen a una misma relaci\u00f3n. Por ejemplo, en la misma base de datos anterior puedeLas claves candidatas no elegid as como primaria se denominan claves alternativas . FUOC 71Z799014MO 16 El modelo relacional y el \u00e1lgebra relacional ser necesario conectar de terminadas tuplas de EMPLEADOS con otras tuplas de EMPLEADOS para indicar, para cada empleado, qui\u00e9n act\u00faa como su jefe. El mecanismo que proporcion an las bases de datos relacionales para conectar tuplas son las claves for\u00e1neas de las relaciones. Las claves for\u00e1neas permiten es- tablecer conexiones entre las tuplas de las relaciones. Para hacer la conexi\u00f3n, una clave for\u00e1nea tiene el conjunto de atributos de una relaci\u00f3n que referencianla clave primaria de otra relaci\u00f3n (o incluso de la misma relaci\u00f3n). Claves for\u00e1neas de la relaci\u00f3n EMPLEADOS En la figura siguiente, la relaci\u00f3n EMPLEADOS( DNI, nombre, apellid o, tel\u00e9fono, DNIjefe los atributos edificiodesp y n\u00fame- rodesp que se refiere a la clave prim aria de la relaci\u00f3n DESPACHOS( edificio , n\u00famero , superficie ). Esta clave for\u00e1nea indica, para cada empleado, el despacho donde trabaj a. Adem\u00e1s, el atribu- to DNIjefe es otra clave for\u00e1nea que referencia la clave primaria de la misma relaci\u00f3n EMPLEA- DOS, e indica, para cada empl eado, quien es su jefe. Las claves for\u00e1neas tienen por objetivo establecer una conexi\u00f3n con la clave primaria que referencian. Por lo tanto, los valores de una cl ave for\u00e1nea deben estar presentes en la clave primaria co rrespondiente, o bien deben ser valores nulos. En caso contrario, la clave for\u00e1nea represen tar\u00eda una referencia o co- nexi\u00f3n incorrecta. Ejemplo En la relaci\u00f3n de esquema EMPLEADOS( DNI, nombre, apellido, DNIjef e, edificiodesp, n\u00famero- desp), la clave for\u00e1nea { edificiodesp, } la relaci\u00f3n DESPACHOS( edificio , n\u00famero , superficie ). De este modo, se cumple que todo s los valores que no son nulos de los atributos edificiodesp y n\u00famerodesp son valores que existen para los atributos edificio y n\u00famero de DESPACHOS , tal y como se puede ver a continuaci\u00f3n: R e l a c i \u00f3 n DESPACHOS : DESPACHOS edificio n\u00famero superficie Marina 120 10Marina 122 15Marina 230 20 Diagonal 120 10 FUOC 71Z799014MO 17 El modelo relacional y el \u00e1lgebra relacional R e l a c i \u00f3 n EMPLEADOS Supongamos que hubiese un empleado con lo s valores <55.555.555, Mar\u00eda, Casagran, NU- LO, Par\u00eds, 400>. Puesto que no hay ning\u00fan despacho con los valores Par\u00eds y 400 para edificio y n\u00famero , la tupla de este empleado hace una refere ncia incorrecta; es de cir, indica un despa- cho para el empleado que, de hecho, no existe. Es preciso se\u00f1alar que en la relaci\u00f3n EMPLEADOS hay otra clave for\u00e1nea, { DNIjefe }, que refe- rencia la misma relaci\u00f3n EMPLEADOS , y entonces se cumple que todos los valores que no son nulos del atributo DNIjefe son valores que existen para el atributo DNI de la misma rela- ci\u00f3n EMPLEADOS . A continuaci\u00f3n estableceremos de fo rma m\u00e1s precisa qu\u00e9 se entiende por clave for\u00e1nea . De la noci\u00f3n que hemos dado de clave for\u00e1nea se pueden extraer varias con- secuencias: 1)Si una clave for\u00e1nea CF referencia una clave primaria CP, el n\u00famero de atri- butos de CF y de CP debe coincidir. Ejemplo de coincidencia del n\u00famero de atributos de CF y CP En el ejemplo anterior, tanto la clave for\u00e1nea { edificiodesp, n\u00famerodesp } como la clave primaria que referencia { edificio, n\u00famero } tienen dos atributos. Si no sucediese as\u00ed, no ser\u00eda posible que los valores de CF existieran en CP. 2)Por el mismo motivo, se puede establ ecer una correspondencia (en concre- to, una biyecci\u00f3n) entre los atributos de la clave for\u00e1nea y los atributos de la clave primaria que referencia.EMPLEADOS DNI nombre apellido DNIjefe edificiodesp n\u00famerodesp 40.444.255 Juan Garc\u00eda NULO Marina 12033.567.711 40.444.255 Marina 12055.898.425 Carlos Buend\u00eda 40.444.255 Diagonal 12077.232.144 Elena Pla 40.444.255 NULO NULO Una clave for\u00e1nea de una relaci\u00f3n R es un subconjunto de atributos del esquema de la relaci\u00f3n, que denominamos CF y que cumple las si- guientes condiciones: 1)Existe una relaci\u00f3n S (S no debe ser necesariamente diferente de R) que tiene por clave primaria CP. 2)Se cumple que, para toda tupla t de la extensi\u00f3n de R, los valores para CF de t son valores nulos o bien valore s que coinciden con los valores para CP de alguna tupla s de S. Y entonces, se dice que la clave for\u00e1nea CF referencia la clave primaria CP de la relaci\u00f3n S, y tambi\u00e9n que la clave for\u00e1nea CF referencia la rela- ci\u00f3n S.Conviene subrayar que, ... ... tal y como ya hemos mencionado, el modelo relacional permite representar toda la informaci\u00f3n mediante valores expl\u00edcitos que contie-nen las relaciones, y no le hace falta nada m\u00e1s. De este modo, las conexiones entre tuplas de las relaciones se expresan con los valores expl\u00edcitos de las claves for\u00e1neas de las re-laciones, y no son necesarios conceptos adicionales (por ejemplo, apuntadoresentre tuplas), para establecer estas conexiones. Esta caracte-r\u00edstica da simplicidad y unifor-midad al modelo. FUOC 71Z799014MO 18 El modelo relacional y el \u00e1lgebra relacional Ejemplo de correspondencia entre los atributos de CF y los de CP En el ejemplo anterior, a edificiodesp le corresponde el atributo edificio , y a n\u00famerodesp le co- rresponde el atributo n\u00famero . 3)Tambi\u00e9n se deduce de la noci\u00f3n de clave for\u00e1nea que los dominios de sus atributos deben coincidir con los domini os de los atributos correspondientes a la clave primaria que referencia. Esta coincidencia de dominios hace que sea posible que los valores de la clave for\u00e1 nea coincidan con valores de la clave primaria referenciada. Ejemplo de coincidencia de los dominios En el ejemplo anterior, se debe cumplir que dominio( edificiodesp ) = dominio( edificio ) y tam- n\u00famerodesp ) = dominio( n\u00famero ). Observad que, de hecho, es ta condici\u00f3n se podr\u00eda rela jar, y se podr\u00eda permitir que los dominios no fuesen exactament e iguales, sino que s\u00f3lo fuesen, y de alguna forma que convendr\u00eda precisar, dominios \"compatibles\". Para simpli- ficarlo, nosotros supondremos que los do minios deben ser iguales en todos los casos en que, seg\u00fan Date (2001), se aceptar\u00edan dominios \"compatibles\". Ejemplo de atributo que forma parte de la clave primaria y de una clave for\u00e1nea Puede suceder que alg\u00fan atributo de una rela ci\u00f3n forme parte tanto de la clave primaria como de una clave for\u00e1nea de la relaci\u00f3n. Esto se da en las relaciones siguientes: EDIFI- CIOS( nombreedificio , n\u00famero , superficie ), donde { edificio } es una clave for\u00e1nea que referencia EDIFICIOS . En este ejemplo, el atributo edificio forma parte tanto de la clave primaria como de la clave for\u00e1nea de la relaci\u00f3n DESPACHOS . 2.6. Creaci\u00f3n de las relacion es de una base de datos Hemos visto que una base de datos relacional consta de varias relaciones. Cada relaci\u00f3n tiene varios atributos que to man valores de unos ciertos dominios; tambi\u00e9n tiene una clave primaria y pued e tener una o m\u00e1s claves for\u00e1neas. Los lenguajes de los SGBD relacionales deben proporcionar la forma de definir todos estos elementos para crear una base de datos. M\u00e1s adelante se ver\u00e1 con detalle la sintaxis y el significado de las sentencias de de- finici\u00f3n de la base de datos para el caso concreto del lenguaje SQL. Lectura recomendada Encontrar\u00e9is explicaciones detalladas sobre la coincidencia de dominios en la obra siguiente: C.J. Date (2001). Introducci\u00f3n a los sistemas de bases de datos (7\u00aa ed., cap. 19). Prentice Hall. El lenguaje SQL se explica en la unidad did\u00e1ctica \"El lenguaje SQL\" de este curso. FUOC 71Z799014MO 19 El modelo relacional y el \u00e1lgebra relacional 3. Operaciones del modelo relacional Las operaciones del modelo relacional deben permitir manipular datos alma- cenados en una base de datos relacional y, por lo tanto, es tructurados en for- ma de relaciones. La manipulaci\u00f3n de datos incluye b\u00e1sicamente dos aspectos: la actualizaci\u00f3n y la consulta. Ejemplo de actualizaci\u00f3n Si una base de datos contiene, por ejemplo, informaci\u00f3n de los empleados de una empresa, y la empresa contrata a un empleado, ser\u00e1 nece sario reflejar este cambio a\u00f1adiendo los datos del nuevo empleado a la base de datos. Existen tres operaciones b\u00e1 sicas de actualizaci\u00f3n: a) Inserci\u00f3n , que sirve para a\u00f1adir una o m\u00e1s tuplas a una relaci\u00f3n. b) Borrado , que sirve para eliminar una o m\u00e1s tuplas de una relaci\u00f3n. c) Modificaci\u00f3n , que sirve para alterar los va lores que tienen una o m\u00e1s tu- plas de una relaci\u00f3n para uno o m\u00e1s de sus atributos. Ejemplo de consulta Si una base de datos contiene, por ejemplo, informaci\u00f3n de los empleados de una empresa, puede interesar consultar el nombre y apellid o de todos los empleados que trabajan en un despacho situado en un edif icio que tiene por nombre Marina . La obtenci\u00f3n de los datos que responden a una consulta puede requerir el an\u00e1- lisis y la extracci\u00f3n de datos de una o m\u00e1s de las relaciones que mantiene la base de datos. Seg\u00fan la forma como se especifican las co nsultas, podemos clasificar los lengua- jes relacionales en dos tipos: 1) Lenguajes basados en el \u00e1lgebra relacional . El \u00e1lgebra relacional se inspi- ra en la teor\u00eda de conjuntos. Si querem os especificar una consulta, es necesarioLa actualizaci\u00f3n de los datos consiste en hacer que los cambios que se producen en la realidad queden reflejados en las relaciones de la base de datos. La consulta de los datos consiste en la obtenc i\u00f3n de datos deducibles a partir de las relaciones qu e contiene la base de datos.La sintaxis y el funcionamiento de las operaciones de actualizaci\u00f3n y consulta, en el caso concreto del lenguaje relacional SQL, se estudian con detalle en la unidad \"El lenguaje SQL\" de este curso. FUOC 71Z799014MO 20 El modelo relacional y el \u00e1lgebra relacional seguir uno o m\u00e1s pasos que sirven para ir construyendo, mediante operaciones del \u00e1lgebra relacional, una nueva relaci\u00f3n que contenga los datos que respon- den a la consulta a partir de las relaciones almacenadas. Los lenguajes basados en el \u00e1lgebra relacional son lenguajes procedimentales , ya que los pasos que forman la consulta desc riben un procedimiento. 2) Lenguajes basados en el c\u00e1lculo relacional . El c\u00e1lculo relacional tiene su fundamento te\u00f3rico en el c\u00e1lculo de pr edicados de la l\u00f3gica matem\u00e1tica. Pro- porciona una notaci\u00f3n que permite formular la defini ci\u00f3n de la relaci\u00f3n don- de est\u00e1n los datos que responden la co nsulta en t\u00e9rminos de las relaciones almacenadas. Esta definici\u00f3n no describe un procedimiento; por lo tanto, se dice que los lenguajes basados en el c\u00e1lculo relacional son lenguajes declara- tivos (no procedimentales). El lenguaje SQL , en las sentencias de consulta, combina construcciones del \u00e1lge- bra relacional y del c\u00e1lculo relacional con un predominio de las construcciones del c\u00e1lculo. Este predominio determin a que SQL sea un lenguaje declarativo. El estudio del \u00e1lgebra relacional presenta un inter\u00e9s espe cial, pues ayuda a en- tender qu\u00e9 servicios de consulta debe pr oporcionar un lenguaje relacional, faci- lita la comprensi\u00f3n de algunas de las construcciones del lenguaje SQL y tambi\u00e9n sirve de base para el tratamiento de la s consultas que efect\u00faan los SGBD inter- namente. Este \u00faltimo tema queda fuera del \u00e1mbito del presente curso, pero es necesario para estudios m\u00e1s avanzados sobre bases de datos. El \u00e1lgebra relacional se explica en el apartado 5 de estaunidad did\u00e1ctica. FUOC 71Z799014MO 21 El modelo relacional y el \u00e1lgebra relacional 4. Reglas de integridad Una base de datos contiene unos datos que, en cada momento, deben reflejar la realidad o, m\u00e1s concretamente, la si tuaci\u00f3n de una porci\u00f3n del mundo real. En el caso de las bases de datos relaci onales, esto significa que la extensi\u00f3n de las relaciones (es decir, las tuplas que contienen las relacion es) deben tener va- lores que reflejen la realidad correctamente. Suele ser bastante frecuente que determ inadas configuraciones de valores para las tuplas de las relaciones no tengan sentido, porq ue no representan ninguna situaci\u00f3n posible del mundo real. Un sueldo negativo En la relaci\u00f3n de esquema EMPLEADOS( DNI, nombre , apellido , sueldo ), una tupla que tiene un valor de -1.000 para el sueldo probablement e no tiene sentido, porque los sueldos no pue- den ser negativos. Como es evidente, para que los datos sean \u00edntegros, es preciso que cumplan varias condiciones. El hecho de que los sueldos no puedan ser ne gativos es una condici\u00f3n que se deber\u00eda cumplir en la relaci\u00f3n EMPLEADOS . En general, las condicione s que garantizan la integr idad de los datos pueden ser de dos tipos: 1)Las restricciones de integridad de usuario son condiciones espec\u00edficas de una base de datos concreta; es decir, son las que se deben cumplir en una basede datos particular con unos usuarios concretos, pero qu e no son necesaria- mente relevantes en otra base de datos. Restricci\u00f3n de integridad de usuario en EMPLEADOS \u00c9ste ser\u00eda el caso de la condici\u00f3n anterior, se g\u00fan la cual los sueldos no pod\u00edan ser negativos. Observad que esta condici\u00f3n era necesaria en la base de datos concreta de este ejemplo por- que aparec\u00eda el atributo sueldo , al que se quer\u00eda dar un significado; sin embargo, podr\u00eda no ser necesaria en otra base de datos diferente donde, por ejemplo, no hubiese sueldos. 2)Las reglas de integridad de modelo , en cambio, son co ndiciones m\u00e1s ge- nerales, propias de un modelo de dato s, y se deben cumplir en toda base de datos que siga dicho modelo. Ejemplo de regla de integridad del modelo de datos relacional En el caso del modelo de datos relacional, habr\u00e1 una regla de integridad para garantizar que los valores de una clave primaria de una relaci\u00f3n no se repitan en tuplas diferentesDenominamos integridad la propiedad de los datos de corresponder a representaciones plausibles del mundo real. FUOC 71Z799014MO 22 El modelo relacional y el \u00e1lgebra relacional de la relaci\u00f3n. Toda base de datos relacional debe cumplir esta regla que, por lo tanto, es una regla de integridad del modelo. Los SGBD deben proporcionar la forma de definir las restricciones de integri- dad de usuario de una base de datos; una vez definidas, deben velar por su cumplimiento. Las reglas de integridad del modelo, en cambio, no se deben definir para cada base de datos concreta, porque se consideran preestablecidas para todas las base de datos de un modelo. Un SGBD de un modelo determinado debe velar por el cumplimiento de las reglas de integr idad preestablecidas por su modelo. A continuaci\u00f3n estudiar emos con detalle las reglas de integridad del modelo relacional , reglas que todo SGBD relaci onal debe obligar a cumplir. 4.1. Regla de integridad de unicidad de la clave primaria La regla de integridad de unicidad est\u00e1 relacionada con la definici\u00f3n de clave primaria. Concretamente, establece que toda clave primaria que se elija para una relaci\u00f3n no debe tener valores repetidos. Ejemplo Tenemos la siguiente relaci\u00f3n: En esta relaci\u00f3n, dado que la clave primaria est\u00e1 formada por edificio y n\u00famero , no hay ning\u00fan despacho que repita tanto edificio como n\u00famero de otro despacho. Sin em bargo, s\u00ed se repiten valores de edificio (por ejemplo, Marina); y ta mbi\u00e9n se repiten valores de n\u00famero (120). A pe- sar de ello, el edificio y el n\u00famero no se repiten nunca al mismo tiempo. A continuaci\u00f3n explicamos esta regla de forma m\u00e1s precisa. Un SGBD relacional deber\u00e1 garantizar el cumplimiento de esta regla de inte- gridad en todas las insercio nes, as\u00ed como en todas la s modificaciones que afec- ten a atributos que pertenecen a la clave primaria de la relaci\u00f3n.DESPACHOS edificio n\u00famero superficie Marina 120 10Marina 122 15Marina 230 20 Diagonal 120 10 La regla de integridad de unicidad de la clave primaria establece que si el conjunto de atributos CP es la clave primaria de una relaci\u00f3n R, en- tonces la extensi\u00f3n de R no puede tener en ni ng\u00fan momento dos tuplas con la misma combinaci\u00f3n de va lores para los atributos de CP.La forma de definir estas restricciones con el lenguaje SQL se explica en la unidad\"El lenguaje SQL\" de este curso. Es preciso destacar que el mismo concepto de clave primaria implica esta condici\u00f3n. El concepto de clave primaria se ha explicado en el subapartado 2.4. de estaunidad did\u00e1ctica. FUOC 71Z799014MO 23 El modelo relacional y el \u00e1lgebra relacional Ejemplo Tenemos la siguiente relaci\u00f3n: En esta relaci\u00f3n no se deber\u00eda poder insertar la tupla <Diagonal, 120, 30>, ni modificar la tu- pla <Marina, 122, 15>, de modo que pasara a ser <Marina, 120, 15>. 4.2. Regla de integridad de entidad de la clave primaria La regla de integridad de entidad de la clave primaria dispone que los atributos de la clave primaria de una relaci \u00f3n no pueden te ner valores nulos. Ejemplo Tenemos la siguiente relaci\u00f3n: En esta relaci\u00f3n, puesto que la clave primaria est\u00e1 formada por edificio y n\u00famero , no hay nin- g\u00fan despacho que tenga un valor nulo para edificio , ni tampoco para n\u00famero . Esta regla es necesaria para que los valo res de las claves primarias puedan iden- tificar las tuplas individuales de las re laciones. Si las claves primarias tuviesen valores nulos, es posible que algunas tuplas no se pudieran distinguir. Ejemplo de clave primaria incorrecta con valores nulos En el ejemplo anterior, si un desp acho tuviese un valor nulo para edificio porque en un mo- mento dado el nombre de este edificio no se conoce, por ejemplo <NULO, 120, 30>, la clave primaria no nos permitir\u00eda distinguirlo de l despacho <Marina, 120, 10> ni del despacho <Diagonal, 120,10>. No podr\u00eda mos estar seguros de que el valor desconocido de edificio no es ni Marina ni Diagonal. A continuaci\u00f3n definimos esta regla de forma m\u00e1s precisa.DESPACHOS edificio n\u00famero superficie Marina 120 10Marina 122 15Marina 230 20 Diagonal 120 10 DESPACHOS edificio n\u00famero superficie Marina 120 10Marina 122 15Marina 230 20 Diagonal 120 10 La regla de integridad de en tidad de la clave primaria establece que si el conjunto de atributos CP es la clave primaria de una relaci\u00f3n R, la extensi\u00f3n de R no puede tener ninguna tupl a con alg\u00fan valor nulo para alguno de los atributos de CP. FUOC 71Z799014MO 24 El modelo relacional y el \u00e1lgebra relacional Un SGBD relacional tendr\u00e1 que garantizar el cumplimie nto de esta regla de in- tegridad en todas las inserciones y, ta mbi\u00e9n, en todas las modificaciones que afecten a atributos que pertenecen a la clave primaria de la relaci\u00f3n. Ejemplo En la relaci\u00f3n DESPACHOS anterior, no se deber\u00eda inserta r la tupla <Diagonal, NULO, 15>. Tampoco deber\u00eda ser posible modificar la tupla <Marina, 120, 10> de modo que pasara a ser <NULO, 120, 10>. 4.3. Regla de integridad referencial La regla de integridad referencial es t\u00e1 relacionada con el concepto de clave fo- r\u00e1nea . Concretamente, determina que todos los valores que toma una clave fo- r\u00e1nea deben ser valores nulos o valores que existen en la clave primaria que referencia. Ejemplo Si tenemos las siguientes relaciones: R e l a c i \u00f3 n DESPACHOS : R e l a c i \u00f3 n EMPLEADOS : donde edificiodesp y n\u00famerodesp de la relaci\u00f3n EMPLEADOS forman una clave for\u00e1nea que re- ferencia la relaci\u00f3n DESPACHOS . Debe ocurrir que los valores no nulos de edificiodesp y n\u00fa- merodesp de la relaci\u00f3n EMPLEADOS est\u00e9n en la relaci\u00f3n DESPACHOS como valores de edificio y n\u00famero . Por ejemplo, el empleado <40.444.255, Juan Garc\u00eda, Marina, 120> tiene el valor Marina para edificiodesp , y el valor 120 para n\u00famerodesp , de modo que en la relaci\u00f3n DESPA- CHOS hay un despacho con valor Marina para edificio y con valor 120 para n\u00famero . La necesidad de la regla de integridad relacional proviene del hecho de que las claves for\u00e1neas tienen por objetivo es tablecer una conexi\u00f3n con la clave pri- maria que referencian. Si un valor de una clave for\u00e1nea no estuviese presenteDESPACHOS edificio n\u00famero superficie Marina 120 10Marina 122 15Marina 230 20 Diagonal 120 10 EMPLEADOS DNI nombre apellido edificiodesp n\u00famerodesp 40.444.255 Juan Garc\u00eda Marina 12033.567.711 Marta Roca Marina 12055.898.425 Carlos Buend\u00eda Diagonal 12077.232.144 Elena Pla NULO NULOObservad que todo lo que impone la regla de integridad referencial viene implicado por la misma noci\u00f3n de clave for\u00e1nea que se ha explicado en el subapartado 2.5 de esta unidad. FUOC 71Z799014MO 25 El modelo relacional y el \u00e1lgebra relacional en la clave primaria corr espondiente, representar\u00eda una referencia o una co- nexi\u00f3n incorrecta. Referencia incorrecta Supongamos que en el ejemplo anterior hu biese un empleado con los valores <56.666.789, Pedro, L\u00f3pez, Valencia, 325>. Ya que no hay un despacho con los valores Valencia y 325 para edificio y n\u00famero , la tupla de este empleado hace una re ferencia incorrecta; es decir, indica un despacho para el empleado que, de hecho, no existe. A continuaci\u00f3n explicamos la regla de modo m\u00e1s preciso. Un SGBD relacional tendr\u00e1 que hacer cumplir esta re gla de integridad. Deber\u00e1 efectuar comprobaciones cuando se produzcan las siguientes operaciones: a)Inserciones en una relaci\u00f3n que tenga una clave for\u00e1nea. b)Modificaciones que afecten a atributos que pertenecen a la clave for\u00e1nea de una relaci\u00f3n. c)Borrados en relaciones refere nciadas por otras relaciones. d)Modificaciones que afecten a atributo s que pertenecen a la clave primaria de una relaci\u00f3n referenc iada por otra relaci\u00f3n. Ejemplo Retomamos el ejemplo anterior, donde edificiodesp y n\u00famerodesp de la relaci\u00f3n EMPLEADOS forman una clave for\u00e1nea que referencia la relaci\u00f3n DESPACHOS : R e l a c i \u00f3 n DESPACHOS :La regla de integridad referencial establece que si el conjunto de atribu- tos CF es una clave for\u00e1nea de una relaci\u00f3n R que referencia una relaci\u00f3n S (no necesariamente diferente de R), que tiene por clave primaria CP, en- tonces, para toda tupla t de la extensi\u00f3n de R, los valores para el conjunto de atributos CF de t son valores nulos, o bien valores que coinciden con los valores para CP de alguna tupla s de S. En el caso de que una tupla t de la extensi\u00f3n de R tenga valores para CF que coincidan con los valores para CP de una tupla s de S, decimos que t es una tupla que referencia s y que s es una tupla que tiene una clave primaria referenciada por t. DESPACHOS edificio n\u00famero superficie Marina 120 10Marina 122 15Marina 230 20 Diagonal 120 10 FUOC 71Z799014MO 26 El modelo relacional y el \u00e1lgebra relacional R e l a c i \u00f3 n EMPLEADOS : Las siguientes operaciones pr ovocar\u00edan el incumplimiento de la regla de integridad referencial: Inserci\u00f3n de <12.764.411, Jorge, Puig, Diagonal, 220> en EMPLEADOS . Modificaci\u00f3n de <40.444.255, Juan, Garc\u00eda, Marina, 120> de EMPLEADOS por <40.444.255, Juan, Garc\u00eda, Marina, 400>. Borrado de <Marina, 120, 10> de DESPACHOS . Modificaci\u00f3n de <Diagonal, 120, 10> de DESPACHOS por <Par\u00eds, 120, 10>. Un SGBD relacional debe procurar que se cumplan las reglas de integridad del modelo. Una forma habitual de mantener estas reglas consiste en rechazartoda operaci\u00f3n de actualizaci\u00f3n que deje la base de datos en un estado en el que alguna regla no se cumpla. En algu nos casos, sin embargo, el SGBD tiene la posibilidad de aceptar la operaci\u00f3n y efectuar a cciones adicionales compen- satorias, de modo que el estado que se obtenga satisfaga las reglas de integri-dad, a pesar de haber ejecutado la operaci\u00f3n. Esta \u00faltima pol\u00edtica se puede aplicar en las siguientes operaciones de actuali- zaci\u00f3n que violar\u00edan la regla de integridad: a)Borrado de una tupla que tiene un a clave primaria referenciada. b)Modificaci\u00f3n de los valores de los atri butos de la clave primaria de una tu- pla que tiene una clave primaria referenciada. En los casos anteriores, algunas de las po l\u00edticas que se podr\u00e1n aplicar ser\u00e1n las siguientes: restricci\u00f3n , actualizaci\u00f3n en cascada y anulaci\u00f3n . A continua- ci\u00f3n explicamos el significado de las tres posibilidad es mencionadas. 4.3.1. Restricci\u00f3n La pol\u00edtica de restri cci\u00f3n consiste en no aceptar la operaci\u00f3n de actualizaci\u00f3n.EMPLEADOS DNI nombre apellido edificiodesp n\u00famerodesp 40.444.255 Juan Garc\u00eda Marina 12033.567.711 Marta Roca Marina 12055.898.425 Carlos Buend\u00eda Diagonal 12077.232.144 Elena Pla NULO NULO M\u00e1s concretamente, la restricci\u00f3n en caso de borrado , consiste en no permitir borrar una tupla si tiene una clave primaria referenciada por al- guna clave for\u00e1nea. FUOC 71Z799014MO 27 El modelo relacional y el \u00e1lgebra relacional Ejemplo de aplicaci\u00f3n de la restricci\u00f3n Supongamos que tenemos las siguientes relaciones: R e l a c i \u00f3 n CLIENTES : R e l a c i \u00f3 n PEDIDOS_PENDIENTES * {numcliente } referencia CLIENTES . a)Si aplicamos la restricci\u00f3n en caso de borrado y, por ejemplo, querem os borrar al cliente n\u00famero 10, no podremos hacerlo porque tiene pedidos pendientes que lo referencian. b)Si aplicamos la restricci\u00f3n en caso de modi ficaci\u00f3n y queremos modificar el n\u00famero del cliente 15, no ser\u00e1 posible hacerlo porque ta mbi\u00e9n tiene pedidos pendientes que lo referen- cian. 4.3.2. Actualizaci\u00f3n en cascada La pol\u00edtica de actua lizaci\u00f3n en cascada co nsiste en permitir la operaci\u00f3n de ac- tualizaci\u00f3n de la tupla, y en efectuar operaciones compensatorias que propa- guen en cascada la actualizaci\u00f3n a las tu plas que la referenc iaban; se act\u00faa de este modo para mantener la integridad referencial.De forma similar, la restricci\u00f3n en caso de modificaci\u00f3n consiste en no permitir modificar ning\u00fan atributo de la clave primaria de una tuplasi tiene una clave primaria refere nciada por alguna clave for\u00e1nea. CLIENTES - 101.235 - 101.236 - 15 M\u00e1s concretamente, la actualizaci\u00f3n en cascada en caso de borrado consiste en permitir el borrado de una tupla t que tiene una clave pri- maria referenciada, y borrar tambi\u00e9 n todas las tuplas que referencian t. De forma similar, la actualizaci\u00f3n en cascada en caso de modifica- ci\u00f3n consiste en permitir la modificaci \u00f3n de atributos de la clave prima- ria de una tupla t que tiene una clave primaria referenciada, y modificar del mismo modo todas las tuplas que referencian t. FUOC 71Z799014MO 28 El modelo relacional y el \u00e1lgebra relacional Ejemplo de aplicaci\u00f3n de la actualizaci\u00f3n en cascada Supongamos que tenemos las siguientes relaciones: R e l a c i \u00f3 n EDIFICIOS : R e l a c i \u00f3 n DESPACHOS : * {edificio } referencia EDIFICIOS . a)Si aplicamos la actualizaci\u00f3n en cascada en caso de borrado y, por ejemplo, queremos bo- rrar el edificio Diagonal, se borrar\u00e1 tambi\u00e9n el despacho Diagonal 120 que hay en el edificio, y nos quedar\u00e1: R e l a c i \u00f3 n EDIFICIOS : R e l a c i \u00f3 n DESPACHOS : * {edificio } referencia EDIFICIOS . b)Si aplicamos la actualizaci\u00f3n en cascada en caso de modificaci\u00f3n, y queremos modificar el nombre del edificio Marina por Mar, tamb i\u00e9n se cambiar\u00e1 Marina por Mar en los despa- chos Marina 120, Marina 122 y Marina 230, y nos quedar\u00e1: R e l a c i \u00f3 n EDIFICIOS : R e l a c i \u00f3 n DESPACHOS : * {edificio } referencia EDIFICIOS .EDIFICIOS nombreedificio ... Marina - Diagonal - DESPACHOS edificio* n\u00famero superficie Marina 120 10 Marina 122 15Marina 230 20 Diagonal 120 10 EDIFICIOS nombreedificio ... Marina - DESPACHOS edificio* n\u00famero superficie Marina 120 10Marina 122 15 Marina 230 20 EDIFICIOS nombreedificio ... Mar - DESPACHOS edificio* n\u00famero superficie Mar 120 10 Mar 122 15 Mar 230 20 FUOC 71Z799014MO 29 El modelo relacional y el \u00e1lgebra relacional 4.3.3. Anulaci\u00f3n Esta pol\u00edtica consiste en pe rmitir la operaci\u00f3n de actu alizaci\u00f3n de la tupla y en efectuar operaciones compensatorias qu e pongan valores nu los a los atributos de la clave for\u00e1nea de las tuplas que la referencian; esta acci\u00f3n se lleva a cabo para mantener la in tegridad referencial. Puesto que generalmente los SGBD rela cionales permiten establecer que un determinado atributo de una relaci\u00f3n no admite valores nulos, s\u00f3lo se puedeaplicar la pol\u00edtica de anulaci\u00f3n si los atributos de la clave for\u00e1nea s\u00ed los ad- miten. Ejemplo de aplicaci\u00f3n de la anulaci\u00f3n El mejor modo de entender en qu\u00e9 consiste la anulaci\u00f3n es mediante un ejemplo. Tenemos las siguientes relaciones: R e l a c i \u00f3 n VENDEDORES : R e l a c i \u00f3 n CLIENTES : * {vendedorasig } referencia VENDEDORES .M\u00e1s concretamente, la anulaci\u00f3n en caso de borrado consiste en per- mitir el borrado de una tupla t que tiene una clave referenciada y, ade- m\u00e1s, modificar todas las tuplas que referencian t, de modo que los atributos de la clave for\u00e1nea co rrespondiente tomen valores nulos. De forma similar, la anulaci\u00f3n en cas o de modificaci\u00f3n consiste en permitir la modificaci\u00f3n de atributo s de la clave primaria de una tupla t que tiene una clave referenciada y, adem\u00e1s, modificar todas las tuplas que referencian t, de modo que los atributos de la clave for\u00e1nea corres- pondiente tomen numcliente ... vendedorasig* 23 - 135 - 138 - 242 - 250 - 3 FUOC 71Z799014MO 30 El modelo relacional y el \u00e1lgebra relacional a)Si aplicamos la anulaci\u00f3n en caso de borrado y, por ejemplo, querem os borrar al vendedor n\u00famero 1, se modificar\u00e1n todos los clientes que lo ten\u00edan asig nado, y pasar\u00e1n a tener un va- lor nulo en vendedorasig . Nos quedar\u00e1: R e l a c i \u00f3 n VENDEDORES : R e l a c i \u00f3 n CLIENTES : * {vendedorasig } referencia VENDEDORES . b)Si aplicamos la anulaci\u00f3n en caso de modi ficaci\u00f3n, y ahora queremos cambiar el n\u00famero del vendedor 2 por 5, se modifi car\u00e1n todos los clientes que lo ten\u00edan asignado y pasar\u00e1n a tener un valor nulo en vendedorasig . Nos quedar\u00e1: R e l a c i \u00f3 n VENDEDORES : R e l a c i \u00f3 n CLIENTES : * {vendedorasig } referencia VENDEDORES . 4.3.4. Selecci\u00f3n de la pol\u00edtica de mantenimiento de la integridad referencial Hemos visto que en caso de borrado o mo dificaci\u00f3n de una clave primaria re- ferenciada por alguna clav e for\u00e1nea hay varias pol\u00edt icas CLIENTES numcliente ... vendedorasig* 23 - NULO 35 - NULO 38 - 242 - 2 50 - 3 VENDEDORES numvendedor ... 5-3- CLIENTES numcliente ... vendedorasig* 23 - NULO35 - NULO 38 - NULO 42 - NULO50 - 3 La forma de definir estas pol\u00edticas de mantenimiento de la integridad con el lenguaje SQL se explica en la unidad\"El lenguaje SQL\" de este curso. FUOC 71Z799014MO 31 El modelo relacional y el \u00e1lgebra relacional El dise\u00f1ador puede elegir para cada clave for\u00e1nea qu\u00e9 pol\u00edtica se aplicar\u00e1 en caso de borrado de la clave primaria re ferenciada, y cu\u00e1l en caso de modifica- ci\u00f3n de \u00e9sta. El dise\u00f1ador deber\u00e1 tener en cuenta el significado de cada clave for\u00e1nea concreta para pode r elegir adecuadamente. 4.4. Regla de integridad de dominio La regla de integridad de dominio est\u00e1 relacionada, como su nombre indica, con la noci\u00f3n de dominio . Esta regla establece dos condiciones. Esta condici\u00f3n implica que todos los valores no nulos que contiene la base de datos para un determinado atributo deben ser del dominio declarado para di- cho atributo. Ejemplo Si en la relaci\u00f3n EMPLEADOS( DNI, nombre, apellido, edademp ) hemos declarado que domi- nio(DNI) es el dominio predefinido de los enteros, entonces no podremos insertar, por ejem- plo, ning\u00fan empleado que tenga por DNI el valor \"Luis\", que no es un entero. Recordemos que los dominios pueden ser de dos tipos: predefinidos o defini- dos por el usuario. Observad que los do minios definidos por el usuario resul- tan muy \u00fatiles, porque no s permiten determinar de forma m\u00e1s espec\u00edfica cu\u00e1les ser\u00e1n los valores admitidos por los atributos. Ejemplo Supongamos ahora que en la relaci\u00f3n EMPLEADOS( DNI, nombre, apellido, edademp ) hemos declarado que dominio( edademp ) es el dominio definido por el usuario edad. Supongamos tambi\u00e9n que el dominio edad se ha definido como el conjunto de los enteros que est\u00e1n entre 16 y 65. En este caso, por ejemplo, no ser\u00e1 posible insertar un empleado con un valor de 90para edademp . La segunda condici\u00f3n de la regla de integridad de dominio es m\u00e1s compleja, especialmente en el caso de dominios definidos por el usua rio; los SGBD ac- tuales no la soportan para estos \u00faltimos dominios. Por estos motivos s\u00f3lo la presentaremos superficialmente. La primera condici\u00f3n consiste en que un valor no nulo de un atributo Ai debe pertenecer al dominio del atributo Ai; es decir, debe pertenecer a dominio( Ai). Esta segunda condici\u00f3n sirve para establecer que los operadores que pueden aplicarse sobre los valores de penden de los dominios de estos valores; es decir, un operador dete rminado s\u00f3lo se puede aplicar sobre valores que tengan dominios que le sean adecuados.Aplicaci\u00f3n de pol\u00edticas diferentes Puede ocurrir que, para una determinada clave for\u00e1nea, la pol\u00edtica adecuada en casode borrado sea diferente de la adecuada en caso de modifica-ci\u00f3n. Por ejemplo, puede ser necesario aplicar la restricci\u00f3n en caso de borrado y la actua-lizaci\u00f3n en cascada en caso de modificaci\u00f3n. Recordad que los conceptos de dominio predefinido y dominio definido por el usuario se han explicado en el subapartado 2.2 de esta unidad did\u00e1ctica. Lectura complementaria Para estudiar con m\u00e1s detalle la segunda condici\u00f3n de la regla de integridad de dominio, pod\u00e9is consultar la siguiente obra: C.J. Date (2001). Introducci\u00f3n a los sistemas de bases de datos (7\u00aa ed., cap. 19). Prentice Hall. FUOC 71Z799014MO 32 El modelo relacional y el \u00e1lgebra relacional Ejemplo Analizaremos esta segunda condici\u00f3n de la re gla de integridad de dominio con un ejemplo concreto. Si en la relaci\u00f3n EMPLEADOS( DNI, nombre, apellido, edademp ) se ha declarado que dominio( DNI) es el dominio predefinido de los enteros, entonces no se permitir\u00e1 consultar todos aquellos empleados cuyo DNI sea igual a 'Elena' ( DNI = 'Elena'). El motivo es que no tiene sentido que el operador de comparaci\u00f3n = se aplique entre un DNI que tiene por domi- nio los enteros, y el valor 'Elena', que es una serie de caracteres. De este modo, el hecho de que los oper adores que se pueden aplicar sobre los valores dependan del dominio de estos valores permite detectar errores que se podr\u00edan cometer cuando se consulta o se actualiza la base de datos. Los domi-nios definidos por el usuario son muy \u00fatiles, porque nos permitir\u00e1n determi- nar de forma m\u00e1s espec\u00edfica cu\u00e1les ser\u00e1 n los operadores que se podr\u00e1n aplicar sobre los valores. Ejemplo Veamos otro ejemplo con dominios definidos po r el usuario. Supongamos que en la conoci- da relaci\u00f3n EMPLEADOS( DNI, nombre, apellido, edademp ) se ha declarado que dominio( DNI) es el dominio definido por el usuario n\u00famerosDNI y que dominio( edademp ) es el dominio de- finido por el usuario edad. Supongamos que n\u00famerosDNI corresponde a los enteros positivos y que edad corresponde a los enteros que est\u00e1n entre 16 y 65. En este caso, ser\u00e1 incorrecto, por ejemplo, consultar los empl eados que tienen el valor de DNI igual al valor de edademp . El motivo es que, aunque tanto los valores de DNI como los de edademp sean enteros, sus do- minios son diferentes; por ello, seg\u00fan el significado que el usuario les da, no tiene sentido compararlos. Sin embargo, los actuales SGBD relaci onales no dan apoyo a la segunda con- dici\u00f3n de la regla de integridad de dominio para dominios definidos por elusuario. Si se quisiera hacer, ser\u00eda necesario que el dise\u00f1ador tuviese alguna forma de especificar, para cada operad or que se desease ut ilizar, para qu\u00e9 com- binaciones de dominios definidos por el usuario tiene sentido que se aplique. El lenguaje est\u00e1ndar SQL no incl uye actualmente esta posibilidad. FUOC 71Z799014MO 33 El modelo relacional y el \u00e1lgebra relacional 5. El \u00e1lgebra relacional Como ya hemos comentado en el apartado dedicado a las operaciones del mo- delo relacional, el \u00e1lgebra relacional se inspira en la teor\u00eda de conjuntos para especificar consultas en una base de datos relacional. Para especificar una consulta en \u00e1lgebra relacional, es preciso definir uno o m\u00e1s pasos que sirven para ir construyendo, mediante operaciones de \u00e1lgebra relacional, una nueva relaci\u00f3n que contenga los datos que responden a la con- sulta a partir de las relaci ones almacenadas. Los lenguajes basados en el \u00e1lge- bra relacional son procedimentales, dado que los pasos que forman la consultadescriben un procedimiento. La visi\u00f3n que presentaremos es la de un le nguaje te\u00f3rico y, por lo tanto, incluire- mos s\u00f3lo sus operaciones fu ndamentales, y no las construcciones que se podr\u00edan a\u00f1adir a un lenguaje comercial para fac ilitar cuestiones como por ejemplo el or- den de presentaci\u00f3n del resultado, el c\u00e1lculo de datos agregados, etc. Las operaciones del \u00e1lgebra relacional han sido clasificadas seg\u00fan distintos cri- terios; de todos ellos indicamos los tres siguientes: 1)Seg\u00fan se pueden expresar o no en t\u00e9rminos de otras operaciones. a) Operaciones primitivas: son aquellas operaciones a partir de las cuales po- demos definir el resto. Esta s operaciones son la uni\u00f3n, la diferencia, el produc- to cartesiano, la sele cci\u00f3n y la proyecci\u00f3n. b) Operaciones no primitivas: el resto de las operaciones del \u00e1lgebra relacio- nal que no son estric tamente necesarias, porque se pueden expresar en t\u00e9rmi- nos de las primitivas; sin embargo, la s operaciones no primitivas permiten formular algunas consultas de forma m\u00e1 s c\u00f3moda. Existen distintas versiones del \u00e1lgebra relacional, seg\u00fan las operaciones no primitivas que se incluyen. No- sotros estudiaremos las operaciones no pr imitivas que se utilizan con mayor fre- cuencia: la intersecci\u00f3n y la combinaci\u00f3n. 2)Seg\u00fan el n\u00famero de relaciones que tienen como operandos: a) Operaciones binarias: son las que tienen dos re laciones como operandos. Son binarias todas las operaciones, ex cepto la selecci\u00f3n y la proyecci\u00f3n.Una caracter\u00edstica destacable de todas las operaciones del \u00e1lgebra rela- cional es que tanto los operandos como el resultado son relaciones. Estapropiedad se denomina cierre relacional .Consultad el apartado 3 de esta unidad did\u00e1ctica. Implicaciones del cierre relacional El hecho de que el resultado de una operaci\u00f3n del \u00e1lgebra relacional sea una nuevarelaci\u00f3n tiene implicaciones importantes: 1.El resultado de una opera- ci\u00f3n puede actuar comooperando de otra operaci\u00f3n. 2.El resultado de una operaci\u00f3n cumplir\u00e1 todas las caracter\u00edsticas que ya conocemos de las relaciones: no-ordenaci\u00f3n de las tuplas, ausencia de tuplas repetidas, etc. FUOC 71Z799014MO 34 El modelo relacional y el \u00e1lgebra relacional b) Operaciones unarias: son las que tienen una sola relaci\u00f3n como operan- do. La selecci\u00f3n y la proyecci\u00f3n son unarias. 3)Seg\u00fan se parecen o no a las operac iones de la teor \u00eda de conjuntos: a) Operaciones conjuntistas: son las que se parecen a las de la teor\u00eda de conjuntos. Se trata de la uni\u00f3n, la intersecci\u00f3n, la diferencia y el productocartesiano. b) Operaciones espec\u00edficamente relacionales: son el resto de las operaciones; es decir, la selecci\u00f3n, la proyecci\u00f3n y la combinaci\u00f3n. Como ya hemos comentado anteriormente, las operaciones del \u00e1lgebra relacional obtienen como resultado un a nueva relaci\u00f3n. Es decir que si hacemos una opera- ci\u00f3n del \u00e1lgebra como por ejemplo EMPLEADOS_ADM EMPLEADOS_PROD para obtener la uni\u00f3n de las relaciones EMPLEADOS_ADM y EMPLEADOS_PROD , el resultado de la operaci\u00f3n es una nueva relaci\u00f3n que tiene la uni\u00f3n de las tuplas de las relaciones de partida. Esta nueva relaci\u00f3n debe tener un nomb re. En principio, consideramos que su nombre es la misma expres i\u00f3n del \u00e1lgebra relacional que la obtiene; es decir, la misma expresi\u00f3n EMPLEADOS_ADM EMPLEADOS_PROD . Puesto que este nombre es largo, en ocasiones puede ser interesante camb iarlo por uno m\u00e1s simple. Esto nos facilitar\u00e1 las referencia s a la nueva relaci\u00f3n, y ser\u00e1 especial- mente \u00fatil en los casos en los que quer amos utilizarla como operando de otra operaci\u00f3n. Usaremos la operaci\u00f3n auxiliar redenominar con este objetivo. En el ejemplo, para dar el nombre EMPLEADOS a la relaci\u00f3n resultante de la operaci\u00f3n EMPLEADOS_ADM EMPLEADOS_PROD , har\u00edamos: EMPLEADOS := EMPLEADOS_ADM EMPLEADOS_PROD. Cada operaci\u00f3n del \u00e1lgebra relacional da unos nombres por defecto a los atri- butos del esquema de la re laci\u00f3n resultante, tal y como veremos m\u00e1s adelante. En algunos casos, puede ser necesario cambiar estos nombres por defecto por otros nombres. Por este motivo, tambi\u00e9n permitiremos cambiar el nombre de la relaci\u00f3n y de sus atribu tos mediante la operaci\u00f3n redenominar .La operaci\u00f3n redenominar , que denotaremos con el s\u00edmbolo : =, permi- te asignar un nombre R a la relaci\u00f3n que resu lta de una operaci\u00f3n del \u00e1lgebra relacional; lo hace de la forma siguiente: R := E, siendo E la expresi\u00f3n de una operac i\u00f3n del \u00e1lgebra relacional.Las operaciones del \u00e1lgebra relacional clasificadas seg\u00fan sean conjuntistas o espec\u00edficamente relacionales se estudian en los subapartados 5.1 y 5.2 de esta unidad. FUOC 71Z799014MO 35 El modelo relacional y el \u00e1lgebra relacional A continuaci\u00f3n presentaremos un ejempl o que utilizaremos para ilustrar las operaciones del \u00e1lgebra relacional. De spu\u00e9s veremos con detalle las opera- ciones. Supongamos que tenemos una base de datos relacional con las cuatro rela- ciones siguientes: 1)La relaci\u00f3n EDIFICIOS_EMP , que contiene datos de di stintos edificios de los que una empresa dispone para desarrollar sus actividades. 2)La relaci\u00f3n DESPACHOS , que contiene datos de cada uno de los despachos que hay en los edificios anteriores. 3)La relaci\u00f3n EMPLEADOS_ADM , que contiene los datos de los empleados de la empresa que llevan a cabo tareas administrativas. 4)La relaci\u00f3n EMPLEADOS_PROD , que almacena los da tos de los empleados de la empresa que se ocupan de tareas de producci\u00f3n. A continuaci\u00f3n describimos los esquemas de las relaciones anteriores y sus ex- tensiones en un mo mento determinado: Esquema y extensi\u00f3n de EDIFICIOS_EMP : Esquema y extensi\u00f3n de DESPACHOS :Utilizaremos tambi\u00e9n la operaci\u00f3n redenominar para cambiar el esquema de una relaci\u00f3n. Si una re laci\u00f3n tiene el esquema S( B1, B2, ..., Bn) y que- remos cambiarlo por R( A1, A2, ..., An), lo haremos de la siguiente forma: R(A1, EDIFICIOS_EMP edificio supmediadesp Marina 15 Diagonal 10 DESPACHOS edificio n\u00famero superficie Marina 120 10Marina 230 20 Diagonal 120 10 Diagonal 440 10 FUOC 71Z799014MO 36 El modelo relacional y el \u00e1lgebra relacional Esquema y extensi\u00f3n de EMPLEADOS_ADM : Esquema y extensi\u00f3n de EMPLEADOS_PROD : Se considera que los valores nulos de los atributos edificiodesp y n\u00famerodesp de las relaciones EMPLEADOS_PROD y EMPLEADOS_ADM indican que el emplea- do correspondiente no tiene despacho. 5.1. Operaciones conjuntistas Las operaciones conjuntistas del \u00e1lgebra relacional son la uni\u00f3n , la intersecci\u00f3n , la diferencia y el producto cartesiano . 5.1.1. Uni\u00f3n La uni\u00f3n de las relaciones EMPLEADOS_ADM y EMPLEADOS_PROD proporciona una nueva relaci\u00f3n que contiene tanto a los empleados de administraci\u00f3n como los empleados de pro- ducci\u00f3n; se indicar\u00eda as\u00ed: EMPLEADOS_ADM EMPLEADOS_PROD . S\u00f3lo tiene sentido aplicar la uni\u00f3n a re laciones que tengan tuplas similares. Por ejemplo, se puede hacer la uni\u00f3n de la s relaciones EMPLEADO S_ADM y EMPLEADOS_PROD porque sus tuplas se parecen. En cambio, no se podr\u00e1 hacer la uni\u00f3n de las relaciones EMPLEADOS_ADM y DESPACHOS porque, como hab\u00e9is podido observar en las tablas, las tuplas respectivas son de tipo diferente.EMPLEADOS_ADM DNI nombre apellido edificiodesp n\u00famerodesp 40.444.255 Juan Garc\u00eda Marina nombreemp apellidoemp edificiodesp 33.567.711 Marta Roca Carlos Buend\u00eda Diagonal 12077.232.144 Elena Pla Marina 23021.335.245 Jorge Soler NULO NULO88.999.210 Pedro Gonz\u00e1lez NULO NULO La uni\u00f3n es una operaci\u00f3n que, a pa rtir de dos relaciones, obtiene una nueva relaci\u00f3n formada por todas las tuplas que est\u00e1n en alguna de las relaciones de partida. La uni\u00f3n es una operaci\u00f3n binaria, y la uni\u00f3n de dos relaciones T y S se indica T S. FUOC 71Z799014MO 37 El modelo relacional y el \u00e1lgebra relacional M\u00e1s concretamente, para poder aplicar la uni\u00f3n a dos relaciones, es preciso que las dos relaciones sean compat ibles. Decimos que dos relaciones T y S son relaciones compatibles si: Tienen el mismo grado. Se puede establecer una biye cci\u00f3n entre los atributos de T y los atributos de S que hace corresponder a cada atributo A i de T un atributo Aj de S, de modo que se cumple que dominio( Ai) = dominio( Aj). Ejemplo de relaciones compatibles Las relaciones EMPLEADOS_ADM y EMPLEADOS_PROD tienen grado 5. Podemos establecer la siguiente biyecci\u00f3n entre sus atributos: A DNI de EMPLEADOS_ADM le corresponde DNIemp de EMPLEADOS_PROD . A nombre de EMPLEADOS_ADM le corresponde nombreemp de EMPLEADOS_PROD . A apellido de EMPLEADOS_PROD . Adem\u00e1s, supondremos que los dominios de sus atributos se han declarado de forma que se cumple que el dominio de cada atributo de EMPLEADOS_ADM sea el mismo que el dominio de su atributo correspondiente en EMPLEADOS_PROD . Por todos estos factores , podemos llegar a la conclusi\u00f3n de que EMPLEADOS_ADM y EMPLEADOS_PROD son relaciones compatibles. A continuaci\u00f3n, pasaremos a definir los at ributos y la extens i\u00f3n de la relaci\u00f3n resultante de una uni\u00f3n. Ejemplo de uni\u00f3n Si queremos obtener una relaci\u00f3n R que tenga a todos los empleados de la empresa del ejemplo anterior, lle varemos a cabo la uni\u00f3 n de las relaciones EMPLEADOS_ADM y EMPLEADOS_PROD de la forma siguiente: R := EMPLEADOS_ADM EMPLEADOS_PROD. Entonces la relaci\u00f3n R resultante ser\u00e1 la reflejada en la tabla siguiente:Los atributos del esquema de la relaci\u00f3n resultante de T S coinci- den con los atributos del esquema de la relaci\u00f3n T. La extensi\u00f3n de la rel aci\u00f3n resultante de T S es el conjunto de tu- plas que pertenecen a la extensi\u00f3n de T, a la extensi\u00f3n de S o a la exten- si\u00f3n de ambas relaciones. R DNI nombre apellido edificiodesp n\u00famerodesp 40.444.255 Juan Garc\u00eda Marina 12033.567.711 Marta Roca Marina 120 55.898.425 Carlos Buend\u00eda Diagonal 120 No-repetici\u00f3n de tuplas Notad que en caso de que una misma tupla est\u00e9 en las dos relaciones que se unen, el resultado de la uni\u00f3n no la tendr\u00e1 repetida. El resultado de la uni\u00f3n es una nueva rela-ci\u00f3n por lo que no puede tener repeticiones de tuplas. FUOC 71Z799014MO 38 El modelo relacional y el \u00e1lgebra relacional El hecho de que los atributos de la rela ci\u00f3n resultante coincidan con los atri- butos de la relaci\u00f3n que figura en prim er lugar en la uni\u00f3n es una convenci\u00f3n; te\u00f3ricamente, tambi\u00e9n habr\u00eda sido posible convenir que coincidiesen con los de la relaci\u00f3n que figu ra en segundo lugar. 5.1.2. Intersecci\u00f3n La intersecci\u00f3n de las relaciones EMPLEADOS_ADM y EMPLEADOS_PROD obtiene una nueva relaci\u00f3n que incluye a los empleados que son al mismo tiempo de administraci\u00f3n y de pro- ducci\u00f3n: se indicar\u00eda como EMPLEADOS_ADM EMPLEADOS_PROD . La intersecci\u00f3n, como la uni\u00f3n, s\u00f3lo se puede aplicar a relaciones que tengan tuplas similares. Para pode r hacer la intersecci\u00f3n de dos relaciones, es preciso, pues, que las relacion es sean compatibles. A continuaci\u00f3n definiremos los atributos y la extensi\u00f3n de la relaci\u00f3n resul- tante de una intersecci\u00f3n. Ejemplo de intersecci\u00f3n Si queremos obtener una relaci\u00f3n R que incluya a todos los empleados de la empresa del ejemplo que trabajan tanto en administraci\u00f3n como en producci\u00f3n, realizaremos la inter- secci\u00f3n de las relaciones EMPLEADOS_ADM y EMPLEADOS_PROD de la forma siguiente: R : = EMPLEADOS_ADM EMPLEADOS_PROD.R DNI nombre apellido edificiodesp n\u00famerodesp 77.232.144 Elena Pla Marina 230 21.335.245 Jorge Soler NULO NULO 88.999.210 Pedro Gonz\u00e1lez NULO NULO La intersecci\u00f3n es una operaci\u00f3n que, a partir de dos relaciones, obtiene una nueva relaci\u00f3n formada por las tu plas que pertenecen a las dos re- laciones de partida. La intersecci\u00f3n es una operaci\u00f3n bina ria; la intersecci\u00f3n de dos relacio- nes T y S se indica T S. Los atributos del esquema de la relaci\u00f3n resultante de T S coinci- den con los atributos del esquema de la relaci\u00f3n T. La extensi\u00f3n de la relaci\u00f3n resultante de T S es el conjunto de tu- plas que pertenecen a la ex tensi\u00f3n de ambas relaciones. FUOC 71Z799014MO 39 El modelo relacional y el \u00e1lgebra relacional Entonces, la relaci\u00f3n R resultante ser\u00e1: Observad que se ha tomado la convenci\u00f3n de que los atributos de la relaci\u00f3n que resulta coincidan con los atributos de la relaci\u00f3n que figura en primer lugar. 5.1.3. Diferencia La diferencia EMPLEADOS_ADM menos EMPLEADOS_PROD da como resultado una nueva re- laci\u00f3n que contiene a los empleados de admini straci\u00f3n que no son empleados de producci\u00f3n, y se indicar\u00eda de este modo: EMPLEADOS_ADM - EMPLEADOS_PROD . La diferencia, como ocurr\u00eda en la uni\u00f3n y la intersecci\u00f3n, s\u00f3lo tiene sentido si se aplica a relaciones que tengan tuplas similares. Para pode r realizar la dife- rencia de dos relaciones es necesari o que las relaciones sean compatibles. A continuaci\u00f3n definimos los atributos y la extensi\u00f3n de la relaci\u00f3n resultante de una diferencia. Ejemplo de diferencia Si queremos obtener una relaci\u00f3n R con todos los empleados de la empresa del ejemplo que trabajan en administraci\u00f3n, pero no en produ cci\u00f3n, haremos la difere ncia de las relaciones EMPLEADOS_ADM y EMPLEADOS_PROD de la forma siguiente: R := EMPLEADOS_ADM - EMPLEADOS_PROD Entonces la relaci\u00f3n R resultante ser\u00e1: Se ha tomado la convenci\u00f3n de que los atributos de la rela ci\u00f3n resultante co- incidan con los atributos de la rela ci\u00f3n que figura en primer lugar.R DNI nombre apellido edificiodesp n\u00famerodesp 33.567.711 Marta Roca Marina 120 La diferencia es una oper aci\u00f3n que, a partir de dos relaciones, obtiene una nueva relaci\u00f3n formada por todas las tuplas que est\u00e1n en la primera rela-ci\u00f3n y, en cambio, no est\u00e1n en la segunda. La diferencia es una operaci\u00f3nbinaria, y la diferencia entre las relaciones T y S se indica como T - S. Los atributos del esquema de la relaci\u00f3n resultante de T - S coinci- den con los atributos del esquema de la relaci\u00f3n T. La extensi\u00f3n de la relaci\u00f3n resultante de T - S es el conjunto de tuplas que pertenecen a la extensi\u00f3n de T, pero no a la de S. R DNI nombre apellido edificiodesp n\u00famerodesp 40.444.255 Juan Garc\u00eda Marina 120 FUOC 71Z799014MO 40 El modelo relacional y el \u00e1lgebra relacional 5.1.4. Producto cartesiano Si calculamos el producto cartesiano de EDIFICIOS_EMP y DESPACHOS , obtendremos una nueva relaci\u00f3n que contiene todas las co ncatenaciones posibles de tuplas de EDIFICIOS_EMP con tuplas de DESPACHOS . Si se quiere calcular el producto cartes iano de dos relaciones que tienen alg\u00fan nombre de atributo com\u00fan, s\u00f3lo hace falta redenominar pr eviamente los atri- butos adecuados de una de las dos relaciones. A continuaci\u00f3n definimos los atributos y la extensi\u00f3n de la relaci\u00f3n resultante de un producto cartesiano. Ejemplo de producto cartesiano El producto cartesiano de las relaciones DESPACHOS y EDIFICIOS_EMP del ejemplo se puede hacer como se indica (es necesario redenominar atributos previamente): EDIFICIOS \u00d7 DESPACHOS. Entonces, la relaci\u00f3n R resultante ser\u00e1:El producto cartesiano es una operac i\u00f3n que, a partir de dos relaciones, obtiene una nueva relaci\u00f3n formada por todas las tuplas que resultan de concatenar tuplas de la primera relaci\u00f3n con tuplas de la segunda. El producto cartesiano es un a operaci\u00f3n binaria. Siendo T y S dos rela- ciones que cumplen que sus esquemas no tienen ning\u00fan nombre deatributo com\u00fan, el producto cartesiano de T y S se indica como T \u00d7 S. Los atributos del esquema de la relaci\u00f3n resultante de T \u00d7 S son todos los atributos de T y todos los atributos de S*. La extensi\u00f3n de la relaci\u00f3n resultante de T \u00d7 S es el conjunto de todas las tuplas de la forma < v1, v2, ..., vn, w1, w2, ..., que < v1, v2, ..., vn> pertenece a la extensi\u00f3n de T y que < w1, w2, ..., wm> pertenece a la extensi\u00f3n de S. R nombreedificio supmediadesp edificio n\u00famero superficie Marina 15 Marina 120 10Marina 15 Marina 230 20Marina 15 Diagonal 120 10Marina 15 Diagonal 440 10 Diagonal 10 Marina 120 10 * Recordad que T y S no tienen ning\u00fan nombre de atributo com\u00fan. FUOC 71Z799014MO 41 El modelo relacional y el \u00e1lgebra relacional Conviene se\u00f1alar que el pr oducto cartesiano es un a operaci\u00f3n que raramente se utiliza de forma expl\u00edcit a, porque el resultado qu e da no suele ser \u00fatil para resolver las consultas habituales. A pesar de ello, el producto cartesiano se incluye en el \u00e1lgebra relacional por- que es una operaci\u00f3n primitiv a; a partir de la cual se define otra operaci\u00f3n del \u00e1lgebra, la combinaci\u00f3n, que se utiliza con mucha frecuencia. 5.2. Operaciones espec\u00edficamente relacionales Las operaciones espec\u00edficame nte relacionales son la selecci\u00f3n , la proyecci\u00f3n y la combinaci\u00f3n . 5.2.1. Selecci\u00f3n Para obtener una relaci\u00f3n que tenga todos los despachos del ed ificio Marina que tienen m\u00e1s de 12 metros cuadrados, podemos ap licar una selecci\u00f3n a la relaci\u00f3n DESPACHOS con una condici\u00f3n de selecci\u00f3n que sea edificio = Marina y superficie > 12; se indicar\u00eda DESPA- CHOS( edificio = Marina y superficie > 12). En general, la condici\u00f3n de selecci\u00f3n C est\u00e1 formad a por una o m\u00e1s cl\u00e1usulas de la forma: Ai v, o bien: Ai Aj, R nombreedificio supmediadesp edificio n\u00famero superficie Diagonal 10 Marina 230 20Diagonal 10 Diagonal 120 10Diagonal 10 Diagonal 440 10 Podemos ver la selecci\u00f3n como una op eraci\u00f3n que sirve para elegir al- gunas tuplas de una relaci\u00f3n y elimin ar el resto. M\u00e1s concretamente, la selecci\u00f3n es una operaci\u00f3 n que, a partir de una relaci\u00f3n, obtiene una nueva relaci\u00f3n formada po r todas las tuplas de la relaci\u00f3n de partida que cumplen una condici\u00f3n de selecci\u00f3n especificada. La selecci\u00f3n es una operaci\u00f3n unaria. Siendo C una condici\u00f3n de se- lecci\u00f3n, la selecci\u00f3n de T con la condici\u00f3n C se indica como T( C). FUOC 71Z799014MO 42 El modelo relacional y el \u00e1lgebra relacional donde Ai y Aj son atributos de la relaci\u00f3n T, es un operador de comparaci\u00f3n* y v es un valor. Adem\u00e1s, se cumple que: En las cl\u00e1usulas de la forma Ai v, v es un valor del dominio de Ai. En las cl\u00e1usulas de la forma Ai, Aj, Ai y Aj tienen el mismo dominio. Las cl\u00e1usulas que forman una condici\u00f3n de selecci\u00f3n se conectan con los si- A continuaci\u00f3n definimos los atributos y la extensi\u00f3n de la relaci\u00f3n resultante de una selecci\u00f3n. Ejemplo de selecci\u00f3n Si queremos obtener una relaci\u00f3n R con los despachos de la ba se de datos del ejemplo que est\u00e1n en el edificio Marina y que tienen una superficie de m\u00e1s de 12 metros cuadrados, ha- remos la siguiente selecci\u00f3n: R := DESPACHOS(edificio = Marina y superficie > 12). La relaci\u00f3n R resultante ser\u00e1: 5.2.2. Proyecci\u00f3nLos atributos del esquema de la relaci\u00f3n resultante de T( C) coinciden con los atributos del es quema de la relaci\u00f3n T. La extensi\u00f3n de la relaci\u00f3n resultante de T( C) es el conjunto de tuplas que pertenecen a la extensi\u00f3n de T y que satisfacen la condici\u00f3n de se- lecci\u00f3n C. Una tupla t satisface una condici\u00f3n de selecci\u00f3n C si, despu\u00e9s de sustituir cada atributo qu e hay en C por su valor en t, la condici\u00f3n C se eval\u00faa en el valor cierto. R edificio n\u00famero superficie Marina 230 20 Podemos considerar la proyecci\u00f3n como una operaci\u00f3n que sirve para elegir algunos atributos de una relaci \u00f3n y eliminar el resto. M\u00e1s concre- tamente, la proyecci\u00f3n es una operac i\u00f3n que, a partir de una relaci\u00f3n, obtiene una nueva relaci\u00f3n formada po r todas las (sub)t uplas de la re- laci\u00f3n de partida que resultan de e liminar unos atributos especificados.* Es decir, =, , <, , >, o . FUOC 71Z799014MO 43 El modelo relacional y el \u00e1lgebra relacional Para obtener una relaci\u00f3n que tenga s\u00f3lo los atributos nombre y apellido de los empleados de administraci\u00f3n, podemos hacer un a proyecci\u00f3n en la relaci\u00f3n EMPLEADOS_ADM sobre estos dos atributos. Se indicar\u00ed a de la forma siguiente: EMPLEADOS_ADM [nombre, apellido ]. A continuaci\u00f3n definiremos los atributos y la extensi\u00f3n de la relaci\u00f3n resul- tante de una proyecci\u00f3n. Ejemplo de proyecci\u00f3n Si queremos obtener una relaci\u00f3n R con el nombre y el apellido de todos los empleados de administraci\u00f3n de la base de datos del ejemplo, haremos la siguiente proyecci\u00f3n: R := EMPLEADOS_ADM[ nombre, apellido ]. Entonces, la relaci\u00f3n R resultante ser\u00e1: 5.2.3. Combinaci\u00f3nLa proyecci\u00f3n es una operaci\u00f3n unaria. Siendo { Ai, Aj, ..., Ak} un subcon- junto de los atributos del esquema de la relaci\u00f3n T, la proyecci\u00f3n de T sobre { Ai, Aj, ..., Ak} se indica como T[ Ai, Aj, ..., Ak]. Los atributos del esquema de la relaci\u00f3n resultante de T[ Ai, Aj, ..., Ak] son los atributos { Ai, Aj, ..., Ak}. La extensi\u00f3n de la relaci\u00f3n resultante de T[ Ai, Aj, ..., Ak] es el conjun- to de todas las tuplas de la forma < t.Ai, t.Aj, ..., t.Ak>, donde se cumple que t es una tupla de la extensi\u00f3n de T y donde t.Ap denota el valor para el atributo Ap de la tupla t. R nombre apellido Juan Garc\u00eda Marta Roca La combinaci\u00f3n es una operaci\u00f3n que, a partir de dos relaciones, obtie- ne una nueva relaci\u00f3n formada por to das las tuplas que resultan de con- cadenar tuplas de la primera relaci\u00f3n con tuplas de la segunda, y que cumplen una condici\u00f3n de combinaci\u00f3n especificada. La combinaci\u00f3n es una operaci\u00f3n binaria. Siendo T y S dos relaciones cuyos esquemas no tienen ning\u00fan no mbre de atributo com\u00fan, y siendo B una condici\u00f3n de combinac i\u00f3n, la combinaci\u00f3n de T y S seg\u00fan la con- dici\u00f3n B se indica T[B]S.Eliminaci\u00f3n de las tuplas repetidas Notad que la proyecci\u00f3n elimina impl\u00edcitamente todas las tuplas repetidas. El resulta-do de una proyecci\u00f3n es una relaci\u00f3n v\u00e1lida y no puede tener repeticiones de tuplas. FUOC 71Z799014MO 44 El modelo relacional y el \u00e1lgebra relacional Para conseguir una relaci\u00f3n que tenga los da tos de cada uno de los empleados de admi- nistraci\u00f3n junto con los datos de los despachos donde trabajan, podemos hacer una com-binaci\u00f3n de las relaciones EMPLEADOS_ADM y DESPACHOS , donde la condici\u00f3n de combinaci\u00f3n indique lo siguiente: edificiodesp = edificio y n\u00famerodesp = n\u00famero . La condi- ci\u00f3n de combinaci\u00f3n hace que el resultado s\u00f3lo combine los datos de un empleado con los datos de un despacho si el edificiodesp y el n\u00famerodesp del empleado son iguales que el edificio y el n\u00famero del despacho, respecti vamente. Es decir, la condici\u00f3n hace que los datos de un empleado se combinen con los datos del despacho donde trabaja, pero no con datos de otros despachos. La combinaci\u00f3n del ejemplo anterior se indicar\u00eda de la forma siguiente: EMPLEADOS_ADM [edificiodesp = edificio, n\u00famerodesp = n\u00famero ]DESPACHOS . Si se quiere combinar dos relaciones que tienen alg\u00fan nombre de atributo co- m\u00fan, s\u00f3lo hace falta redenominar prev iamente los atributo s repetidos de una de las dos. En general, la condici\u00f3n B de una combinaci\u00f3n T[B]S est\u00e1 formada por una o m\u00e1s comparaciones de la forma Ai Aj, donde Ai es un atributo de la relaci\u00f3n T, Aj es un atributo de la relaci\u00f3n S, es un operador de comparaci\u00f3n ( =, , <, , >, ), y se cumple que Ai y Aj tienen el mismo dominio. Las comparaciones de una condici\u00f3n de combinaci\u00f3n se separan mediante comas. A continuaci\u00f3n definimos los atributos y la extensi\u00f3n de la relaci\u00f3n resultante de una combinaci\u00f3n. Ejemplo de combinaci\u00f3n Supongamos que se desea encontrar los datos de los despachos que tienen una superficie ma- yor o igual que la superficie media de los despachos del edificio donde est\u00e1n situados. La si- guiente combinaci\u00f3n nos proporcionar\u00e1 los dato s de estos despachos junto con los datos de su edificio (observad que es preciso redenominar previamente los atributos): EDIFICIOS( nombreeedficio,supmediadesp ) := EDIFICIOS_EMP(e dificio, supmediadesp ),Los atributos del esquema de la relaci\u00f3n resultante de T[B]S son to- dos los atributos de T y todos los atributos de S*. La extensi\u00f3n de la relaci\u00f3n resultante de T[B]S es el conjunto de tu- plas que pertenecen a la extensi\u00f3n del producto cartesiano T \u00d7 S y que satisfacen todas las comparaciones que forman la condici\u00f3n de combi- naci\u00f3n B. Una tupla t satisface una comparaci\u00f3n si, despu\u00e9s de sustituir cada atributo que figura en la comparaci\u00f3n por su valor en t, la compa- raci\u00f3n se eval\u00faa al valor cierto.* Recordad que T y S no tienen ning\u00fan nombre de atributo com\u00fan. FUOC 71Z799014MO 45 El modelo relacional y el \u00e1lgebra relacional R := EDIFICIOS [nombreedificio = edificio, supmediadesp superficie ] DESPACHOS. Entonces, la relaci\u00f3n R resultante ser\u00e1: Supongamos ahora que para obtener los datos de cada uno de los empleados de administra- ci\u00f3n, junto con los datos del despacho donde trabajan, utilizamos la siguiente combinaci\u00f3n: R := EMPLEADOS_ADM[edificiodesp = edificio, n\u00famerodesp = n\u00famero]DESPACHOS . La relaci\u00f3n R resultante ser\u00e1: La relaci\u00f3n R combina los datos de cada emplea do con los datos de su despacho. En ocasiones, la combinac i\u00f3n recibe el nombre de -combinaci\u00f3n , y cuando todas las comparaciones de la condici\u00f3n de la combinaci\u00f3n tienen el operador \"=\", se denomina equicombinaci\u00f3n . Seg\u00fan esto, la combinaci\u00f3n del \u00faltimo ejemplo es una equicombinaci\u00f3n. Observad que el resultado de una equicombinaci\u00f3n siempre incluye una o m\u00e1s parejas de atributos que tienen va lores id\u00e9nticos en todas las tuplas. En el ejemplo anterior, los valores de edificiodesp coinciden con los de edificio , y los valores de n\u00famerodesp coinciden con los de n\u00famero . Puesto que uno de cada par de atributos es superfluo, se ha establecido una variante de combinaci\u00f3n denominada combinaci\u00f3n natural , con el fin de eliminarlos. Ejemplo de combinaci\u00f3n natural Si hacemos: R := EDIFICIOS_EMP * DESPACHOS,R nombreedificio supmediadesp edificio n\u00famero superficie Marina 15 Marina 230 20 Diagonal 10 Diagonal 120 10 Diagonal 10 Diagonal 440 10 R DNI nombre apellido edificiodesp n\u00famerodesp edificio n\u00famero superficie 40.444.255 Juan Garc\u00eda Marina 120 Marina 120 1033.567.711 Marta Roca Marina 120 Marina 120 10 La combinaci\u00f3n natural de dos relaciones T y S se denota como T * S y consiste b\u00e1sicamente en una equi combinaci\u00f3n seguida de la elimina- ci\u00f3n de los atributos superfluos; adem\u00e1s, se considera por defecto quela condici\u00f3n de combinaci\u00f3n iguala todas las parejas de atributos que tienen el mismo nombre en T y en S. Observad que, a diferencia de la equicombinaci\u00f3n, la combinaci\u00f3n na- tural se aplica a relaciones que ti enen nombres de atributos comunes. FUOC 71Z799014MO 46 El modelo relacional y el \u00e1lgebra relacional se considera que la condici\u00f3n es edificio = edificio porque edificio es el \u00fanico nombre de atri- buto que figura tanto en el esquema de EDIFICIOS_EMP como en el esquema de DESPACHOS . El resultado de esta combinaci\u00f3n natural es: Notad que se ha eliminado uno de los atributos de nombre edificio . En ocasiones, antes de la combinaci\u00f3n natural es necesari o aplicar la opera- ci\u00f3n redenominar para hacer coincidir los nombre s de los atributos que nos in- teresa igualar. Ejemplo de combinaci\u00f3n natural con redenominaci\u00f3n Por ejemplo, si queremos obtener los datos de cada uno de los empleados de administraci\u00f3n junto con los datos del despacho donde trabajan pero sin repetir valores de atributos super-fluos, haremos la siguiente combinaci\u00f3n natura l, que requiere una re denominaci\u00f3n previa: D(edificiodesp, n\u00fame rodesp, superficie ) := DESPACHOS( edificio, n\u00famero, superficie ), R := EMPLEADOS_ADM * D. Entonces, la relaci\u00f3n R resultante ser\u00e1: 5.3. Secuencias de operaciones del \u00e1lgebra relacionalR edificio supmediadesp n\u00famero superficie Marina 15 120 10Marina 15 230 20 Diagonal 10 120 10Diagonal 10 440 10 R DNI nombre apellido edificiodesp n\u00famerodesp superficie 40.444.255 Juan Garc\u00eda Marina 120 1033.567.711 Marta Roca Marina 120 10 En muchos casos, para formular un a consulta en \u00e1lgebra relacional es preciso utilizar varias operaciones, que se aplican en un cierto orden. Para hacerlo, hay dos posibilidades: 1)Utilizar una sola expresi\u00f3n del \u00e1l gebra que incluya todas las opera- ciones con los par\u00e9ntesis necesarios para indicar el orden de aplicaci\u00f3n. 2)Descomponer la expresi\u00f3n en vari os pasos donde cada paso aplique una sola operaci\u00f3n y obtenga una relaci\u00f3n intermedia que se pueda uti-lizar en los pasos subsiguientes. FUOC 71Z799014MO 47 El modelo relacional y el \u00e1lgebra relacional Ejemplo de utilizaci\u00f3n de secuencias de operaciones Para obtener el nombre y el ap ellido de los empleados, tanto de administraci\u00f3n como de pro- ducci\u00f3n, es necesario hacer una uni\u00f3n de EMPLEADOS_ADM y EMPLEADOS_PROD , y des- pu\u00e9s hacer una proyecci\u00f3n sobre los atributos nombre y apellido . La operaci\u00f3n se puede expresar de las formas siguientes: a)Se puede utilizar una sola expresi\u00f3n: R := ) [nombre, EMPS := EMPLEADOS_ADM EMPLEADOS_PROD; R := EMPS[ nombre, apellido ] En los casos en que una consulta requiere efectuar muchas operaciones, resul- ta m\u00e1s sencilla la segund a alternativa, porque evita expresiones complejas. Otros ejemplos de consultas formuladas con secuencias de operaciones Veamos algunos ejemplos de consultas en la ba se de datos formuladas con secuencias de ope- raciones del \u00e1lgebra relacional. 1)Para obtener el nombre del edif icio y el n\u00famero de los despachos situados en edificios en los que la superficie media de estos despachos es mayor que 12, podemos utilizar la siguiente secuencia de operaciones: A := EDIFICIOS_EMP( supmediadesp > 12); B : = D E S P A C H O S * A; R : = B [edificio, n\u00famero ] 2)Supongamos ahora que se desea obtener el nombre y el apellido de todos los empleados (tanto de administraci\u00f3n como de producci\u00f3n ) que est\u00e1n asignados al despacho 120 del edi- ficio Marina. En este caso, podemo s utilizar la siguiente secuencia: A := EMPLEADOS_ADM EMPLEADOS_PROD ; B := A( edificiodesp = Marina y n\u00famerodesp = 120); R := B[ nombre, apellido ]. 3)Si queremos consultar el nombre del edificio y el n\u00famero de los despachos que ning\u00fan empleado de administraci\u00f3n tiene asig nado, podemos utilizar esta secuencia: A := DESPACHOS [ edificio, n\u00famero ]; B := EMPLEADOS_ADM[ edificiodesp, n\u00famerodesp ]; R := A - B . 4)Para obtener el DNI, el nombre y el apellido de todos los empleados de administraci\u00f3n que tienen despacho, junto con la superficie de su despacho, podemos hacer lo siguiente: A [ DNI, nombre, apellido, edificio, n\u00famero ] := EMPLEADOS_ADM[ DNI, nombre, apellido, edi- ficiodesp, n\u00famerodesp ]; B : = A * DESPACHOS ; R := B[DNI, nombre, apellido, superficie] . 5.4. Extensiones: co mbinaciones finalizar del \u00e1lgebra rela cional, analizaremos algunas extensiones \u00fatiles de la combinaci\u00f3n. Las combinaciones que se han descrito obti enen las tuplas del producto cartesia- no de dos relaciones que satisfacen una condici\u00f3n de combinaci\u00f3n. Las tuplas de Recordad que la base de datos que se utiliza en los ejemplos se ha descrito en la introducci\u00f3n del apartado 5 de esta unidad did\u00e1ctica. FUOC 71Z799014MO 48 El modelo relacional y el \u00e1lgebra relacional una de las dos relaciones que no tienen en la otra relaci\u00f3n una tupla como m\u00ed- nimo con la cual, una vez concatenadas , satisfagan la condici\u00f3n de combina- ci\u00f3n, no aparecen en el resultado de la combinaci\u00f3n, y podr\u00edamos decir que sus datos se pierden. Por ejemplo, si hacemos la siguiente combinac i\u00f3n natural (con una redenominaci\u00f3n previa): D(edificiodesp, n\u00fame ) superficie ), R := EMPLEADOS_PROD * D . Puesto que se trata de una combinaci\u00f3n natura l, se considera que la condici\u00f3n de combina- ci\u00f3n es edificio = edificio y n\u00famero = n\u00famero , y la relaci\u00f3n R resultante ser\u00e1: Notad que en esta relaci\u00f3n R no est\u00e1n los empleados de producci\u00f3n que no tienen despacho asignado (con valores nulos en edificiodesp y n\u00famerodesp ), y tampoco los despachos que no tienen ning\u00fan empleado de producci\u00f3n, porque no cumplen la condici\u00f3n de combinaci\u00f3n. Conviene destacar que las tuplas que tienen un valor nulo para alguno de los atri- butos que figuran en la condici\u00f3n de co mbinaci\u00f3n se pierden siempre, porque en estos casos la condici\u00f3 n de combinaci\u00f3n siempre se eval\u00faa a falso. En algunos casos, puede interesar hacer combinaciones de los datos de dos re- laciones sin que haya p\u00e9rdid a de datos de las relaciones de partida. Entonces, se utilizan las 120 1055.898.425 Carlos Buend\u00eda Diagonal 120 1077.232.144 Elena Pla Marina 230 20 Las combinaciones externas entre dos relaciones T y S consisten en va- riantes de combinaci\u00f3n que conserva n en el resultado todas las tuplas de T, de S o de ambas relaciones. Pueden ser de los tipos siguientes: 1)La combinaci\u00f3n externa izquierda entre dos relaciones T y S, que denotamos como T[C]IS, conserva en el resultado todas las tuplas de la relaci\u00f3n T. 2)La combinaci\u00f3n externa derecha entre dos relaciones T y S, que denotamos como T[C]DS, conserva en el resultado todas las tuplas de la relaci\u00f3n S. 3)Finalmente, la combinaci\u00f3n externa plena entre dos relaciones T y S, que denotamos como T[C]pS, conserva en el re sultado todas las tu- plas de T y todas las tuplas de S.Las combinaciones se han explicado en el subapartado 5.3.3 de esta unidad did\u00e1ctica. FUOC 71Z799014MO 49 El modelo relacional y el \u00e1lgebra relacional Estas extensiones tambi\u00e9n se aplican al caso de la combin aci\u00f3n natural entre dos relaciones, T * S, concretamente: a)La combinaci\u00f3n natural externa izquierda entre dos relaciones T y S, que se indica como T *I S, conserva en el resultado todas las tuplas de la relaci\u00f3n T. b)La combinaci\u00f3n natural externa derecha entre dos relaciones T y S, que se indica como T *D S, conserva en el resultado toda s las tuplas de la relaci\u00f3n S. c)Finalmente, la combinaci\u00f3n natural externa plena entre dos relaciones T y S, que se indica como T *P S, conserva en el resultado todas las tuplas de T y todas las tuplas de S. Las tuplas de una relaci\u00f3n T que se conservan en el resultado R de una combi- naci\u00f3n externa con otra relaci\u00f3n S, a pesar de que no satisfacen la condici\u00f3n de combinaci\u00f3n, tienen valores nulos en el resultado R para todos los atributos que provienen de la relaci\u00f3n S. Ejemplos de combinaciones naturales externas 1)Si hacemos la siguiente combinaci\u00f3n natura l derecha (con una redenominaci\u00f3n previa): D(edificiodesp, n\u00fame rodesp, superficie ) superficie ), R := EMPLADOS_PROD *D D, la relaci\u00f3n R resultante ser\u00e1: Ahora obtenemos todos los despachos en la rela ci\u00f3n resultante, tanto si tienen un empleado de producci\u00f3n asignado como si no. Notad que los atributos DNI, nombre y apellido para los despachos que no tienen empl eado reciben valores nulos. 2)Si hacemos la siguiente combinaci\u00f3n natural izquierda (con una redenominaci\u00f3n previa): D(edificiodesp, n\u00famerodesp, superficie ) := DESPACHOS( edificio, n\u00famero, superficie ), R := EMPLEADOS_PROD *I D, entonces edificiodesp n\u00famerodesp superficie 33.567.711 120 1055.898.425 Carlos Buend\u00eda Diagonal 120 1077.232.144 Elena Pla Marina 230 20 NULO NULO NULO Diagonal 440 10 R DNIemp nombreemp apellidoemp edificiodesp n\u00famerodesp superficie 33.567.711 Marta Roca Marina 120 1055.898.425 Carlos Buend\u00eda Diagonal 120 10 77.232.144 Elena Pla Marina23020 21.335.245 Jorge Soler NULO NULO NULO 88.999.210 Pedro Gon z\u00e1lez NULO NULO NULO FUOC 71Z799014MO 50 El modelo relacional y el \u00e1lgebra relacional Esta combinaci\u00f3n externa nos pe rmite obtener en la relaci\u00f3n resultante a todos los emplea- dos de producci\u00f3n, tanto si tienen despacho co mo si no. Observad que el atributo superficie para los empleados que no tienen despacho contiene un valor nulo. 3)Finalmente, si hacemos la siguiente combin aci\u00f3n natural redenominaci\u00f3n previa): D(edificiodesp, ), R:= EMPLEADOS_PROD *P D, entonces la relaci\u00f3n R resultante ser\u00e1: En este caso, en la relaci\u00f3n resultante obtenemos a todos los empleados de producci\u00f3n y tam- bi\u00e9n 120 1055.898.425 Carlos Buend\u00eda Diagonal 120 1077.232.144 Elena Pla Marina 230 2021.335.245 Jorge Soler NULO NULO NULO88.999.210 Pedro Gonz\u00e1lez NULO NULO NULO NULO NULO NULO Diagonal 440 10 FUOC 71Z799014MO 51 El modelo relacional y el \u00e1lgebra relacional Resumen En esta unidad did\u00e1ctica hemos presentado los conceptos fundamentales del modelo relacional de datos y, a continuaci\u00f3n, hemos explicado las opera- ciones del \u00e1lgebra relacional : 1)Los aspectos m\u00e1s relevant es del modelo relacional que hemos descrito son los siguientes: a)En lo que respecta a la estructura de los datos : Consiste en un conjunto de relaciones. Una relaci\u00f3n permite almacena r datos relacionados entre s\u00ed. La clave primaria de una relaci \u00f3n permite identificar sus datos. Las claves for\u00e1neas de las relaciones permiten referenciar claves primarias y, de este modo, establecer conexion es entre los datos de las relaciones. b)En lo que respecta a la integridad de los datos : La regla de integridad de unicidad y de entidad de la clave primaria: las cla- ves primarias no pueden contener valores repetidos ni valores nulos. La regla de integridad re ferencial: los valores de las claves for\u00e1neas deben existir en la clave primaria referenc iada o bien deben ser valores nulos. La regla de integridad de dominio: los valores no nulos de un atributo de- ben pertenecer al dominio del atribu to, y los operadores que es posible aplicar sobre los valores dependen de los dominios de estos valores. 2)El \u00e1lgebra relacional proporciona un conjunto de operaciones para mani- pular relaciones. Estas oper aciones se pueden clasific la forma siguiente: a)Operaciones conjuntistas: uni\u00f3n, in tersecci\u00f3n, diferencia y producto cartesiano. b)Operaciones espec\u00edficamente relacion ales: selecci\u00f3n, proyecci\u00f3n y com- binaci\u00f3n. Las operaciones del \u00e1lgebra relacional pueden formar secu encias que permiten resolver consultas complejas. FUOC 71Z799014MO 53 El modelo relacional y el \u00e1lgebra relacional Ejercicios de autoevaluaci\u00f3n 1.Dada la relaci\u00f3n que corresponde a la siguiente representaci\u00f3n tabular: Figura 4 a)Indicad qu\u00e9 conjunto de atributos tiene. b)Decid qu\u00e9 dominio tiene ca da uno de sus atributos. c)Escribid todas las distintas formas de denotar su esquema de relaci\u00f3n. d)Elegid una de las formas de denotar su esquema de relaci\u00f3n y utilizadla para dibujar el con- junto de tuplas correspondiente a su extensi\u00f3n. 2.Indicad cu\u00e1les son todas las supercla ves de las siguientes relaciones: a)DESPACHOS (edificio, n\u00famero, superficie ), que tiene como \u00fanica clave candidata la siguien- te: edificio, n\u00famero . b)EMPLEADOS (DNI, NSS, nombre, apellido ), que tiene es claves candidatas: DNI y NSS . 3.Decid, para cada una de las siguientes operaciones de actualizaci\u00f3n, si se podr\u00eda aceptar su aplicaci\u00f3n sobre la base de datos qu e se ha utilizado en esta unidad: a)Insertar en EDIFICIOS_EMP <40.444.255, Juan, g)Borrar en tupla clave for\u00e1nea edificio de DESPA- CHOS se ha seleccionado la pol\u00edtica de restricci\u00f3n en caso de borrado. h)Borrar en EDIFICIOS_EMP la tupla <Marina, 15> si para la clave for\u00e1nea edificio de DES- PACHOS se ha seleccionado la pol\u00edt ica de actualizaci\u00f3n en ca scada en caso de borrado. 4.Escribid secuencias de operaciones del \u00e1lgebr a relacional que resuel van las siguientes con- sultas en la base de datos que hemos utilizado en esta unidad: a)Obtener los despachos con una superficie mayor que 15. Concretamente, se quiere saber el nombre del edificio, el n\u00famero y la superfic ie de estos despachos, junto con la superficie media de los despachos del edificio donde est\u00e1n situados. b)Obtener el nombre del edificio y el n\u00famero de los despachos que no tienen asignado a ning\u00fan empleado (ni de produc ci\u00f3n ni de administraci\u00f3n). c)Obtener el nombre y el apellido de los emplea dos (tanto de administraci\u00f3n como de pro- ducci\u00f3n), que no tienen despacho. d)Obtener el nombre y el apellido de todos los empleados (tanto de administraci\u00f3n como de producci\u00f3n) que tienen despacho asignado, junto con la superficie de su despacho y lasuperficie media de los despachos del edificio al que pertenece su despacho. e)Obtener los despachos con una superficie mayo r que la superficie del despacho Diagonal, 120. Concretamente, se quiere saber el nombre del edificio y el n\u00famero de estos despachos. f)Obtener todos los despachos de la empresa (tan to si tienen empleados como si no), junto con los empleados que tienen asignados (en caso de que los tengan). Concretamente, se quie- re conocer el nombre del edificio, el n\u00famero de despacho y el DNI del empleado. FUOC 71Z799014MO 54 El modelo relacional y el \u00e1lgebra relacional 5.Sea R la relaci\u00f3n que resulta de la intersecci\u00f3n de las relaciones T y S, es decir, R := T S. Escribid una secuencia de operaciones del \u00e1lgebra relacional que incluya s\u00f3lo operacionesprimitivas y que obtenga como resultado R. 6.Sean las relaciones de esquema T( A, B, C) y S( D, E, F), y sea R la relaci\u00f3n que resulta de la siguiente combinaci\u00f3n: R := T [B = D, C = E ]S. Escribid una secuencia de operaciones del \u00e1lgebra relacional que incluya s\u00f3lo operaciones primitivas y que obtenga como resultado R. FUOC 71Z799014MO 55 El modelo relacional y el \u00e1lgebra relacional Solucionario Ejercicios de autoevaluaci\u00f3n 1. a)La relaci\u00f3n representada tiene el siguiente conjunto de atributos: edificio, n\u00famero, superficie . b)Los dominios son dominio( edificio ) = edificios , dominio( n\u00famero ) = n\u00fameros y dominio( su- perficie ) = sups. c)Las formas de denotar el esquema de relaci\u00f3n son: D E S P A C H O S ( edificio, n\u00famero, superficie ), D E S P A C H O S ( edificio, superficie, n\u00famero ), D E S P A C H O S ( n\u00famero, edificio, superficie ), D E S P A C H O S ( n\u00famero, superficie, edificio ), D E S P A C H O S ( superficie, edificio, n\u00famero ), D E S P A C H O S ( superficie, n\u00famero, edificio ), que corresponden a las posibles or denaciones de sus atributos. d)Elegiremos la siguiente forma de denotar el esquema de relaci\u00f3n: DESPACHOS( edificio, n\u00famero, superficie ). Entonces el conjunto de tuplas de su extensi\u00f3n ser\u00e1: Figura 5 2.Las superclaves de las relaciones correspondientes son: a){edificio, n\u00famero } y {edificio, n\u00famero, superficie }. b){DNI}, {NSS}, NSS }, }, nombre }, {NSS, apellido }, {DNI, nom- bre, apellido }, {NSS, nombre, apellido }, {DNI, NSS, nombre, apellido } y {DNI, NSS, nombre, apellido }. 3. a)Se acepta. b)Se rechaza porque viola la regla de integr idad de entidad de la clave primaria. c)Se rechaza porque viola la regl a de integridad referencial. d)Se rechaza porque viola la regla de integr idad de unicidad de la clave primaria. e)Se acepta. f)Se rechaza porque viola la regla de integr idad de unicidad de la clave primaria. g)Se rechaza porque viola la regl a de integridad referencial. h)Se acepta y se borran el edificio Marina y todos sus despachos. 4. a)Podemos utilizar la siguiente secuencia de operaciones: A := DESPACHOS (superficie >15), R := A * EDIFICIOS_EMP . b)Podemos utilizar la siguiente secuencia de operaciones: A : = D E S P A C H O S [edificio, n\u00famero ], B := EMPLEADOS_ADM EMPLEADOS_PROD, C := B [edificiodesp, n\u00famerodesp ], R := A C. c)Podemos utilizar la siguiente secuencia de operaciones: A := EMPLEADOS_ADM EMPLEADOS_PROD , B := A(edificiodesp = NULO y n\u00famerodesp = NULO), R := B[nombre, apellido ]. d)Podemos utilizar la siguiente secuencia de operaciones: A := EMPLEADOS_ADM EMPLEADOS_PROD, B(DNI, nombre, apellido, edificio, n\u00famero) := A(DNI, nombre, apellido, edificiodesp, n\u00famerodesp) , C := B * DESPACHOS , D := C * EDIFICIOS_EMP , R : = D [nombre, apellido, superficie, supmediadesp ]. FUOC 71Z799014MO 56 El modelo relacional y el \u00e1lgebra relacional e)Podemos utilizar la siguiente secuencia de operaciones: A := DESPACHOS (edificio = Diagonal y n\u00famero = 120), B ( Ed, Num , Sup) := A( edificio , n\u00famero , superficie ), C := DESPACHOS [superficie >Sup] B, R := C[edificio , n\u00famero ]. f)Podemos utilizar la siguiente secuencia := n\u00famero , DNI]. 5.La secuencia siguiente: A : = T S, R := T A, s\u00f3lo incluye operaciones primitivas, dado que la diferencia es primitiva, y obtiene el mismo resultado que R := T S. 6.La siguiente secuencia: A := T \u00d7 S, R := A(B = D y C = E), que s\u00f3lo incluye operaciones primitivas (un pr oducto cartesiano y una selecci\u00f3n), obtiene el mismo resultado que R := T[B = D ,C = E ]S. Glosario actualizaci\u00f3n Hecho de reflejar los cambios que se producen en la realidad en las re laciones de una base de datos. actualizaci\u00f3n en cascada para el caso de borrado Pol\u00edtica de mantenimiento de la integridad referencial que consiste en borrar una tupla t que tiene una clave primaria refere nciada, as\u00ed como borrar toda s las tuplas que referencian t. actualizaci\u00f3n en cascada para el caso de modificaci\u00f3n Pol\u00edtica de mantenimiento de la integridad referencial que consiste en permitir modificar atri- butos de la clave primaria de una tupla t con una clave primaria referenciada, y modificar del mismo modo todas las tuplas que referencian la tupla t. anulaci\u00f3n en caso de borrado Pol\u00edtica de mantenimiento de la integridad referencial que consiste en borrar una tupla t con una clave referenciada y, adem\u00e1s, modi ficar todas las tuplas que referencian t de modo que los atributos de la clave for\u00e1nea correspondiente tomen valores nulos. anulaci\u00f3n en caso de modificaci\u00f3n Pol\u00edtica de mantenimiento de la integridad referencial que consiste en modificar atributos de la clave primaria de una tupla t con una clave referenciada y, adem\u00e1s, modificar todas las tu- plas que referencian t de modo que los atributos de la clave for\u00e1nea correspondiente tomen valores nulos. atributo (en el contexto del modelo relacional) Nombre del papel que ejerce un do minio en un esquema de relaci\u00f3n. borrado Hecho de borrar una o m\u00e1s tuplas de una relaci\u00f3n. cardinalidad de una relaci\u00f3n N\u00famero de tuplas que pe rtenecen a su extensi\u00f3n. cierre relacional Propiedad de todas las operacion es del \u00e1lgebra relacional seg\u00fan la cual tanto sus operandos como su resultado son relaciones. clave alternativa de una relaci\u00f3n Clave candidata de la relaci\u00f3n que no se ha elegido como clave primaria. clave candidata de una relaci\u00f3n Superclave C de la relaci\u00f3n que cumple qu e ning\u00fan subconjunto propio de C es superclave. clave primaria de una relaci\u00f3n Clave candidata de la relaci\u00f3n que se ha elegido para identificar las tuplas de la relaci\u00f3n. FUOC 71Z799014MO 57 El modelo relacional y el \u00e1lgebra relacional clave for\u00e1nea de una relaci\u00f3n R Subconjunto de los atributos del esquema de la relaci\u00f3n, CF, tal que existe una relaci\u00f3n S (S no debe ser necesariamente diferente de R) que tiene por clave primaria CP, y se cumple que, para toda tupla t de la extensi\u00f3n de R, los valores para CF de t son o bien valores nulos, o bien valores que coinciden con los valores para CP de alguna tupla s de S. combinaci\u00f3n Operaci\u00f3n del \u00e1lgebra relacional que, a partir de dos relaci ones, obtiene una nueva relaci\u00f3n formada por todas las tuplas qu e resultan de concatenar tuplas de la primera relaci\u00f3n con tuplas de la segunda relaci\u00f3n, y que cumplen una condici\u00f3n de combinaci\u00f3n especificada. combinaci\u00f3n externa Extensi\u00f3n de combinaci\u00f3n entre dos relaciones, T y S, que conserva en el resultado todas las tuplas de T, de S o de las dos relaciones. combinaci\u00f3n natural Variante de combinaci\u00f3n que consiste b\u00e1sicamente en una equicombinaci\u00f3n seguida de la eliminaci\u00f3n de los atributos superfluos. consulta Obtenci\u00f3n de datos deducibles a partir de las relaciones que contiene la base de datos. diferencia Operaci\u00f3n del \u00e1lgebra relacional que, a partir de dos relaci ones, obtiene una nueva relaci\u00f3n formada por todas las tuplas que est\u00e1n en la pr imera relaci\u00f3n y, en cambio, no est\u00e1n en la segunda. dominio (en el contexto del modelo relacional) Conjunto de valores at\u00f3micos. equicombinaci\u00f3n Combinaci\u00f3n en la que todas las comparacione s de la condici\u00f3n tienen el operador \"=\". esquema de relaci\u00f3n Componente de una relaci\u00f3n que consiste en un nombre de relaci\u00f3n R y en un conjunto de atributos { A1, A2, ..., An}. extensi\u00f3n de una relaci\u00f3n de esquema R (A1, A2, ..., An) Conjunto de tuplas ti (i = 1, 2, ..., m ) donde cada tupla ti es un conjunto de pares ti = {<A1:Vi1>, <A2Vi2>, ..., <An:Vin>} y, para cada par < Aj:Vij>, se cumple que vij es un valor de dominio( Aj) o bien un valor nulo. grado de una relaci\u00f3n N\u00famero de atributos que pertenecen a su esquema. inserci\u00f3n Hecho de a\u00f1adir una o m\u00e1s tuplas a una relaci\u00f3n. integridad Propiedad de los datos de corresponder a re presentaciones plausi bles del mundo real. intersecci\u00f3n Operaci\u00f3n del \u00e1lgebra relacional que, a partir de dos relaci ones, obtiene una nueva relaci\u00f3n formada por las tuplas que est\u00e1n en las dos relaciones de partida. lenguaje basado en el c\u00e1lculo relacional Lenguaje que proporciona un tipo de formulaci\u00f3 n de consultas fundamentado en el c\u00e1lculo de predicados de la l\u00f3gica matem\u00e1tica. lenguaje basado en el \u00e1lgebra relacional Lenguaje que proporciona un tipo de formulac i\u00f3n de consultas inspirado en la teor\u00eda de conjuntos. modificaci\u00f3n Hecho de alterar los valores que tienen una o m\u00e1s tuplas de una relaci\u00f3n para uno o m\u00e1s de sus atributos. producto cartesiano Operaci\u00f3n del \u00e1lgebra relacional que, a partir de dos relaci ones, obtiene una nueva relaci\u00f3n formada por todas las tuplas qu e resultan de concatenar tuplas de la primera relaci\u00f3n con tuplas de la segunda relaci\u00f3n. FUOC 71Z799014MO 58 El modelo relacional y el \u00e1lgebra relacional proyecci\u00f3n Operaci\u00f3n del \u00e1lgebra relacional que, a partir de una relaci\u00f3n, obtiene una nueva relaci\u00f3n formada por todas las (sub)tuplas de la relaci\u00f3n de partida que resultan de eliminar unos atri- butos especificados. redenominar Operaci\u00f3n auxiliar del \u00e1lgebra relacional que permite cambiar los nombres que figuran en el esquema de una relaci\u00f3n. regla de integridad de dominio Regla que establece que un valor no nulo de un atributo Ai debe pertenecer al dominio del atributo Ai, y que los operadores que es posible aplic ar sobre los valores dependen de los do- minios de estos valores. regla de integridad de entidad de la clave primaria Regla que establece que si el conjunto de atributos CP es la clave primaria de una relaci\u00f3n R, la extensi\u00f3n de R no puede tener en ning\u00fan momento ninguna tupla con un valor nulo paraalguno de los atributos de CP. regla de integridad de modelo Condiciones generales que deben cumplirse en toda base de da tos de un modelo determinado. regla de integridad de unicidad de la clave primaria Regla que establece que si el conjunto de atributos CP es la clave primaria de una relaci\u00f3n R, la extensi\u00f3n de R no puede tener en ning\u00fan momento dos tuplas con la misma combinaci\u00f3n de valores para los atributos de CP. regla de integridad referencial Regla que establece que si el conjunto de atributos CF es una clave for\u00e1nea de una relaci\u00f3n R que referencia una relaci\u00f3n S (no necesariamente diferente de R), que tiene por clave prima- ria CP, entonces, para toda tupla t de la extensi\u00f3n de R, los valores para CF de t son o bien valores nulos o bien valores que coinciden con los valores para CP de alguna tupla s de S. relaci\u00f3n Elemento de la estructura de los datos de una base de datos relacional formado por un esque- ma (o intensi\u00f3n) y una extensi\u00f3n. restricci\u00f3n en caso de modificaci\u00f3n Pol\u00edtica de mantenimient o de la integridad referencial, que consiste en no permitir modificar ning\u00fan atributo de la clave prim aria de una tupla si se trata de una clave primaria referenciada. restricci\u00f3n en caso de borrado Pol\u00edtica de mantenimiento de la integridad refe rencial que consiste en no permitir borrar una tupla si tiene una clav e primaria referenciada. restricciones de integridad de usuario Condiciones espec\u00edficas que se deben cumplir en una base de datos concreta. selecci\u00f3n Operaci\u00f3n del \u00e1lgebra relacional que, a partir de una relaci\u00f3n, obtiene una nueva relaci\u00f3n for- mada por todas las tuplas de la relaci\u00f3n de partida que cu mplen una condici\u00f3n de selecci\u00f3n especificada. superclave de una relaci\u00f3n de esquema R( A 1, A2, ..., An) Subconjunto de los atributos del esquema tal qu e no puede haber dos tu plas en la extensi\u00f3n de la relaci\u00f3n que tengan la misma combinaci\u00f3 n de valores para los a tributos del subconjunto. uni\u00f3n Operaci\u00f3n del \u00e1lgebra relacional que, a partir de dos relaci ones, obtiene una nueva relaci\u00f3n formada por todas las tuplas que est\u00e1n en alguna de las relaciones de partida. Bibliograf\u00eda Bibliograf\u00eda b\u00e1sica Date, C.J. (2001). Introducci\u00f3n a los sistemas de bases de datos (7\u00aa ed.). Prentice-Hall. Elmasri, R.; Navathe, S.B. (2000). Sistemas de s. Conceptos fundamentales (3\u00aa ed.). Madrid: Addison-Wesley Iberoamericana.El lenguaje SQL Carme Mart\u00edn Escofet FUOC 71Z799014MO El lenguaje SQL \u00cdndice Introducci\u00f3n ............................................................................................... 5 Objetivos ...................................................................................................... 10 1. Sentencias de definici\u00f3n .................................................................... 11 1.1. Creaci\u00f3n y borrado de una base de datos relacional......................... 12 1.2. Creaci\u00f3n de tablas ............................................................................. 13 1.2.1. Tipos de datos ........................................................................ 13 1.2.2. Creaci\u00f3n, modificaci\u00f3n y borrado de dominios.................... 14 1.2.3. Definiciones por defecto ........................................................ 16 1.2.4. Restricciones de columna....................................................... 17 1.2.5. Restricciones de tabla............................................................. 17 1.2.6. Modificaci\u00f3n y borrado de claves primarias con claves for\u00e1neas que hacen referencia a \u00e9stas .................................... 18 1.2.7. Aserciones............................................................................... 19 1.3. Modificaci\u00f3n y borrado de tablas...................................................... 19 1.4. Creaci\u00f3n y borrado de vistas ............................................................. 20 1.5. Definici\u00f3n de la base de datos relacional BDUOC............................ 23 2. Sentencias de manipulaci\u00f3n ............................................................. 26 2.1. Inserci\u00f3n de filas en una tabla........................................................... 26 2.2. Borrado de filas de una tabla ............................................................. 27 2.3. Modificaci\u00f3n de filas de una tabla .................................................... 27 2.4. Introducci\u00f3n de filas en la base de datos relacional BDUOC ........... 28 2.5. Consultas a una base de datos relacional.......................................... 29 2.5.1. Funciones de agregraci\u00f3n....................................................... 31 2.5.2. Subconsultas........................................................................... 32 2.5.3. Otros predicados .................................................................... 32 2.5.4. Ordenaci\u00f3n de los datos obtenidos en respuestas a consultas ....................................................... 35 2.5.5. Consultas con agrupaci\u00f3n de filas de una tabla .................... 36 2.5.6. Consultas a m\u00e1s de una tabla ................................................ 38 2.5.7. La uni\u00f3n ................................................................................. 43 2.5.8. La intersecci\u00f3n ....................................................................... 44 2.5.9. La diferencia........................................................................... 45 3. Sentencias de control .......................................................................... 48 3.1. Las transacciones ............................................................................... 48 3.2. Las autorizaciones y desautorizaciones ............................................. 49 FUOC 71Z799014MO El lenguaje SQL 4. Sublenguajes especializados .............................................................. 51 4.1. SQL hospedado.................................................................................. 51 4.2. Las SQL/CLI ....................................................................................... 52 Resumen ....................................................................................................... 53 Actividad ..................................................................................................... 55 autoevaluaci\u00f3n .................................................................. 55 ................................................................................................. 58 Anexos .......................................................................................................... 59 FUOC 71Z799014MO 5 El lenguaje SQL Introducci\u00f3n El SQL es el lenguaje est\u00e1ndar ANSI/ISO de definici\u00f3n, manipulaci\u00f3n y control de bases de datos relacionales. Es un le nguaje declarativo: s\u00f3lo hay que indicar qu\u00e9 se quiere hacer. En cambio, en lo s lenguajes procedimentales es necesario especificar c\u00f3mo hay que hacer cualquier ac ci\u00f3n sobre la base de datos. El SQL es un lenguaje muy parecido al lenguaje natural; concretamente, se parece al ingl\u00e9s, y es muy expresivo. Por estas razo nes, y como lenguaje est\u00e1ndar, el SQL es un lenguaje con el que se puede ac ceder a todos los sistemas relacionales comerciales. Empezamos con una breve explicaci\u00f3n de la forma en que el SQL ha llegado a ser el lenguaje est\u00e1ndar de las bases de datos relacionales: 1)Al principio de los a\u00f1os setenta, los laboratorios de investigaci\u00f3n Santa Te - resa de IBM empezaron a trabajar en el pr oyecto System R. El objetivo de este proyecto era implementar un prototipo de SGBD relaci onal; por lo tanto, tam - bi\u00e9n necesitaban investigar en el campo de los lenguajes de bases de datos rela - cionales. A mediados de los a\u00f1os setenta, el proyecto de IBM dio como resultado un primer lenguaje denominado SEQUEL ( Structured English Query Language ), que por razones legales se denomin\u00f3 m\u00e1s adelante SQL (Structured Query Language ). Al final de la d\u00e9cada de los setenta y al principio de la de los ochenta, una vez finalizado el proyecto Syst em R, IBM y otras empresas empezaron a utilizar el SQL en sus SGBD relacionales, con lo qu e este lenguaje adquiri\u00f3 una gran po - pularidad. 2)En 1982, ANSI ( American National Standards Institute ) encarg\u00f3 a uno de sus co - mit\u00e9s (X3H2) la definici\u00f3n de un lenguaje de bases de datos relacionales. Este co - mit\u00e9, despu\u00e9s de evaluar diferentes lenguajes, y ante la aceptaci\u00f3n comercial del SQL, eligi\u00f3 un lenguaje es t\u00e1ndar que estaba basado en \u00e9ste pr\u00e1cticamente en su totalidad. El SQL se convirti\u00f3 oficialmente en el lenguaje est\u00e1ndar de ANSI en el a\u00f1o 1986, y de ISO ( International Standards Organization ) en 1987. Tambi\u00e9n ha sido adoptado como lenguaje est\u00e1ndar por FIPS ( Federal Information Processing Standard ), Unix X/Open y SAA ( Systems Application Architecture ) de IBM. 3)En el a\u00f1o 1989, el est\u00e1ndar fue objeto de una revisi\u00f3n y una ampliaci\u00f3n que dieron lugar al lenguaje que se conoce con el nombre de SQL1 o SQL89. En el a\u00f1o 1992 el est\u00e1ndar volvi\u00f3 a se r revisado y ampliado considerablemente para cubrir carencias de la versi\u00f3n ante rior. Esta nueva versi\u00f3n del SQL, que se conoce con el nombre de SQL2 o SQL92 , es la que nosotros presentaremos en esta unidad did\u00e1ctica. Como veremos m\u00e1s adelante, aunque aparezca s\u00f3lo la sigla SQL, siempre nos estaremos refiriendo al SQL92, ya que \u00e9ste tiene como subconjunto el SQL89; Recordad que el \u00e1lgebra relacional, que hemos visto en la unidad \"El modelo relacional y el \u00e1lgebra relacional\", es un lenguaje procedimental. FUOC 71Z799014MO 6 El lenguaje SQL por lo tanto, todo lo que era v\u00e1lido en el caso del SQL89 lo continuar\u00e1 siendo en el SQL92. De hecho, se pueden distinguir tres niveles dentro del SQL92: 1)El nivel introductorio (entry ), que incluye el SQL89 y las definiciones de clave primaria y clave for\u00e1nea al crear una tabla. 2)El nivel intermedio ( intermediate ), que, adem\u00e1s del SQL89, a\u00f1ade algu - nas ampliaciones del SQL92. 3)El nivel completo ( full), que ya tiene todas las ampliaciones del SQL92. El modelo relacional tiene como estructura de almacenamiento de los datos las relaciones. La intensi\u00f3 n o esquema de una relaci\u00f3n consiste en el nombre que hemos dado a la relaci\u00f3n y un conjunto de atributos. La extensi\u00f3n de una relaci\u00f3n es un conjunto de tuplas. Al trabajar con SQL, esta nomenclatura cambia, como podemos apreciar en la siguiente figura: H a b l a r e m o s d e tablas en lugar de relaciones. H a b l a r e m o s d e columnas en lugar de atributos. H a b l a r e m o s d e filas en lugar de tuplas. Sin embargo, a pesar de que la nomenc latura utilizada sea diferente, los con - ceptos son los mismos. Con el SQL se puede definir, manipular y controlar una base de datos relacio - nal. A continuaci\u00f3n veremos, aunque s\u00f3lo en un nivel introductorio, c\u00f3mo se pueden realizar estas acciones: El concepto de clave primaria y su importancia en una relaci\u00f3n o tabla se ha visto en la unidad \"El modelo relacional y el \u00e1lgebra relacional\" de este curso. El modelo relacional se ha presentado en la unidad \"El modelo relacional y el \u00e1lgebra relacional\" de este curso. FUOC 71Z799014MO 7 El lenguaje SQL 1)Ser\u00eda necesario crear una tabla que cont uviese los datos de los productos de nuestra empresa: 2)Insertar un producto en la tabla creada anteriormente: 3)Consultar qu\u00e9 productos de nuestra empresa son sillas: 4)Dejar acceder a uno de nuestros vended ores a la informaci\u00f3n de la tabla productos : Y muchas m\u00e1s cosas que iremos viendo punto por punto en los siguientes apartados. Fij\u00e9monos en la estructura de todo lo que hemos hecho hasta ahora con SQL. Las operaciones de SQL reciben el nombre de sentencias y est\u00e1n formadas por CREATE productos WHERE tipo = 'Silla'; GRANT SELECT ON productos TO jmontserrat;Nombre de la tabla Nombre de las columnas y tipo Clave primaria Nombre de la tabla Valores de la fila Columnas seleccionadas Filas seleccionadasTabla Hacer consultas Usuario Nombre de la tabla FUOC 71Z799014MO 8 El lenguaje SQL diferentes partes que denominamos cl\u00e1usulas , tal y como podemos apreciar en el siguiente ejemplo: Esta consulta muestra el c\u00f3digo, el nombre y el tipo de los productos que cues - tan m\u00e1s de 1.000 euros. Los tres primeros apartados de este m\u00f3dulo tratan sobre un tipo de SQL deno - minado SQL interactivo , que permite acceder directamente a una base de da - tos relacional: a)En el primer apartado definiremos las denominadas sentencias de defini - ci\u00f3n, donde crearemos la base de datos, las tablas que la compondr\u00e1n y los do - minios, las aserciones y las vistas que queramos. b)En el segundo aprenderemos a manipular la base de datos, ya sea introdu - ciendo, modificando o borra ndo valores en las filas de las tablas, o bien ha - ciendo consultas. c)En el tercero veremos las sentencias de control, que aseguran un buen uso de la base de datos. Sin embargo, muchas veces querremos acceder a la base de datos desde una aplicaci\u00f3n hecha en un le nguaje de programaci\u00f3n cualquiera, que nos ofrece mucha m\u00e1s potencia fuera del entorno de las bases de datos. Para utilizar SQL desde un lenguaje de prog ramaci\u00f3n necesitaremos se ntencias especiales que nos permitan distinguir entre las instru cciones del lenguaje de programaci\u00f3n y las sentencias de SQL. La idea es que trabajando b\u00e1sicamente con un lengua - je de programaci\u00f3n anfitri\u00f3n se puede cobijar SQL como si fuese un hu\u00e9sped. Por este motivo, este tipo de SQL se conoce con el nombre de SQL hospeda - do. Para trabajar con SQL hospedado necesitamos un precompilador que se - pare las sentencias del lenguaje de prog ramaci\u00f3n de las del lenguaje de bases de datos. Una alternativa a es ta forma de trabajar son las rutinas SQL/CLI* (SQL/Call-Level Interface ), que resolviendo tambi\u00e9n el problema de acceder a SQL desde un lenguaje de programa ci\u00f3n, no necesitan precompilador. Antes de empezar a conocer el lenguaje, es necesario a\u00f1adir un \u00faltimo comen - tario. Aunque SQL es el lenguaje est\u00e1ndar para bases de datos relacionales y ha sido ampliamente aceptado por los sistem as relacionales co merciales, no ha sido capaz de reflejar toda la teor\u00eda de l modelo relacional establecida por E.F. Codd; esto lo iremos viendo a medida que profundicemos en el lenguaje.SELECT codigo_producto, nombre_producto, tipo FROM productos WHERE precio > 1000; Introduciremos SQL hospedado y el concepto de SQL/CLI en el apartado 4 de esta unidad did\u00e1ctica. * Las rutinas SQL/CLI se a\u00f1adieron al est\u00e1ndar SQL92 en 1995. Encontrar\u00e9is la teor\u00eda del modelo relacional de E.F. Codd en la unidad \"El modelo relacional y el \u00e1lgebra relacional\" de este curso. SentenciaCl\u00e1usula Cl\u00e1usula Cl\u00e1usula FUOC 71Z799014MO 9 El lenguaje SQL Los sistemas relacionales comerciales y los investigadores de bases de datos son una referencia muy impo rtante para mantener el est\u00e1ndar actualizado. En estos momentos ya se dispone de una nueva versi\u00f3n de SQL92 que se denomi - na SQL: 1999 o SQL3. SQL: 1999 tiene a SQL92 como subconjunto, e incorpora nuevas prestaciones de gran inter\u00e9s. En inform\u00e1tica, en general, y particular - mente en bases de datos, es necesario estar siempre al d\u00eda, y por eso es muy im - portante tener el h\u00e1bito de leer publicaciones peri\u00f3dicas que nos informen y nos mantengan al corriente de las novedades. FUOC 71Z799014MO 10 El lenguaje SQL Objetivos Una vez finalizado el estudio de los ma teriales did\u00e1cticos de esta unidad, dispondr\u00e9is de las herramientas indispen sables para alcanzar los siguientes objetivos: 1.Conocer el lenguaje est\u00e1ndar ANSI/ISO SQL92. 2.Definir una base de datos relacional , incluyendo domini os, aserciones y vistas. 3.Saber introducir, borra r y modificar datos. 4.Ser capaz de plantear cualquier tipo de consulta a la base de datos. 5.Saber utilizar senten cias de control. 6.Conocer los principios b\u00e1sicos de la utilizaci\u00f3n del SQL desde un lenguaje de programaci\u00f3n. FUOC 71Z799014MO 11 El lenguaje SQL 1. Sentencias de definici\u00f3n Para poder trabajar con bases de datos relacionales, lo primero que tenemos que hacer es definirlas. Veremos las \u00f3r denes del est\u00e1ndar SQL92 para crear y borrar una base de datos re lacional y para insertar, borrar y modificar las dife - rentes tablas que la componen. En este apartado tambi\u00e9n veremos c\u00f3mo se definen los dominios, las asercio - nes (restricciones) y las vistas. La sencillez y la homogene idad del SQL92 hacen que: 1)Para crear bases de datos, tablas, domi nios, aserciones y vistas se utilice la sentencia CREATE . 2)Para modificar tablas y dominios se utilice la sentencia ALTER . 3)Para borrar bases de datos, tablas, dominios, aserci ones y vistas se utilice la sentencia DROP . La adecuaci\u00f3n de estas sentencias a cada caso nos dar\u00e1 diferencias que iremos perfilando al hacer la descripci\u00f3n individual de cada una. Para ilustrar la aplicaci\u00f3n de las sentencias de SQL que veremos, utilizaremos una base de datos de ejemplo muy sencilla de una peque\u00f1a empresa con sede en Barcelona, Girona, Lleida y Tarrago na, que se encarga de desarrollar pro - yectos inform\u00e1ticos. La in formaci\u00f3n que nos interesar\u00e1 almacenar de esta em - presa, que denominaremos BDUOC , ser\u00e1 la siguiente: 1)Sobre los empleados que trab ajan en la empresa, qu erremos saber su c\u00f3digo de empleado, el nombre y ap ellido, el sueldo, el nomb re y la ciudad de su de - partamento y el n\u00famero de proyecto al que est\u00e1n asignados. 2)Sobre los diferentes departamentos en lo s que est\u00e1 estructurada la empresa, nos interesa conocer su no mbre, la ciudad donde se encuentran y el tel\u00e9fono. Ser\u00e1 necesario tener en cuenta que un departamento con el mismo nombre puede estar en ciudades diferentes, y que en una misma ciudad puede haber departamentos con no mbres diferentes. 3)Sobre los proyectos inform \u00e1ticos que se desarrollan, querremos saber su c\u00f3 - digo, el nombre, el precio, la fecha de in icio, la fecha previs ta de finalizaci\u00f3n, la fecha real de finalizaci\u00f3n y el c\u00f3di go de cliente para quien se desarrolla. 4)Sobre los clientes para quien trabaja la empresa, querremos saber el c\u00f3digo de cliente, el nombre, el NIF, la direcci\u00f3n, la ciudad y el tel\u00e9fono.Vistas Una vista en el modelo relacio- nal no es sino una tabla virtual derivada de las tablas reales de nuestra base de datos, un es-quema externo puede ser un conjunto de vistas. FUOC 71Z799014MO 12 El lenguaje SQL 1.1. Creaci\u00f3n y borrado de una base de datos relacional El est\u00e1ndar SQL92 no dispone de ninguna sentencia de creaci\u00f3n de bases de datos. La idea es que una base de datos no es m\u00e1s que un conjunto de tablas y, por lo tanto, las senten cias que nos ofrece el SQL92 se concentran en la crea - ci\u00f3n, la modificaci\u00f3n y el borrado de estas tablas. En cambio, disponemos de una sentencia m\u00e1 s potente que la de creaci\u00f3n de bases de datos: la sentencia de creaci\u00f3n de esquemas denominada CREATE SCHEMA . Con la creaci\u00f3n de esquemas podemos ag rupar un conjunto de elementos de la base de datos que son propiedad de un usuario. La sintaxis de esta sentencia es la que ten\u00e9is a continuaci\u00f3n: La nomenclatura utilizada en la sentencia es la siguiente: Las palabras en negrita son palabras reservadas del lenguaje: La notaci\u00f3n [...] quiere decir que lo que hay entre los corchetes se podr\u00eda poner o no. L a n o t a c i \u00f3 n {A| ... |B} quiere decir que tenemos que elegir entre todas las opciones que hay entre las llaves, pe ro debemos poner una obligatoriamente. La sentencia de creaci\u00f3n de esquemas hace que varias tablas ( lista_de_ele- mentos_del_esquema ) se puedan agrupar ba jo un mismo nombre ( nom- bre_esquema ) y que tengan un propietario ( usuario ). Aunque todos los par\u00e1 - metros de la sentencia CREATE SCHEMA son opcionales, como m\u00ednimo se debe dar o bien el nombre del es quema, o bien el nombre del usuario propietario de la base de datos. Si s\u00f3lo especificamos el usuario, \u00e9ste ser\u00e1 el nombre del esquema. La creaci\u00f3n de esquemas puede hacer mucho m\u00e1s qu e agrupar tablas, porque lista_de_elementos_del_esquema puede, adem\u00e1s de tablas, ser tambi\u00e9n dominios, vistas, privilegios y re stricciones, entre otras cosas. Para borrar una base de datos encontramos el mismo problema que para crear - la. El est\u00e1ndar SQL92 s\u00f3lo nos ofrece la sentencia de borrado de esquemas DROP SCHEMA , que presenta la DATABASE Muchos de los sistemas relacionales comerciales (como ocurre en el caso de Informix, DB2, SQL Server y otros) han incorporado sentencias de creaci\u00f3n de bases de datos con la siguiente sintaxis: CREATE DATABASE La sentencia DROP DATABASE Muchos de los sistemas relacionales comerciales (como por ejemplo Informix, DB2, SQL Server y otros) han incorporado sentencias de borrado de bases de datos con la siguiente sintaxis: DROP DATABASE FUOC 71Z799014MO 13 El lenguaje SQL Donde tenemos lo siguiente: La opci\u00f3n de borrado de esquemas RESTRICT hace que el esquema s\u00f3lo se pueda borrar si no contiene ning\u00fan elemento. L a o p c i \u00f3 n CASCADE borra el esquema aunque no est\u00e9 completamente vac\u00edo. 1.2. Creaci\u00f3n de tablas Como ya hemos visto, la estructura de almacenamiento de los datos del mo - delo relacional so n las tablas. Para crear una tabla , es necesario utilizar la sen- su formato: Donde definici\u00f3n_columna es: El proceso que hay que seguir para crear una tabla es el siguiente: 1)Lo primero que tenemos que hacer es decidir qu\u00e9 nombre queremos poner a la tabla ( nombre_tabla ). 2)Despu\u00e9s, iremos dando el nombre de cada uno de los atributos que forma - r\u00e1n las columnas de la tabla ( nombre_columna ). 3)A cada una de las columnas le asignaremos un tipo de datos predefinido o bien un dominio definido por el usuario. Tambi\u00e9n podremos dar definiciones por defecto y restricciones de columna. 4)Una vez definidas las columnas, s\u00f3lo nos quedar\u00e1 dar las restricciones de tabla. 1.2.1. Tipos de datos Para cada columna tenemos que elegir entre al g\u00fan dominio definido por el usua - rio o alguno de los tipos de datos predef inidos que se describen [restric_col] Tipos de datos predefinidos Tipos de datos Descripci\u00f3n CHARACTER (longitud) Cadenas de caracteres de longitud fija. CHARACTER VARYING (longitud) Cadenas de caracteres de longitud variable.Recordad que las tablas se han estudiado en la unidad \"El modelo relacional y el \u00e1lgebra relacional\" de este curso. Recordad que las correspondencias entre los tipos de datos y los dominios predefinidos del modelo relacional se han visto en el subapartado 2.2 de la unidad \"El modelo relacional y el \u00e1lgebra relacional\" de este curso. FUOC 71Z799014MO 14 El lenguaje SQL Ejemplos de asignaciones de columnas Veamos algunos ejemplos de asignaciones de columnas en los tipos de datos predefinidos DATE , TIME y TIMESTAMP : La columna fecha_nacimiento podr\u00eda ser del tipo DATE y podr\u00eda tener como valor '1978-12-25'. La columna inicio_partido podr\u00eda ser del tipo TIME y podr\u00eda tener como valor '17:15:00.000000'. L a c o l u m n a entrada_trabajo podr\u00eda ser de tipo TIMESTAMP y podr\u00eda tener como valor '1998-7-8 9:30:05'. 1.2.2. Creaci\u00f3n, modificaci\u00f3n y borrado de dominios Adem\u00e1s de los dominios dados por el tipo de datos predefinidos, el SQL92 nos ofrece la posibilidad de trabajar con dominios definidos por el usuario. Para crear un dominio es necesario utiliz ar la sentencia CREATE DOMAIN : donde restricciones_dominio tiene el siguiente formato:Tipos de datos predefinidos Tipos de datos Descripci\u00f3n BIT (longitud) Cadenas de bits de longitud fija. BIT VARYING (longitud) Cadenas de bits de longitud variables. NUMERIC (precisi\u00f3n, escala)N\u00famero decimales con tantos d\u00edgitos como indique la precisi\u00f3n y tantos decimales como indique la escala. DECIMAL (precisi\u00f3n, escala)N\u00famero decimales con tantos d\u00edgitos como indique la precisi\u00f3n y tantos decimales como indique la escala. INTEGER N\u00fameros enteros. SMALLINT N\u00fameros enteros peque\u00f1os. REALN\u00fameros con coma flotante con precisi\u00f3n predefinida. FLOAT (precisi\u00f3n)N\u00fameros con coma flotante con la precisi\u00f3n especificada. DOUBLE PRECISIONN\u00fameros con coma flotante con m\u00e1s precisi\u00f3n predefinida que la del tipo REAL . DATEFechas. Est\u00e1n compuestas de: YEAR a\u00f1o, MONTH mes, DAY d\u00eda . TIMEHoras. Est\u00e1n compuestas de HOUR hora, MINUT minutos, SECOND segundos . TIMESTAMPFechas y horas. Est\u00e1n compuestas de YEAR a\u00f1o, MONTH mes, DAY d\u00eda, HOUR hora, MINUT minutos, SECOND segundos DECIMAL NUMERIC y DECIMAL se descri- ben igual, y es posible utilizar tanto el uno como el otro para definir n\u00fameros decimales. El tratamiento del tiempo El est\u00e1ndar SQL92 define la siguiente nomenclatura para trabajar con el De todos modos, los sistemas relacionales comerciales disponen de diferentes formatos, entre los cuales podemos elegir cuando tenemos que trabajar con columnas temporales. Dominios definidos por el usuario Aunque el SQL92 nos ofrece la sentencia CREATE DOMAIN , hay pocos sistemas relaciona-les comerciales que nos permitan utilizarla. Explicaremos la construcci\u00f3n de condiciones m\u00e1s adelante, en el subapartado 2.5 cuando hablemos de c\u00f3mo se hacen consultas a una base de datos. Veremos def_defecto en el subapartado 1.2.3 de esta unidad. FUOC 71Z799014MO 15 El lenguaje SQL Creaci\u00f3n de un dominio en BDUOC Si quisi\u00e9ramos definir un dominio para las ci udades donde se encuentran los departamentos de la empresa BDUOC, har\u00edamos: De este modo, cuando definimos la columna ciudades dentro de la tabla departamentos no se tendr\u00e1 que decir que es de tipo CHAR (20) , sino de tipo dom_ciudades . Esto nos de - ber\u00eda asegurar, seg\u00fan el modelo relacional, que s\u00f3lo haremos operaciones sobre la columna ciudades con otras columnas que tengan este mism o dominio definido po r el usuario; sin embargo, el SQL92 no nos ofrece herramientas para asegurar que las comparaciones que ha - cemos sean entre los mismos dominios definidos por el usuario. Por ejemplo, si tenemos una columna con los nombres de los empleado s definida sobre el tipo de datos CHAR (20) , el SQL nos permite compararla con la columna ciudades , aunque sem\u00e1nticamente no tenga sentido. En cambio, seg\u00fan el modelo relacional, esta comparaci\u00f3n no se deber\u00eda haber permitido. Para borrar un domi nio definido po r el usuario es preciso utilizar la senten - cia DROP DOMAIN , que tiene este formato: En este caso, tenemos que: La opci\u00f3n de borrado de dominios RESTRICT hace que el dominio s\u00f3lo se pueda borrar si no se utiliza en ning\u00fan sitio. L a o p c i \u00f3 n CASCADE borra el dominio aunque est\u00e9 referenciado, y pone el tipo de datos del domini o all\u00ed donde se utilizaba. Borrar un dominio de BDUOC Si quisi\u00e9ramos borrar el dominio que hemos cr eado antes para las ci udades donde se encuen - tran los departamentos de la empresa BDUOC, har\u00edamos: En este caso nos deber\u00edamos asegurar de que ninguna columna est\u00e1 definida sobre dom_ciu- dades antes de borrar el dominio. Para modificar un dominio sem\u00e1ntico es necesario utilizar la sentencia ALTER DOMAIN . Veamos su formato:CREATE DOMAIN acci\u00f3n_modif_restricci\u00f3n_dominio}; FUOC lo siguiente: acci\u00f3n_modificar_dominio puede ser: acci\u00f3n_modif_restricci\u00f3n_dominio puede ser: Modificar un dominio en BDUOC Si quisi\u00e9ramos a\u00f1adir una nuev a ciudad (Matar\u00f3) al dominio que hemos creado antes para las ciudades donde se encuentran los depa rtamentos de la empresa BDUOC, har\u00edamos: Con esto hemos eliminado la restricci\u00f3n de dominio antigua. Y ahora tenemos que introdu - cir la nueva restricci\u00f3n: 1.2.3. Definicion es por defecto Ya hemos visto en otros m\u00f3dulos la importancia de los valores nulos y su inevi - table aparici\u00f3n como valores de las bases de datos. La opci\u00f3n def_defecto nos permite espe cificar qu\u00e9 nomenclatura queremos dar a nuestros va lores por omisi\u00f3n. Por ejemplo, para un empleado que todav\u00eda no se ha decidido cu\u00e1nto ganar\u00e1, podemos elegir que, de momento, tenga un sueldo de 0 euros ( DEFAULT 0.0 ), o bien que tenga un sueldo con un valor nulo ( DEFAULT NULL ). Sin embargo, hay que tener en cuenta que si elegimos la opci\u00f3n DEFAULT NULL , la columna para la que daremos la definici\u00f3n po r defecto de valor nulo deber\u00eda admitir valores nulos. La opci\u00f3n DEFAULT tiene el siguiente formato:{SET def_defecto |DROP El lenguaje SQL La posibilidad m\u00e1s ut ilizada y la opci\u00f3n por defect o, si no especificamos nada, es la palabra reservada NULL . Sin embargo, tambi\u00e9n podemos definir nuestro propio literal, o bien recurrir a una de las funciones que aparecen en la tabla siguiente: 1.2.4. Restricciones de columna En cada una de las columnas de la tabl a, una vez les hemos dado un nombre y hemos definido su dominio, podemos imponer ciertas restricciones que siem - pre se tendr\u00e1n que cumplir. Las restricciones que se pueden dar son las que apa - recen en la tabla que tenemos a continuaci\u00f3n: 1.2.5. Restricciones de tabla Una vez hemos dado un nombre, hemos de finido una tabla y hemos impuesto ciertas restricciones para cada una de las columnas, podemos aplicar restriccio - nes sobre toda la tabla, que siempre se deber\u00e1n cumplir. Las restricciones que se pueden dar son las siguientes:Funci\u00f3n Descripci\u00f3n {USER |CURRENT_USER} Identificador del usuario actual SESSION_USER Identificador del usuario de esta sesi\u00f3n SYSTEM_USER Identificador del usuario del sistema operativo CURRENT_DATE Fecha actual CURRENT_TIME Hora actual CURRENT_TIMESTAMP Fecha y hora actuales Restricciones de columna Restricci\u00f3n Descripci\u00f3n NOT NULL La columna no puede tener valores nulos. UNIQUELa columna no puede tener valores repetidos. Es una clave alternativa. PRIMARY KEYLa columna no puede tener va lores repetidos ni nulos. Es la clave primaria. REFERENCES tabla [(columna)]La columna es la clave for\u00e1nea de la columna de la tabla especificada. CHECK (condiciones) La columna debe cumplir las condiciones especificadas. Restricciones de tabla Restricci\u00f3n Descripci\u00f3n UNIQUE (columna [, columna . . .])El conjunto de las colu mnas especificadas no puede tener valores repetidos. Es una clave alternativa. FUOC 71Z799014MO 18 El lenguaje SQL 1.2.6. Modificaci\u00f3n y borrado de claves primarias con claves for\u00e1neas que hacen referencia a \u00e9stas En otra unidad de este curso hemos vist o tres pol\u00edticas aplicables a los casos de borrado y modificaci\u00f3n de filas que tien en una clave primaria referenciada por claves for\u00e1neas. Estas pol\u00edticas eran la restricci\u00f3n, la actu alizaci\u00f3n en cascada y la anulaci\u00f3n. El SQL nos ofrece la posibilidad de especi ficar, al definir un a clave for\u00e1nea, qu\u00e9 pol\u00edtica queremos seguir . Veamos su formato: Donde una de las restricciones de tabla era la definici\u00f3n de claves for\u00e1neas, que tiene el siguiente formato: Donde NO ACTION corresponde a la pol\u00edtica de restricci\u00f3n; CASCADE , a la actua - lizaci\u00f3n en cascada, y SET NULL ser\u00eda la anulaci\u00f3n. SET DEFAULT se podr\u00eda con - siderar una variante de SET NULL , donde en lugar de valores nulos se puede poner el valor especificado por defecto.Restricciones de tabla Restricci\u00f3n Descripci\u00f3n PRIMARY KEY (columna [, columna . . .])El conjunto de las co lumnas especificadas no puede tener valores nulos ni repetidos. Es una clave primaria. FOREIGN KEY (columna [, columna . colu mnas especificadas es una clave for\u00e1nea que referencia la clave primaria formada por el conjunto de las columnas2 de la tabla dada. Si las columnas y las columnas2 se de nominan exactamente igual, entonces no ser\u00eda necesario poner columnas2. CHECK (condiciones)La tabla debe cumplir [ON DELETE SET DEFAULT | SET NULL}] [ON UPDATE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]Para recordar las pol\u00edticas que se pueden aplicar a los casos de borrado y modificaci\u00f3n de las filas, consultad los subapartados 4.3.1, 4.3.2 y 4.3.3 de la unidad \"El modelo relacional y el \u00e1lgebra relacional\" de este curso. FUOC 71Z799014MO 19 El lenguaje SQL 1.2.7. Aserciones Una aserci\u00f3n es una restricci\u00f3n genera l que hace referencia a una o m\u00e1s co - lumnas de m\u00e1s de una tabla. Para definir una aserci\u00f3n se utiliza la sentencia CREATE ASSERTION , y tiene el siguiente formato: Crear una aserci\u00f3n en BDUOC Creamos una aserci\u00f3n sobre la base de dato s BDUOC que nos asegure que no hay ning\u00fan empleado con un sueldo superior a 80.000 asignado al proyecto SALSA: Para borrar una aserci\u00f3n es necesario utilizar la sentencia DROP ASSERTION , que presenta este formato: Borrar una aserci\u00f3n en Por ejemplo, para borrar la aserci\u00f3n restriccion1 , utilizar\u00edamos la sentencia DROP ASSERTION de la forma siguiente: 1.3. Modificaci\u00f3n y borrado de tablas Para modificar una tabla es preciso utilizar la sentencia ALTER TABLE . Vea empleados e WHERE p.codigo_proyec = = e.num_proyec and e.sueldo > 8.0E+4 caso, tenemos que: acci\u00f3n_modificar_columna puede ser: acci\u00f3n_modif_restricci\u00f3n_tabla puede ser: Si queremos modificar una tabla es que qu eremos realizar una de las siguientes operaciones: 1)A\u00f1adirle una columna ( ADD columna ). 2)Modificar las definiciones po r defecto de la columna ( ALTER columna ). 3)Borrar la columna ( DROP columna ). 4)A\u00f1adir alguna nueva restricci\u00f3n de tabla ( ADD restricci\u00f3n ). 5)Borrar alguna restricci\u00f3n de tabla ( DROPCONSTRAINT restricci\u00f3n ). Para borrar una tabla es preciso utilizar la sentencia DROP TABLE : En este caso tenemos que: Si utilizamos la opci\u00f3n RESTRICT , la tabla no se borrar\u00e1 si est\u00e1 referencia - da, por ejemplo, por alguna vista. Si usamos la opci\u00f3n CASCADE , todo lo que referencie a la tabla se borrar\u00e1 con \u00e9sta. 1.4. Creaci\u00f3n y borrado de vistas Como hemos observado, la arquitectura ANSI/SPARC distingue tres niveles, que se describen en el esquema conceptual , el esquema interno y los esquemas ex - ternos. Hasta ahora, mientras cre\u00e1bamos la s tablas de la base de datos, \u00edbamos {ADD [COLUMN] columna def_columna | ALTER [COLUMN] columna { SET DROP [COLUMN columna { TABLE nombre_tabla { RESTRICT |CASCADE}; Los tres niveles de la arquitectura ANSI/SPARC se han estudiado en el subapartado 4.1 de la unidad \"Introducci\u00f3n a las bases de datos\" de este curso. FUOC 71Z799014MO 21 El lenguaje SQL describiendo el esquema co nceptual. Para describir los diferentes esquemas ex - ternos utilizamos el concepto de vista del SQL. Para crear una vista es necesario utilizar la sentencia CREATE VIEW . Veamos su formato: Lo primero que tene mos que hacer para crear una vista es decidir qu\u00e9 nombre le queremos poner ( nombre_vista ). Si queremos cambia r el nombre de las columnas, o bien poner nombre a alguna que en principio no ten\u00eda, lo pode - mos hacer en lista_columnas . Y ya s\u00f3lo nos quedar\u00e1 definir la consulta que formar\u00e1 nuestra vista. Las vistas no existen realmente como un conjunto de valores almacenados en la base de datos, sino que son tablas ficticias, denominadas derivadas (no materializadas). Se construyen a partir de tablas reales (materializadas) alma - cenadas en la base de datos, y conocidas con el nombre de tablas b\u00e1sicas (o tablas de base). La no-existencia real de las vistas hace que puedan ser actua - lizables o no. Creaci\u00f3n de una vista en BDUOC Creamos una vista sobre la base de datos BDUOC que nos d\u00e9 para cada cliente el n\u00famero de proyectos que tiene encargados el cliente en cuesti\u00f3n. Si tuvi\u00e9semos las siguientes extensiones: T a b l a clientes : T a b l a proyectos :CREATE VIEW nombre_vista p.codigo_cliente c.codigo_cli GROUP BY c.codigo_cli); ciudad Arag\u00f3n Barcelona NULL CME 38.123.898-E Valencia 22 Girona 972.23.57.21 30 ACME 36.432.127-A Mallorca 33 Lleida 973.23.45.67Por lo que respecta a la construcci\u00f3n de consultas, consultad el subapartado 2.5 de esta FUOC 71Z799014MO 22 El lenguaje mir\u00e1semos la extensi\u00f3n de la vista proyectos_por_clientes , ver\u00edamos lo que encon - tramos en el margen. En las vistas, adem\u00e1s de hacer consulta s, podemos insertar, modificar y borrar filas. Actualizaci\u00f3n de vistas en BDUOC Si alguien insertase en la vista proyectos_por_cliente , los valores para un nuevo cliente 60 con tres proyectos encargados, encontrar\u00edam os que estos tres proyectos tendr\u00edan que fi - gurar realmente en la tabla proyectos y, por lo tanto, el SGBD los deber\u00eda insertar con la informaci\u00f3n que tenemos, que es pr\u00e1cticamente inexistente. Veamos gr\u00e1ficamente c\u00f3mo quedar\u00edan las tablas despu\u00e9s de esta hipot\u00e9tica actualizaci\u00f3n, que no llegaremos a hacer nun - ca, ya que ir\u00eda en contra de la teor\u00eda del modelo relacional: T a b l a clientes T a b l a p r o y e c t o s : El SGBD no puede actual izar la tabla b\u00e1sica clientes si s\u00f3lo sabe la clave primaria, y todav\u00eda menos la tabla b\u00e1sica proyectos sin la clave primaria; por lo tanto, esta vista no ser\u00eda actualizable. En cambio, si definimos una vista para saber los clientes que tenemos en Barcelona o en Gi - rona, har\u00edamos:proyectos ECIGSA 38.567.893-C Arag\u00f3n Barcelona NULL CME 38.123.898-E Valencia 22 Girona 972.23.57.21 30 ACME 36.432.127-A Mallorca 33 Lleida 973.23.45.67 60 NULL NULL NULL NULL NULLproyectos_por_clientes codigo_cli numero_proyectos 10 3 SALSA 1,0E+6 10-2-98 1-2-99 NULL 20 NULL NULL NULL NULL NULL NULL 60 NULL NULL NULL NULL NULL NULL 60 NULL NULL NULL NULL NULL NULL 60 CREATE VIEW clientes_Barcelona_Girona AS (SELECT * FROM WHITH CHECK OPTION; FUOC 71Z799014MO 23 El lenguaje SQL Si queremos asegurarnos de que se cumpla la condici\u00f3n de la cl\u00e1usula WHERE , debemos poner la opci\u00f3n WHITH CHECK OPTION . Si no lo hici\u00e9semos, podr\u00eda ocurrir que alguien incluyese en la vista clientes_Barcelona_Girona a un cliente nuevo con el c\u00f3digo 70, de nombre JMB, con el NIF 36.788.224-C, la direcci\u00f3n en NULL, la ciudad Lleida y el tel\u00e9fono NULL. Si consult\u00e1semos la extensi\u00f3n de la vista clientes_Barcelona_Girona , ver\u00edamos: Esta vista s\u00ed podr\u00eda ser actual izable. Podr\u00edamos insertar un nu evo cliente con c\u00f3digo 50, de nombre CEA, con el NIF 38.226.777-D, con la dire cci\u00f3n Par\u00eds 44, la ciudad Barcelona y el te - l\u00e9fono 93.422.60.77. Despu\u00e9s de esta actualizaci\u00f3n, en la tabla b\u00e1sica clientes encontra - r\u00edamos, efectivamente: Para borrar una vista es preciso utilizar la sentencia DROP VIEW , que presenta el formato: Si utilizamos la opci\u00f3n RESTRICT , la vista no se borrar\u00e1 si est\u00e1 referenciada, por ejemplo, por otra vista. En cambio, si ponemos la opci\u00f3n CASCADE , todo lo que referencie a la vi sta se borrar\u00e1 con \u00e9sta. Borrar una vista en BDUOC Para borrar la vista clientes_Barcelona_Girona , har\u00edamos lo siguiente: 1.5. Definici\u00f3n de la base de datos relacional BDUOC Veamos c\u00f3mo se crear\u00eda la base de datos BDUOC, ut ilizando, por ejemplo, un SGBD relacional que disponga de la sentencia CREATE DATABASE Barcelona NULL CME Valencia Girona 972.23.57.21 ciudad telefono Arag\u00f3n Barcelona NULL CME 38.123.898-E Valencia 22 Girona 972.23.57.21 30 ACME 36.432.127-A Mallorca 33 Lleida 973.23.45.67 50 CEA Barcelona 93.442.60.77 de creaci\u00f3n Antes de crear una tabla con una o m\u00e1s claves for\u00e1neas, se deben haber creado las tablas que tienen como clave primaria las referenciadas por las for\u00e1neas. FUOC 71Z799014MO 24 El lenguaje SQL COMMIT ;* Tenemos que elegir restricci\u00f3n de tabla porque la clave primaria est\u00e1 compuesta por m\u00e1s de un atributo. La sentencia COMMIT se explica en el subapartado 3.1 de esta unidad did\u00e1ctica. FUOC 71Z799014MO 25 El lenguaje SQL Al crear una tabla vemos que muchas re stricciones se pueden imponer de dos formas: como restricciones de columna o como restricciones de tabla. Por ejem - plo, cuando queremos decir cu\u00e1l es la clave primaria de una tabla, tenemos las dos posibilidades. Esto se de be a la flexibilidad del SQL: En el caso de que la restricci\u00f3n haga referencia a un solo atributo, podemos elegir la posibilidad que m\u00e1s nos guste. En el caso de la tabla departamentos , tenemos que elegir por fuerza la op - ci\u00f3n de restricciones de tabla, porque la clave primaria est\u00e1 compuesta por m\u00e1s de un atributo. En general, lo pondremos todo como restricciones de tabla, excepto NOT NULL y CHECK cuando haga referencia a una sola columna. FUOC 71Z799014MO 26 El lenguaje SQL 2. Sentencias de manipulaci\u00f3n Una vez creada la base de datos con sus tablas, debemos poder insertar, modi - ficar y borrar los valores de las filas de las tablas. Para poder hacer esto, el SQL92 nos ofrece las siguientes sentencias: INSERT para insertar, UPDATE para modificar y DELETE para borrar. Una vez hemos in sertado valores en nuestras tablas, tenemos que poder consultarlos. La sentencia para hacer consultas a una base de datos con el SQL92 es SELECT FROM . Veamos a continuaci\u00f3n estas sentencias. 2.1. Inserci\u00f3n de filas en una tabla Antes de poder consultar los datos de una base de datos, es preciso introdu - cirlos con la sentencia INSER TINTO VALUES , tiene el formato: Los valores v1, v2, ..., vn se deben corresponder ex actamente con las colum - nas que hemos dicho que tendr\u00edamos con el CREATE TABLE y deben estar en el mismo orden, a menos que las volv amos a poner a continuaci\u00f3n del nom - bre de la tabla. En este \u00faltimo caso, los valores se deben disponer de forma co - herente con el nuevo orden que hemos im puesto. Podr\u00eda darse el caso de que quisi\u00e9ramos que algunos valo res para insertar fuesen valores por omisi\u00f3n, de - finidos previamente con la opci\u00f3n DEFAULT . Entonces pondr\u00edamos la palabra reservada DEFAULT . Si se trata de introducir valores nulos, tambi\u00e9n podemos utilizar la pala bra reservada NULL . Inserci\u00f3n de una fila en BDUOC La forma de insertar a un cliente en la tabla clientes de la base de datos de BDUOC 'Barcelona'); Inserci\u00f3n de m\u00faltiples filas Para insertar m\u00e1s de una fila con una sola sentencia, tenemos que obtener los valores como resultado de una consulta realizada en una o m\u00e1s tablas. FUOC 71Z799014MO 27 El lenguaje SQL 2.2. Borrado de filas de una tabla Para borrar valores de algunas filas de una tabla podemos utilizar la senten - cia DELETE FROM WHERE . Su formato es el siguiente: En cambio, si lo que qu isi\u00e9ramos conseguir es borrar todas las filas de una tabla , entonces s\u00f3lo tendr\u00edamos que poner la sentencia DELETE FROM , sin WHERE . Borrar todas las filas de una tabla en BDUOC Podemos dejar la tabla proyectos sin ninguna fila: En nuestra base de datos, borrar los proyectos del cliente 2 se har\u00eda de la forma que mostra - mos a continuaci\u00f3n: 2.3. Modificaci\u00f3n de filas de una tabla Si quisi\u00e9ramos modificar los valores de al gunas filas de una tabla , tendr\u00edamos que utilizar la sentencia UPDATE SET WHERE . A continuaci\u00f3n presentamos su formato: Modificaci\u00f3n de los valores de algunas filas en BDUOC Supongamos que queremos incrementar el sueldo de todos los empleado s del proyecto 2 en 1.000 euros. La modificaci\u00f3n a ejecutar ser\u00eda:DELETE FROM nombre_tabla [WHERE condiciones]; DELETE FROM proyectos; DELETE FROM proyectos WHERE 2; UPDATE nombre_tabla SET columna = {expr |DEFAULT |NULL} ...] WHERE condiciones; UPDATE empleados SET sueldo = sueldo + 1000 WHERE num_proyec = 2;Borrado de m\u00faltiples filas Notemos que el cliente con el c\u00f3digo 2 podr\u00eda tener m\u00e1s de un proyecto contratado y, por lo tanto, se borrar\u00eda m\u00e1s de una fila con una sola sentencia. Modificaci\u00f3n de m\u00faltiples filas Notemos que el proyecto n\u00famero 2 podr\u00eda tener a m\u00e1s de un empleado asignado y, por lo tanto, se modificar\u00eda la columna sueldo , de m\u00e1s de una fila con una sola sentencia. FUOC 71Z799014MO 28 El lenguaje SQL 2.4. Introducci\u00f3n de filas en la base de datos relacional BDUOC Antes de empezar a hacer consultas a la base de datos BDUOC, habremos intro - ducido unas cuantas filas en sus tablas con la sentencia INSERT INTO . De esta forma, podremos ver reflejado el result ado de las consultas que iremos hacien - do, a partir de este momento, sobre cada extensi\u00f3n; esto lo podemos observar en las tablas correspondientes a cada extensi\u00f3n, que presentamos a continua - ci\u00f3n: T a b l a departamentos : T a b l a clientes : T a b l a empleados :departamentos nombre_dep ciudad_dep telefono DIR Barcelona 93.422.60.70 Arag\u00f3n Barcelona NULL CME 38.123.898-E Valencia 22 Girona 972.23.57.21 30 num_proyec 1 Puig 1,0E+5 DIR Girona 1 2 Pedro Mas 9,0E+4 DIR Barcelona 4 3 Ana Ros 7,0E+4 DIS Lleida 3 4 Jorge Roca 7,0E+4 DIS Barcelona 4 5 Clara Blanc 4,0E+4 PROG Tarragona 1 6 Laura Tort 3,0E+4 PROG Tarragona 3 7 Rogelio Salt 4,0E+4 NULL NULL 4 8 Sergio Grau 3,0E+4 PROG Tarragona NULL FUOC 71Z799014MO 29 El lenguaje SQL T a b l a proyectos : 2.5. Consultas a una base de datos relacional Para hacer consultas sobre una tabla con el SQ L es preciso utilizar la sentencia SELECT FROM , que tiene el siguiente formato: La opci\u00f3n AS nos permite renombrar las columnas que queremos seleccionar o las tablas que queremos consultar que en este caso, es s\u00f3lo una. Dicho de otro modo, nos permite la definici\u00f3n de alias. Fij\u00e9monos en que la palabra clave AS es opcional, y es bastante habitual poner s\u00f3lo un espacio en blanco en lugar de toda la palabra. Consultas a BDUOC A continuaci\u00f3n presentamos un ejemplo de cons ulta a la base de da tos BDUOC para conocer todos los datos que aparece en la tabla clientes : La respuesta a esta consulta ser\u00eda:proyectos Barcelona NULL CME 38.123.898-E Valencia 22 Girona 972.23.57.21 30 973.23.45.67 40 Rosell\u00f3n 44 Tarragona 977.33.71.43El * despu\u00e9s de SELECT indica que queremos ver todos los atributos que aparecen en la tabla. FUOC 71Z799014MO 30 El lenguaje SQL Si hubi\u00e9semos querido ver s\u00f3lo el c\u00f3digo, el nombre, la direcci\u00f3n y la ciudad, habr\u00edamos hecho: Y habr\u00edamos obtenido la respuesta siguiente: Con la sentencia SELECT FROM podemos seleccionar columnas de una tabla, pero para seleccionar filas de una ta bla es preciso a\u00f1adirle la cl\u00e1usula WHERE . El formato es: La cl\u00e1usula WHERE nos permite obtener las fila s que cumplen la condici\u00f3n es - pecificada en la consulta. Consultas a BDUOC seleccionando filas Veamos un ejemplo en el que pedimos \"los c\u00f3di gos de los empleados que trabajan en el pro - yecto n\u00famero 4\": La respuesta a esta consulta ser\u00eda la que pod\u00e9is ver en el margen. Para definir las condic iones en la cl\u00e1usula WHERE , podemos utilizar alguno de los operadores de los que dispone el SQL, que son los siguientes: Si queremos que en una consulta nos ap arezcan las filas resultantes sin repeti - ciones, es preciso poner la palabra clave DISTINCT ECIGSA Arag\u00f3n 11 Barcelona 20 CME Valencia 22 Girona 30 ACME Mallorca 33 Lleida 40 JGM Rosell\u00f3n FROM empleados WHERE num_proyec = 4; Operadores de comparaci\u00f3n Operadores l\u00f3gicos = Igual NOT Para la negaci\u00f3n de condiciones < Menor AND Para la conjunci\u00f3n de condiciones > Mayor OR Para la disyunci\u00f3n de condiciones <= Menor o igual >= Mayor o igual < > Diferentecodigo_empl 247 FUOC 71Z799014MO 31 El lenguaje SQL de SELECT . Tambi\u00e9n podr\u00edamos explicitar qu e lo queremos todo, incluso con repeticiones, poniendo ALL (opci\u00f3n por defecto) en lugar de DISTINCT . El for - mato de DISTINCT es: Consulta a BDUOC seleccionando filas sin repeticiones Por ejemplo, si quisi\u00e9ramos ver qu\u00e9 sueldos se est\u00e1n pagando en nuestra empresa, podr\u00edamos hacer: La respuesta a esta consulta, sin repeticiones, ser\u00eda la que aparece en el margen. 2.5.1. Funciones de agregraci\u00f3n El SQL nos ofrece las siguientes funcione s de agregaci\u00f3n para efectuar varias operaciones sobre los dato s de una base de datos: En general, las funciones de agregaci\u00f3n se aplican a una columna, excepto la funci\u00f3n de agregaci\u00f3n COUNT , que normalmente se aplica a todas las columnas de la tabla o tablas seleccionadas. Por lo tanto, COUNT (*) contar\u00e1 todas las filas de la tabla o las tablas que cumplan las condiciones. Si se utilizase COUNT(dis - tinct columna) , s\u00f3lo contar\u00eda los valores que no fuesen nulos ni repetidos, y si se utilizase COUNT (columna) , s\u00f3lo contar\u00eda los valores que no fuesen nulos. Ejemplo de utilizaci\u00f3n de la funci\u00f3n COUNT (*) Veamos un ejemplo de uso de la funci\u00f3n COUNT , que aparece en la cl\u00e1usula SELECT , para hacer la consulta \"\u00bfCu\u00e1ntos departamentos est\u00e1n ubicados en la ciudad de Lleida?\": La respuesta a esta consulta ser\u00ed a la que aparece reflejada en la tabla que encontrar\u00e9is en Funciones de agregaci\u00f3n Funci\u00f3n Descripci\u00f3n COUNT Nos da el n\u00famero total de filas seleccionadas SUM Suma los valores de una columna MIN Nos da el valor m\u00ednimo de una columna MAX Nos da el valor m\u00e1ximo de una columna AVG Calcula el valor medio de una columna SELECT COUNT (*) AS numero_dep FROM departamentos WHERE ciudad_dep = 'Lleida';sueldo 3,0E+44,0E+47,0E+49,0E+41,0E+5 numero_dep 1 FUOC 71Z799014MO 32 El lenguaje SQL Veremos ejemplos de las dem\u00e1s funcione s de agregaci\u00f3n en los siguientes apartados. 2.5.2. Subconsultas Subconsulta en BDUOC Si quisi\u00e9ramos saber los c\u00f3digos y los nombres de los proyectos de precio m\u00e1s elevado, en primer lugar tendr\u00edamos que encontrar lo s proyectos que tienen el precio m\u00e1s ele - vado. Lo har\u00edamos de la forma siguiente: El resultado de la consulta anterior ser\u00eda lo que puede verse al margen. 2.5.3. Otros predicados 1) Predicado BETWEEN Para expresar una condici\u00f3n que quiere encontrar un valor entre unos l\u00edmites concretos, podemos utilizar BETWEEN : Ejemplo de uso del predicado BETWEEN Un ejemplo en el que se pide \"Los c\u00f3digos de los empleados que ganan entre 20.000 y 50.000 euros anuales\" ser\u00eda:Una subconsulta es una consulta incluida dentro de una cl\u00e1usula WHERE o HAVING de otra consulta. En ocasiones, para expresar ciertas condicio - nes no hay m\u00e1s remedio que obtene r el valor que buscamos como re - sultado de una consulta. SELECT codigo_proyec, nombre_proyec FROM proyectos WHERE = (precio) FROM proyectos); SELECT BETWEEN l\u00edmite1 codigo_empl FROM empleados WHERE sueldo BETWEEN 2.0E+4 and 5.0E+4; Veremos la cl\u00e1usula HAVING en de esta unidad did\u00e1ctica. codigo_proyec nombre_proyec 4T I N E L L Los proyectos de precio m\u00e1s bajo Si en lugar de los c\u00f3digos y los nombres de proyectos de precio m\u00e1s alto hubi\u00e9semos querido saber los de precio m\u00e1s bajo, habr\u00edamos aplicado la funci\u00f3n de agregaci\u00f3n MIN. FUOC 71Z799014MO 33 El lenguaje SQL La respuesta a esta consulta ser\u00ed a la que se ve en el margen. 2) Predicado IN Para comprobar si un valor coincide con los elementos de una lista utilizare - mos IN, y para ver si no coincide, NOT IN : Ejemplo de uso del predicado IN \"Queremos saber el nombre de todos los departamentos que se encuentran en las ciudades de Lleida o Tarragona\": La respuesta ser\u00eda la que aparece en el margen. 3) Predicado LIKE Para comprobar si una columna de tipo car\u00e1cter cumple alguna propiedad de - terminada, podemos usar LIKE : Los patrones del SQL92 para expresar caracter\u00edsticas son los siguientes: a)Pondremos un car\u00e1cter _ para cada ca r\u00e1cter individual que queramos con - siderar. b)Pondremos un car\u00e1cter % para expres ar una secuencia de caracteres, que puede no estar formada por ninguno. Ejemplo de uso del predicado LIKE A continuaci\u00f3n presentamos un ejemplo en el que buscaremos los nombres de los emplea - dos que empiezan por J, y otro ejemplo en el que obtendremos los proyectos que comienzan por S y tienen cinco letras: a)Nombres de empleados que empiezan por la letra J: La respuesta a esta consulta ser\u00eda la que se muestra en el margen.SELECT nombre_columnas_a_seleccionar FROM DIS Lleida PROG Tarragona Otros patrones Aunque _ y % son los caracteres elegidos por el est\u00e1ndar, cada sistema relacional comercial ofrece diversas variantes. Atributos a\u00f1adidos Aunque la consulta pide s\u00f3lo los nombres de empleados a\u00f1adimos el c\u00f3digo para poder diferenciar dos empleados con el mismo nombre. codigo_empl nombre_empl 4J o r g e FUOC 71Z799014MO 34 El lenguaje SQL b)Proyectos que empiezan por S y tienen cinco letras: Y la respuesta a esta otra consulta ser\u00eda la que aparece en el margen. 4) Predicado IS NULL Para comprobar si un va lor es nulo utilizaremos IS NULL , y para averiguar si no lo es, IS NOT NULL . El formato es: Ejemplo de uso del predicado IS NULL Un ejemplo de uso de este predicado ser\u00eda \"Que remos saber el c\u00f3digo y el nombre de todos los empleados que no est\u00e1n asignados a ning\u00fan proyecto\": Obtendr\u00edamos la respuesta que tenemos al margen. 5) Predicados ANY/SOME y ALL Para ver si una columna cumple que todas sus filas ( ALL) o algunas de sus filas (ANY/SOME ) satisfagan una condici\u00f3n, podemos hacer: Ejemplo de uso de los predicados ALL y ANY/SOME a)Veamos un ejemplo de aplicaci\u00f3n de ALL para encontrar los c\u00f3di gos y los nombres de los proyectos en los que los sueldos de todos los empleados asignados son menores que el precio del proyecto:SELECT codigo_proyec FROM nombre_proyec FROM proyectos WHERE precio > ALL (SELECT sueldo FROM empleados WHERE codigo_proyec = num_proyec);codigo_proyec 3 codigo_empl nombre_empl 8S e r g i o Los predicados ANY/SOME Podemos elegir cualquiera de los dos predicados para pedir que alguna fila satisfaga una condici\u00f3n. FUOC 71Z799014MO 35 El lenguaje SQL Fij\u00e9monos en la condici\u00f3n de WHERE de la subconsulta, que nos asegura que los sueldos que observamos son los de los empleados asignados al proyecto de la consulta. La respuesta a esta consulta ser\u00eda la que aparece en el margen. b)A continuaci\u00f3n, presentamos un ejemplo de ANY/SOME para buscar los c\u00f3digos y los nom - bres de los proyectos que tienen alg\u00fan empleado que gana un sueldo m\u00e1s elevado que el pre - cio del proyecto en el que trabaja. La respuesta a esta consulta est\u00e1 vac\u00eda, como se ve en el margen. 6) Predicado EXISTS Para comprobar si una su bconsulta produce alguna fila de resultados, pode - mos utilizar la sentencia denominada test de existencia : EXISTS . Para compro - bar si una subconsulta no produce ninguna fila de resultados, podemos utilizar NOT EXISTS . Ejemplo de uso del predicado EXISTS Un ejemplo en el que se buscan los c\u00f3digos y los nombres de los empleados que est\u00e1n asig - nados a alg\u00fan proyecto ser\u00eda: La respuesta a esta consulta ser\u00eda la que se muestra en el margen. 2.5.4. Ordenaci\u00f3n de los datos obte nidos en respuestas a consultas Si se desea que, al hacer una consulta , los datos aparezcan en un orden deter - minado, es preciso utilizar la cl\u00e1usula ORDER BY en la sentencia SELECT , que presenta el si guiente formato:SELECT codigo_proyec, nombre_proyec FROM proyectos WHERE precio < ANY sueldo FROM empleados WHERE codigo_proyec FROM tabla_a_consultarcodigo_proyec nombre_proyec S C O M2P E S C I3S A L S A4T I N E L L codigo_proyec nombre_proyec codigo_empl nombre_empl 1M a r \u00ed a2P e r o3A n a4J o r g e 5C l a r a 6L a u r a7R o g e l i o FUOC 71Z799014MO 36 El lenguaje SQL Consulta a BDUOC con respuesta ordenada Imaginemos que queremos consultar los nombre s de los empleados ordenados seg\u00fan el suel - do que ganan, y si ganan el mismo sueldo , ordenados alfab\u00e9ticamente por el nombre: Esta consulta dar\u00eda la respuesta siguiente: Si no se especifica nada m\u00e1s, se seguir\u00e1 un orden ascendente, pero si se desea seguir un orden descende nte es necesario a\u00f1adir DESC detr\u00e1s de cada factor de ordenaci\u00f3n expresado en la cl\u00e1usula ORDER BY : Tambi\u00e9n se puede ex plicitar un orden ascendente poniendo la palabra clave ASC (opci\u00f3n por defecto). 2.5.5. Consultas con agrupaci \u00f3n de filas de una tabla Las cl\u00e1usulas siguientes, a\u00f1 adidas a la instrucci\u00f3n SELECT FROM , permiten or - ganizar las filas por grupos: a)La cl\u00e1usula GROUP BY nos sirve para agrupar f ilas seg\u00fan las columnas que indique esta cl\u00e1usula.[WHERE nombre_empl apellido_empl sueldo 6 Laura Tort 3,0E+4 8 Sergio Grau 3,0E+4 5 Clara Blanc 4,0E+4 7 Rogelio Salt 4,0E+4 3 Ana Ros 7,0E+4 4 Jorge Roca 7,0E+4 2 Pedro Mas 9,0E+4 1 Mar\u00eda Puig 1,0E+5 ORDER columna_ordenaci\u00f3n [ DESC] [, columna [DESC] 71Z799014MO 37 El lenguaje SQL b)La cl\u00e1usula HAVING especifica condiciones de b\u00fasqueda para grupos de filas; lleva a cabo la misma funci\u00f3n que antes cumpl\u00eda la cl\u00e1usula WHERE para las filas de toda la tabla, pero ahora las condiciones se aplican a los grupos obtenidos. Presenta el si guiente formato: Notemos que en las sentencias SQL se van a\u00f1adiendo cl\u00e1usulas a medida que la dificultad o la exigencia de la consulta lo requiere. Consulta con agrupaci\u00f3n de filas en BDUOC Imaginemos que queremos saber el sueldo medio que ganan los empleados de cada de - partamento: El resultado de esta consulta ser\u00eda: Ejemplo de uso de la funci\u00f3n de agregaci\u00f3n SUM Veamos un ejemplo de uso de una funci\u00f3n de agregaci\u00f3n SUM del SQL que aparece en la cl\u00e1u - sula HAVING de GROUP BY : \"Queremos saber los c\u00f3digos de los proyectos en los que la suma de los sueldos de los emplea dos es mayor que 180.000 euros\": El resultado de esta consulta ser\u00eda el que se ve al margen.SELECT nombre_columnas_a seleccionar sueldo_medio DIR Barcelona 9,0E + 4 DIR Girona 1,0E + 5 DIS Lleida 7,0E + 4 DIS Barcelona 7,0E + 4 PROG Tarragona 3,3E + 4 NULL NULL 4,0E + 4 SELECT num_proyec FROM empleados GROUP BY num_proyec HAVING SUM (sueldo) >1.8E+5; Factores de agrupaci\u00f3n Los factores de agrupaci\u00f3n de la cl\u00e1usula GROUP BY deben ser, como m\u00ednimo, las columnas que figuran en SELECT , exceptuando las columnas afectadas por funciones de agregaci\u00f3n. num_proyec 4 DISTINCT y GROUP BY En este ejemplo no es necesario poner DISTINCT , a pesar de que la columna num_proyec no es atributo identificador. Fij\u00e9monos en que en la tabla empleados hemos puesto que todos los proyectos tienen el mismo c\u00f3digo juntos en un mismo grupo y no es posible que aparezcan repetidos. FUOC 71Z799014MO 38 El lenguaje SQL 2.5.6. Consultas a m\u00e1s de una tabla Muchas veces queremos consultar datos de m\u00e1s de una tabla haciendo combi - naciones de columnas de tablas diferentes. En el SQL es posible listar m\u00e1s de una tabla que se quiere consultar especific\u00e1ndolo en la cl\u00e1usula FROM . 1) Combinaci\u00f3n La combinaci\u00f3n consigue crear una sola tabla a partir de las tablas especifica - das en la cl\u00e1usula FROM , haciendo coincidir los va lores de las columnas rela - cionadas de estas tablas. Ejemplo de combinaci\u00f3n en BDUOC A continuaci\u00f3n mostramos un ejemplo con la base de datos BDUOC en el que queremos sa - ber el NIF del cliente y el c\u00f3digo y el precio del proyecto que desarro llamos para el cliente n\u00famero 20: El resultado ser\u00eda: Si trabajamos con m\u00e1s de una tabla, puede ocurrir que la tabla resultante tenga dos columnas con el mismo nombre. Por ello es obligatorio especificar a qu\u00e9 tabla corresponden las columnas a la s que nos estamos refiriendo, denomi - nando la tabla a la que pertenecen antes de ponerlas (por ejemplo, clien- tes.codigo_cli ). Para simplificarlo, se utilizan los alias que, en este caso, se definen en la cl\u00e1usula FROM . Ejemplo de alias en BDUOC c podr\u00eda ser el alias de la tabla clientes . De este modo, para indi car a qu\u00e9 tabla pertenece codigo_cli , s\u00f3lo har\u00eda falta poner: c.codigo_cli. Veamos c\u00f3mo quedar\u00eda la consulta anterior ex presada mediante alias, aunque en este ejem - plo no ser\u00edan necesarios, porque todas las columnas de las dos tablas tienen nombres dife - rentes. Pediremos, ad em\u00e1s, las la misma operaci\u00f3n de combinaci\u00f3n, pero del \u00e1lgebra relacional, se ha visto en el subapartado 5.3.3. de la unidad \"El modelo relacional y el \u00e1lgebra relacional\" de este curso. FUOC 71Z799014MO 39 El lenguaje SQL Notemos que en WHERE necesitamos expresar el v\u00ednculo que se establece entre las dos tablas, en este caso codigo_cli de clientes y codigo_cliente de proyectos . Expresado en operaciones del \u00e1lgebra relacional, esto signif ica que hacemos una combinaci\u00f3n en lugar de un producto cartesiano. Fij\u00e9monos en que, al igual que en \u00e1lgebra rela cional, la operaci\u00f3n que acabamos de hacer es una equicombinaci\u00f3n ( equi-join ); por lo tanto, nos aparecen dos columnas id\u00e9nticas: c.co- digo_cli y p.codigo_cliente . La forma de expresar la combinaci\u00f3n que acabamos de ver pertenece al SQL92 introductorio. Una forma alternativa de realizar la equicombinaci\u00f3n anterior, utilizando el SQL92 intermedio o completo, ser\u00eda la siguiente: Ejemplo anterior con el SQL92 intermedio o completo El ejemplo que hemos expuesto antes utiliza ndo el SQL92 intermedio o completo ser\u00eda: Y obtendr\u00edamos el mism o resultado de antes. La opci\u00f3n ON, adem\u00e1s de expresar condiciones con la igualdad, en el caso de que las columnas que queramos vincular tengan nombres diferentes, nos ofre - ce la posibilidad de expresar condicio nes con los dem\u00e1s op eradores de compa - raci\u00f3n que no sean el de igualdad. Ser\u00ed a el equivalente a la operaci\u00f3n que en \u00e1lgebra relacional hemos denominado -combinaci\u00f3n (-join). Tambi\u00e9n podemos utilizar una misma ta bla dos veces con alias diferentes, para distinguirlas. Dos alias para una misma tabla en BDUOC Si pidi\u00e9semos los c\u00f3digos y los apellidos de los empleados que ganan m\u00e1s que el empleado que tiene por c\u00f3digo el n\u00famero 5, har\u00edamos lo siguiente: Hemos tomado la tabla e2 para fijar la fila del empleado con c\u00f3digo n\u00famero 5, de modo que podamos comparar el sueldo de la tabla e1, que contiene a todos los empleados, con el suel - do de la tabla e2, que contiene s\u00f3lo al empleado 5.SELECT nombre_columnas_a_seleccionar FROM p.codigo_cliente WHERE c.codigo_cli = 20; SELECT > e2.sueldo WHERE e2.codigo_empl = 5;Las operaciones del \u00e1lgebra relacional se han visto en el apartado 5 de la unidad \"El modelo relacional y el \u00e1lgebra relacional\" de este curso. Pod\u00e9is ver la equicombinaci\u00f3n y la -combinaci\u00f3n en el subapartado 5.3.3 de la unidad \"El modelo relacional y el \u00e1lgebra relacional\" de este curso. FUOC 71Z799014MO 40 El lenguaje SQL La respuesta a esta consulta ser\u00eda: 2) Combinaci\u00f3n natural La combinaci\u00f3n natural ( natural join ) de dos tablas consiste b\u00e1sicamente, al igual que en el \u00e1lgebra relacional, en hacer una equicombinaci\u00f3n entre colum - nas del mismo nombre y eliminar las columnas repetidas. La combinaci\u00f3n na - tural, utilizando el SQL92 intermedio o completo, se har\u00eda de la forma siguiente: Combinaci\u00f3n natural en BDUOC Veamos a continuaci\u00f3n un ejemplo en el que la s columnas para las que se har\u00eda la combina - ci\u00f3n natural se denominan igual en las dos tabl as. Ahora queremos saber el c\u00f3digo y el nom - bre de los empleados que est\u00e1n asignados al departamento cuyo te l\u00e9fono es 977.33.38.52: La combinaci\u00f3n natural tambi\u00e9n se podr\u00eda hacer con la cl\u00e1usula USING , s\u00f3lo aplicando la pa - labra reservada JOIN : La respuesta que dar\u00eda ser\u00eda: 3) Combinaci\u00f3n in terna y externa Cualquier combinaci\u00f3n puede ser interna o externa: a)La combinaci\u00f3n interna (inner join ) s\u00f3lo se queda con las filas que tienen valores id\u00e9nticos en las columnas de la s tablas que compara. Esto puede hacer que perdamos alguna fila interesante de alguna de las dos tablas; por ejemplo, e1.codigo_empl e1.apellido_empl 1 Puig 2 Mas 3 Ros 4 Roca '977.333.852 6 Laura 8 Sergio FUOC 71Z799014MO 41 El lenguaje SQL porque se encuentra a NULL en el mome nto de hacer la combinaci\u00f3n. Su for - mato es el siguiente: b)Por ello disponemos de la combinaci\u00f3n externa (outer join ), que nos per - mite obtener todos los valores de la ta bla que hemos puesto a la derecha, los de la tabla que hemos puesto a la izquie rda o todos los valores de las dos tablas. Su formato es: Combinaci\u00f3n natural interna en BDUOC Si quisi\u00e9ramos vincular con una combinaci\u00f3n natural interna las tablas empleados y departamentos para saber el c\u00f3digo y el nombre de todos los empleados y el nombre, la ciudad y el tel\u00e9fono de todos los departamentos, har\u00edamos: Y obtendr\u00edamos el siguiente resultado: Fij\u00e9monos en que en el resultado no aparece el empleado n\u00famero 7, que no est\u00e1 asignado a ning\u00fan departamento, ni el de partamento de programaci\u00f3n de Girona, que no tiene ning\u00fan empleado asignado. Combinaci\u00f3n natural externa a BDUOC En los ejemplos siguientes veremos c\u00f3mo var\u00edan los resultados que iremos obteniendo seg\u00fan los tipos de combinaci\u00f3n externa:SELECT nombre_columnas_a_seleccionar FROM t1 [NATURAL] [INNER] JOIN e.nombre_dep e.ciudad_dep d.telefono 1 Mar\u00eda DIR Girona 972.23.89.70 2 Pedro DIR Barcelona 93.422.60.70 3 Ana DIS Lleida 973.23.50.40 4 Jorge DIS Barcelona 93.224.85.23 5 Clara PROG Tarragona 977.33.38.52 6 Laura PROG Tarragona 977.33.38.52 8 Sergio PROG Tarragona 977.33.38.52Combinaci\u00f3n interna Aunque en el ejemplo estamos haciendo una combinaci\u00f3n natural interna, no es necesario poner la palabra INNER , ya que es la opci\u00f3n por defecto. FUOC 71Z799014MO 42 El lenguaje SQL a)Combinaci\u00f3n externa izquierda El resultado ser\u00eda el que podemos ver a continuaci\u00f3n: b)Combinaci\u00f3n externa derecha Obtendr\u00edamos este resultado: DIR Girona 972.23.89.70 2 Pedro DIR Barcelona 93.422.60.70 3 Ana DIS Lleida 973.23.50.40 4 Jorge DIS Barcelona 93.224.85.23 5 Clara PROG Tarragona 977.33.38.52 6 Laura PROG Tarragona 977.33.38.52 7 Rogelio NULL NULL SELECT e.codigo_empl, e.nombre_empl e.nombre_dep e.ciudad_dep d.telefono DIR Girona 972.23.89.70 2 Pedro DIR Barcelona 93.422.60.70 3 Ana DIS Lleida 973.23.50.40 4 Jorge DIS Barcelona 93.224.85.23 5 Clara PROG Tarragona 977.33.38.52 6 Laura PROG Tarragona 977.33.38.52 8 e.nombre_empl e.nombre_dep e.ciudad_dep d.telefono DIR Girona 972.23.89.70 2 Pedro DIR Barcelona 93.422.60.70 3 Ana DIS Lleida 973.23.50.40Combinaci\u00f3n externa izquierda Aqu\u00ed figura el empleado 7. Combinaci\u00f3n externa derecha Aqu\u00ed figura el departamento de programaci\u00f3n de Girona. FUOC 71Z799014MO 43 El lenguaje SQL 4) Combinaciones con m\u00e1s de dos tablas Si queremos combinar tres tablas o m\u00e1 s con el SQL92 introductorio, s\u00f3lo te - nemos que a\u00f1adir todas las tablas en el FROM y los v\u00ednculos necesarios en el WHERE . Si queremos combinarlas con el SQ L92 intermedio o con el completo, tenemos que ir haciendo co mbinaciones de tablas por pares, y la tabla resul - tante se convertir\u00e1 en el prim er componente del siguiente par. Combinaciones con m\u00e1s de dos tablas en BDUOC Veamos ejemplos de los dos casos, suponiendo que queremos combinar las tablas emplea- dos, proyectos y clientes : o bien: 2.5.7. La uni\u00f3n La cl\u00e1usula UNION permite unir consultas de dos o m\u00e1s sentencias SELECT FROM . Su formato es: Si ponemos la opci\u00f3n ALL, aparecer\u00e1n todas las filas obtenidas a causa de la uni\u00f3n. No la pondremos si queremos eliminar las filas repetidas. Lo m\u00e1s e.codigo_empl e.nombre_empl e.nombre_dep e.ciudad_dep d.telefono 4 Jorge DIS PROG Tarragona 977.33.38.52 6 Laura PROG Tarragona 977.33.38.52 7 Rogelio NULL NULL NULL 8 Sergio PROG Tarragona 977.33.38.52 NULL NULL PROG Girona 972.23.50.91 SELECT * FROM empleados, proyectos, clientes WHERE num_proyec = codigo_proyec AND codigo_cliente = codigo_cli; SELECT * FROM (empleados JOIN proyectos ON num_proyec = codigo_proyec) JOIN clientes ON codigo_cliente = FROM SELECT columnas FROM tabla [WHERE condiciones];Combinaci\u00f3n externa plena Aqu\u00ed figura el empleado 7 y el departamento de programaci\u00f3n de Girona. FUOC 71Z799014MO 44 El lenguaje SQL importante de la uni\u00f3n es que somo s nosotros quienes tenemos que procu - rar que se efect\u00fae entre columnas defi nidas sobre dominios compatibles; es decir, que tengan la misma interpre taci\u00f3n sem\u00e1ntica. Como ya hemos co - mentado, el SQL92 no nos ofrece herra mientas para asegurar la compatibi - lidad sem\u00e1ntica entre columnas. Utilizaci\u00f3n de la uni\u00f3n en BDUOC Si queremos saber todas las ciudades que hay en nuestra base de da tos, podr\u00edamos hacer: El resultado de esta consulta se r\u00eda el que se muestra al margen. 2.5.8. La intersecci\u00f3n Para hacer la intersecci\u00f3n entre dos o m\u00e1s sentencias SELECT FROM , podemos utilizar la cl\u00e1usula INTERSECT , cuyo formato es: Si indicamos la opci\u00f3n ALL, aparecer\u00e1n todas las filas obtenidas a partir de la intersecci\u00f3n. No la pondremos si quer emos eliminar las filas repetidas. Lo m\u00e1s importante de la intersecci\u00f3n es que somos nosotros quienes tenemos que vigilar que se haga entre columnas definidas sobre dominios compatibles; es decir, que tengan la misma interpretaci\u00f3n sem\u00e1ntica. Utilizaci\u00f3n de la intersecci\u00f3n en BDUOC Si queremos saber todas las ciudades donde tenemos departamentos en los que podamos en - contrar alg\u00fan cliente, podr\u00edamos hacer: El resultado de esta consulta se r\u00eda el que se muestra al margen.SELECT ciudad FROM clientes UNION SELECT ciudad_dep INTERSECT SELECT ciudad_dep FROM departamentos; ciudad Barcelona Girona Lleida Tarragona ciudad Barcelona Girona Lleida Tarragona FUOC 71Z799014MO 45 El lenguaje SQL Sin embargo, la intersecci\u00f3n es una de las operaciones del SQL que se puede hacer de m\u00e1s formas diferentes. Tambi\u00e9 n podr\u00edamos encontrar la intersecci\u00f3n con IN o EXISTS : a)Intersecci\u00f3n utilizando IN b)Intersecci\u00f3n utilizando EXISTS Ejemplo anterior expresado con IN y con EXISTS El ejemplo que hemos propuesto antes se podr\u00eda expresar con IN: o tambi\u00e9n con EXISTS : 2.5.9. La diferencia Para encontrar la diferencia entre dos o m\u00e1s sentencias SELECT FROM podemos utilizar la cl\u00e1usula EXCEPT , que tiene este formato:SELECT columnas FROM tabla WHERE columna IN (SELECT columna FROM tabla [WHERE condiciones]); SELECT columnas FROM tabla EXISTS (SELECT * FROM tabla WHERE condiciones); SELECT c.ciudad FROM d); SELECT c.ciudad FROM clientes c WHERE EXISTS (SELECT * FROM departamentos d WHERE c.ciudad = d.ciudad_dep; SELECT columnas FROM tabla FUOC 71Z799014MO 46 El lenguaje SQL Si ponemos la opci\u00f3n ALL aparecer\u00e1n todas las filas qu e da la diferencia. No la pondremos si queremos elim inar las filas repetidas. Lo m\u00e1s importante de la diferencia es que somos nosotros quienes tenemos que vigilar que se haga entre columnas definidas sobre dominios compatibles. Utilizaci\u00f3n de la diferencia en BDUOC Si queremos saber los clientes que no nos ha n contratado ning\u00fan proyecto, podr\u00edamos hacer: El resultado de esta consulta ser\u00eda el que se ve en el margen. La diferencia es, junto con la interse cci\u00f3n, una de las operaciones del SQL que se puede realizar de m\u00e1s formas dife rentes. Tambi\u00e9n podr\u00edamos encontrar la diferencia utilizando NOT IN o NOT EXISTS : a)Diferencia utilizando NOT IN : b)Diferencia utilizando NOT SELECT codigo_cliente FROM SELECT columnas FROM tabla WHERE columna NOT IN (SELECT columna FROM tabla [WHERE condiciones]); SELECT columnas FROM tabla WHERE NOT EXISTS FROM tabla WHERE condiciones); codigo_cli 40 FUOC 71Z799014MO 47 El lenguaje SQL Ejemplo anterior expresado con NOT IN y con NOT EXISTS El ejemplo que hemos hecho antes se podr\u00eda expresar con NOT IN : o tambi\u00e9n con NOT EXISTSSELECT c.codigo_cli FROM clientes c WHERE c.codigo_cli NOT IN (SELECT p.codigo_cliente FROM proyectos p); SELECT c.codigo_cli FROM clientes c WHERE NOT EXISTS (SELECT FROM proyectos p WHERE c.codigo_cli = p.codigo_cliente); FUOC 71Z799014MO 48 El lenguaje SQL 3. Sentencias de control Adem\u00e1s de definir y manipular una base de datos relacional, es importante que se establezcan mecanismos de control para resolver problemas de concurrencia de usuarios y garantizar la seguridad de los datos. Para la concurrencia de usuarios utilizaremos el concepto de transacci\u00f3n , y para la seguridad veremos c\u00f3mo se pue - de autorizar y desautorizar a usuarios a acceder a la base de datos. 3.1. Las transacciones La mayor\u00eda de las transacciones se inicia n de forma impl\u00edcita al utilizar alguna sentencia que empieza con CREATE , ALTER , DROP , SET, DECLARE , GRANT o REVOKE , aunque existe la sentencia SQL para iniciar transacciones , que es la siguiente: Si queremos actualizar la base de datos utilizaremos la opci\u00f3n READ WRITE , y si no la queremos actualiz ar, elegiremos la opci\u00f3n READ ONLY . Sin embargo, en cambio, una transacci\u00f3n siempre debe acabar expl\u00edcitamente con alguna de las se ntencias siguientes: La diferencia entre COMMIT y ROLLBACK es que mientras la sentencia COMMIT confirma todos los cambios producidos co ntra la BD durante la ejecuci\u00f3n de la transacci\u00f3n, la sentencia ROLLBACK deshace todos los cambios que se hayan producido en la base de datos y la deja como estaba antes del inicio de nuestra transacci\u00f3n. La palabra reservada WORK s\u00f3lo sirve para aclarar lo que hace la sentencia, y es totalmente opcional.Una transacci\u00f3n es una unidad l\u00f3gica de trabajo. O informalmente, y trabajando con SQL, un conjunto de sentencias que se ejecutan como si fuesen una sola. En general, las sentencias que form an parte de una transacci\u00f3n se interrelacionan entre s\u00ed, y no tiene sentido que se ejecute una sin que se ejecuten las dem\u00e1s. SET TRANSACTION {READ 71Z799014MO 49 El lenguaje SQL Ejemplo de transacci\u00f3n A continuaci\u00f3n proponemos un ejemplo de transa cci\u00f3n en el que se quiere disminuir el suel - do de los empleados que han trabajado en el proy ecto 3 en 1.000 euros. y aumentar el sueldo de los empleados que han trabajado en el proyecto 1 tambi\u00e9n en 1.000 euros. 3.2. Las autorizaciones y desautorizaciones Todos los privilegios sobre la base de dato s los tiene su propietario, pero no es el \u00fanico que accede a \u00e9sta. Por este moti vo, el SQL nos ofrece sentencias para autorizar y desautoriz ar a otros usuarios. 1) Autori zaciones Para autorizar, el SQL dispon e de la siguiente sentencia: Donde tenemos que: a)privilegios puede ser: ALL PRIVILEGES : todos los privilegios sobr e el objeto especificado. USAGE : utilizaci\u00f3n del objeto especifi cado; en este caso el dominio. SELECT : consultas. INSERT [(columnas )]: inserciones. Se pu ede concretar de qu\u00e9 columnas . UPDATE [(columnas )]: modificaciones. Se puede concretar de qu\u00e9 columnas . DELETE : borrados. REFERENCES [(columna )]: referencia del objeto en restricciones de integri - dad. Se puede concretar de qu\u00e9 columnas . b)Objeto debe ser: DOMAIN : dominioSET TRANSACTION READ WRITE; UPDATE empleados SET sueldo = sueldo - 1000 WHERE num_proyec = 3; UPDATE empleados SET sueldo = sueldo + 1000 WHERE num_proyec = 1; COMMIT; GRANT privilegios ON objeto TO usuarios [WITH GRANT OPTION ]; FUOC 71Z799014MO 50 El lenguaje SQL TABLE : tabla. Vista . c) Usuarios puede ser todo el mundo: PUBLIC , o bien una lista de los identi - ficadores de los usuarios que queremos autorizar. d)La opci\u00f3n WITH GRANT OPTION permite que el usuario que autoricemos pueda, a su vez, autorizar a otros usuarios a acceder al objeto con los mismos privilegios con los que ha sido autorizado. 2) Desautorizaciones Para desautorizar, el SQL disp one de la siguiente sentencia: Donde tenemos que: a)privilegios , objeto y usuarios son los mismos que para la sentencia GRANT . b)La opci\u00f3n GRANT OPTION FOR se utilizar\u00eda en el ca so de que quisi\u00e9ramos eliminar el derecho a autorizar ( WITH GRANT OPTION ). c)Si un usuario al que hemos autorizado ha autorizado a su vez a otros, que al mismo tiempo pueden haber hecho m\u00e1s autorizaciones, la opci\u00f3n CASCADE hace que queden desautor izados todos a la vez. d)La opci\u00f3n RESTRICT no nos permite desautorizar a un usuario si \u00e9ste ha autorizado a otros.REVOKE [GRANT OPTION FOR] privilegios ON objeto FROM usuarios [ |CASCADE]; FUOC 71Z799014MO 51 El lenguaje SQL 4. Sublenguajes especializados Muchas veces querremos acceder a la base de datos desde una aplicaci\u00f3n he - cha en un lenguaje de programaci\u00f3n cu alquiera. Para utilizar el SQL desde un lenguaje de programaci \u00f3n, podemos utilizar el SQL hospedado , y para traba - jar con \u00e9ste necesitamos un precompila dor que separe las sentencias del len - guaje de programaci\u00f3n de las del lenguaje de bases de datos. Una alternativa muy interesante a esta forma de trabajar son las rutinas SQL/CLI . El objetivo de este apartado no es explicar con detalle ni el SQL hospedado ni, a\u00fan menos, las rutina s SQL/CLI. S\u00f3lo introducirem os las ideas b\u00e1sicas del fun - cionamiento de ambos. 4.1. SQL hospedado Para crear y manipular una base de dato s relacional necesi tamos SQL. Adem\u00e1s, si la tarea que queremos hacer requiere el poder de procesamiento de un len - guaje de programaci\u00f3n como Java, C, Cobol, Fortran, Pa scal, etc., podemos utilizar el SQL hospedado en el lenguaje de programa ci\u00f3n elegido. De este mo - do, podemos utilizar las sentencias del SQL dentro de nuestras aplicaciones, poniendo siempre delante la palabra reservada EXEC SQL* . Para poder compilar la mezcla de llama das de SQL y sentencias de programa - ci\u00f3n, antes tenemos que utilizar un precompilador. Un precompilador es una herramienta que separa la s sentencias del SQL y la s sentencias de programa - ci\u00f3n. All\u00e1 donde en el programa fuente haya una sentencia de acceso a la base de datos, se debe insertar una llamada a la interfaz del SGBD. El programa fuente resultante de la precompilaci\u00f3n ya est\u00e1 \u00fanicamente en el lenguaje de programa - ci\u00f3n, preparado para ser comp ilado, montado y ejecutado. En la figura que encontrar\u00e9is en la p\u00e1gina siguiente pod\u00e9is observar este funcionamiento. Todas las sentencias de definici\u00f3n, ma nipulaci\u00f3n y control que hemos visto para el SQL se pueden utilizar en el SQ L hospedado, pero pr ecedidas de la cl\u00e1u - sula EXEC SQL . S\u00f3lo habr\u00e1 una excepci\u00f3n: cuando el resultado de una senten - cia SQL obtenga m\u00e1s de una fila o haga referencia tambi\u00e9 n a m\u00e1s de una, deberemos trabajar con el concepto de cursor . Un cursor se tiene que haber declarado antes de su utilizaci\u00f3n ( EXEC SQL DECLARE nombre_cursor CURSOR FOR). Para utilizarlo, se debe abrir ( EXEC SQL OPEN nombre_cursor ), ir tomando los datos uno a uno, tratarlos * Puede haber peque\u00f1as diferencias dependiendo del lenguaje de programaci\u00f3n concreto que estemos considerando. FUOC 71Z799014MO 52 El lenguaje SQL (EXEC SQL FETCH nombre_cursor INTO ), y finalmente, cerrarlo ( ( SQL/Call-Level Interface ), denominadas de forma abreviada CLI, permiten que aplicaciones desarrollada s en un cierto lenguaje de programa - ci\u00f3n (con s\u00f3lo las herramientas disponib les para este lenguaje y sin el uso de un precompilador) puedan incluir sent encias SQL mediante llamadas a libre - r\u00edas. Estas sentencias SQL se deben interpretar en tiempo de ejecuci\u00f3n del programa, a diferencia del SQL hospedad o, que requer\u00eda el uso de un pre - compilador. La interfaz ODBC (Open Database Connectivity ) define una librer\u00eda de funciones que permite a las aplicacion es acceder al SGBD utilizando el SQL. Las rutinas SQL/CLI est\u00e1n fuertemente basadas en las caracter\u00edsticas de la interfaz ODBC, y gracias al trabajo desarrollado por SAG-X/Open ( SQL Access Group-X/Open ), fueron a\u00f1adidas SQL92 en 1995. Las SQL/CLI son simplement e rutinas que llaman al SG BD para interpretar las sentencias SQL que pide la aplicaci\u00f3n. Desde el punt o de vista del SGBD, las SQL/CLI se pueden considerar, simp lemente, como otras aplicaciones. FUOC 71Z799014MO 53 El lenguaje SQL Resumen En esta unidad hemos pres entado las sentencias m\u00e1s utilizadas del lenguaje es - t\u00e1ndar ANSI/ISO SQL92 de definici\u00f3n, ma nipulaci\u00f3n y control de bases de da - tos relacionales. Como ya hemos comentad o en la introducci\u00f3n, el SQL es un lenguaje muy potente, y esto hace que existan m\u00e1s sentencias y opciones de las que hemos explicado en este m\u00f3dulo. Sin embargo, no es menos cierto que hemos visto m\u00e1s sentencias que las que algunos sistemas relacionales ofrecen actualmente. Hemos intentado seguir co n la mayor fidelidad el est\u00e1ndar, in - cluyendo comentarios s\u00f3lo cuando en la mayor\u00eda de los sistemas relacionales comerciales alguna operaci\u00f3n se hac\u00eda de forma distinta. Conociendo el SQL92 podemos trabajar con cualquier sistema relacional co - mercial; s\u00f3lo tendremos qu e dedicar unas cuantas horas a ver qu\u00e9 variaciones se dan con respecto al est\u00e1ndar. Recordemos c\u00f3mo ser\u00e1 la creaci\u00f3n de una base de datos con SQL : 1)En primer lugar, tendremos que dar nomb re a la base de datos, con la sen - tencia CREATE DATABASE , si continuaci\u00f3n definiremos las tablas , los dominios, las aserciones y las vistas que formar\u00e1n nuestra base de datos. 3)Una vez definidas las tablas, que estar\u00e1n completamente vac\u00edas, se deber\u00e1n llenar con la sentencia INSERT INTO . Cuando la base de datos tenga un conjun to de filas, la podremos manipular, ya sea actualizando filas o bien haci\u00e9ndo consultas. Adem\u00e1s, podemos usar todas las senten cias de control qu e hemos explicado. FUOC 71Z799014MO 55 El lenguaje SQL Actividad 1.Seguro que siempre hab\u00e9is querido saber d\u00f3nde ten\u00edais aquella pel\u00edcula de v\u00eddeo que nunca encontrabais. Por ello os proponemos crear una ba se de datos para organi zar las cintas de v\u00eddeo y localizarlas r\u00e1pidamente cuando os apetezca utilizarlas. Tendr\u00e9is que crear la base de datos y las tablas; tambi\u00e9n deber\u00e9 is decidir las claves primarias e insertar filas. Para almacenar las cintas de v\u00eddeo, tendremos que crear las siguientes tablas: a)Las cintas: querremos saber su c\u00f3digo, la esta nter\u00eda donde se encuentran, el estante y la fila, suponiendo que en un estante haya m\u00e1s de una fila. Tendremos que poner nosotros el c\u00f3digo de las cintas, con un rotulador, en el lomo de cada una. b)Las pel\u00edculas: querremos saber su c\u00f3digo, t\u00edtulo , director principal (en el caso de que haya m\u00e1s de uno) y el tema. El c\u00f3digo de las pel\u00edculas tambi\u00e9n lo tendremos que escribir nosotros con un rotulador para distinguir pe l\u00edculas que tienen el mismo nombre. c)Los actores: s\u00f3lo querremos saber de ellos un c\u00f3digo, el nombre y el apellido y, si somos aficionados al cine, otros datos que nos pueda interesar almacenar. El c\u00f3digo de los actores, que inventaremos nosotros, nos permitir\u00e1 dist inguir entre actores que se llaman igual. d)Pel\u00edculas que hay en cada cinta: en esta tabla pondremos el c\u00f3 digo de la cinta y el c\u00f3digo de la pel\u00edcula. En una cinta puede haber m\u00e1s de una pel\u00edcula, y podemos tener una pel\u00edcula repetida en m\u00e1s de una cinta; se debe tener en cuenta este hecho en el momento de elegir la clave primaria. e)Actores que aparecen en las pel\u00edculas: en esta tabla indicaremos el c\u00f3digo de la pel\u00edcula y el c\u00f3digo del actor. En una pel\u00edcula puede participar m\u00e1s de un actor y un actor puede aparecer en m\u00e1s de una pel\u00edcula; hay que tener presente este hecho cuando se elige la clave primaria. Esperamos que, adem\u00e1s de prac ticar sentencias de definici\u00f3n, manipulaci\u00f3n y control del SQL, esta actividad os resulte muy \u00fatil. Ejercicios de autoevaluaci\u00f3n Con la actividad anterior hemos practicado sentencias de definici\u00f3n y control del SQL. Me - diante las sentencias de manipulaci\u00f3n hemos insertado filas y, si nos hubi\u00e9semos equivocado, tambi\u00e9n habr\u00edamos borrado y modi ficado alguna fila. Con los ejercicios de autoevaluaci\u00f3n practicaremos la parte de sentencias de manipu laci\u00f3n que no hemos tratado todav\u00eda: las con - sultas. Los ejercicios que propon emos se har\u00e1n sobre la base de datos relacional BDUOC que ha ido apareciendo a lo largo de esta unidad. 1.Obtened los c\u00f3digos y los nombres y apellidos de los empleados, ordenados alfab\u00e9tica - mente de forma descendente por apellido y, en caso de repeticiones, por nombre. 2.Consultad el c\u00f3digo y el nombre de los proy ectos de los clientes que son de Barcelona. 3.Obtened los nombres y las ciudades de los de partamentos que trabajan en los proyectos n\u00famero 3 y n\u00famero 4. 4.De todos los empleados que perciben un sueldo de entre 50.000 y 80 .000 euros, buscad los c\u00f3digos de empleado y los nombres de los proyectos que tienen asignados. 5.Buscad el nombre, la ciudad y el tel\u00e9fono de los departamentos donde trabajan los em - pleados del proyecto GESCOM. 6.Obtened los c\u00f3digos y los nombres y apellidos de los empleados que trabajan en los pro - yectos de precio m\u00e1s alto. 7.Averiguad cu\u00e1l es el sueldo m\u00e1s alto de cada departamento. Concretamente, es necesario dar el nombre y la ciudad del depa rtamento y el sueldo m\u00e1s elevado. 8.Obtened los c\u00f3digos y los nombres de los clientes que tienen m\u00e1s de un proyecto contratado. 9.Averiguad los c\u00f3digos y los nombres de los proyectos cuyos empleados asignados tienen un sueldo superior a 30.000 euros. 10.Buscad los nombres y las ciudades de los de partamentos que no tienen ning\u00fan empleado asignado. FUOC 71Z799014MO 56 El lenguaje SQL Solucionario Ejercicios de autoevaluaci\u00f3n 1. 2.Con el SQL92 introductorio, la soluci\u00f3n ser\u00eda: Con el SQL92 intermedio o con el completo, la soluci\u00f3n ser\u00eda: 3. 4.Con el SQL92 introductorio, la soluci\u00f3n ser\u00eda: Con el SQL92 intermedio o con el completo, la soluci\u00f3n ser\u00eda: 5.Con el SQL92 introductorio, la soluci\u00f3n ser\u00eda: Con el SQL92 intermedio o con el completo, la soluci\u00f3n ser\u00eda:SELECT apellido_empl, and c.codigo_cli = p.codigo_cliente; SELECT p.codigo_proyec, p.nombre_proyec proyectos JOIN WHERE c.ciudad = e.codigo_empl, p.nombre_proyec FROM empleados e, proyectos WHERE 8.0E+4 and e. num_proyec = p.codigo_proyec; SELECT e.codigo_empl, p.nombre_proyec FROM empleados e JOIN p WHERE e.sueldo BETWEEN 5.0E+4 AND 8.0E+4; SELECT DISTINCT d.* FROM departamentos d, empleados e, proyectos p WHERE p. nombre_proyec = 'GESCOM' and d.nombre_dep = e.nombre_dep FROM JOIN proyectos p ON e.num_proyec = p.codigo_proyec WHERE p.nombre_proyec = 'GESCOM'; SQL92 introductorio, la soluci\u00f3n ser\u00eda: Con el SQL92 intermedio o con el completo, la soluci\u00f3n ser\u00eda: 7. 8.Con el SQL92 introductorio, la soluci\u00f3n ser\u00eda: Con el SQL92 intermedio o con el completo, la soluci\u00f3n ser\u00eda: 9.Con el SQL92 introductorio, la soluci\u00f3n ser\u00eda: Con el SQL92 intermedio o el completo, la soluci\u00f3n ser\u00eda: 10.SELECT e.codigo_empl, e.nombre_empl, e.apellido_empl FROM proyectos p, = p.codigo_proyec and p.precio e.codigo_empl, e.apellido_empl empleados e JOIN = p.codigo_proyec WHERE c.codigo_cli, c.nombre_cli FROM proyectos p, c = p.codigo_cliente GROUP (SELECT * FROM empleados e WHERE e.nombre_dep = d.nombre_dep AND e.ciudad_dep = d.ciudad_dep); FUOC 71Z799014MO 58 El lenguaje SQL o bien: Bibliograf\u00eda Bibliograf\u00eda b\u00e1sica El SQL92 se define, seg\u00fan lo busqu\u00e9is en ISO o en ANSI, en cualquiera de los dos documentos siguientes: Database Language SQL (1992). Document ISO/IEC 9075:1992. International Organization for Standardization (ISO). Database Language SQL (1992). Document ANSI/X3.135-1992. American National Standards Institute (ANSI). Date, C.J.; Darwen, H. (1997). A guide to the SQL Standard (4.a ed.). Reading, Massachusetts: Addison-Wesley. Los libros que contienen la descripci\u00f3n del est\u00e1 ndar ANSI/ISO SQL92 son bastante gruesos y pesados de leer. Este libro constituye un resumen del oficial. Date, C.J. (2001). Introducci\u00f3n a los sistemas de bases de datos (7\u00aa edici\u00f3n). Prentice Hall. Ten\u00e9is todav\u00eda una versi\u00f3n m\u00e1s re sumida de uno de los mismos au tores del libro anterior en el cap\u00edtulo 4 de este libro. Adem\u00e1s en el ap\u00e9ndice B pod\u00e9is en contrar una panor\u00e1mica de SQL3. Otros libros traducidos al castellano del SQ L92 que os recomendamos son los siguientes: Groff, J.R.; Weinberg, (1998). Gu\u00eda de SQL . Osborne: McGraw-Hill. Os recomendamos la consulta de este libro por su claridad y por los comentarios sobre el modo en el que se utiliza el est\u00e1ndar en los diferentes sistemas relacionales comerciales. Silberschatz, A.; Korth, H.F.; Sudarshan, S. (1998). datos . (3.a ed.). Madrid: McGraw-Hill. Pod\u00e9is encontrar una lectura r\u00e1pida, resumida, pe ro bastante completa del SQL en el cap\u00edtulo 4 de este libro. Por \u00faltimo, para profundizar en el estudio de SQL:1999 reco mendamos FUOC 71Z799014MO 59 El lenguaje SQL Anexos Anexo 1 Sentencias de definici\u00f3n 1)Creaci\u00f3n de esquemas: 2)Borrado de esquemas: 3)Creaci\u00f3n 4)Borrado de bases de 5)Creaci\u00f3n de tablas Donde tenemos lo siguiente: definici\u00f3n_columna es: Una de las restricciones de la tabla era la definici\u00f3n de claves for\u00e1neas:CREATE SCHEMA El 6)Modificaci\u00f3n lo siguiente formato: restricciones_dominio tiene DROP { 61 siguiente: acci\u00f3n_modificar_dominio puede ser: acci\u00f3n_modif_restricci\u00f3n_dominio puede ser: 10) Borrado de dominios creados por el usuario: 11) Definici\u00f3n de una aserci\u00f3n: 12) Borrado de una aserci\u00f3n: 13) Creaci\u00f3n de una vista: 14) Borrado de una vista: Anexo 2 Sentencias de manipulaci\u00f3n 1)Inserci\u00f3n de 2)Borrado de filas de una tabla 3)Modificaci\u00f3n de filas de una tabla: 4)Consultas de una base de datos relacional: Anexo 3 Sentencias de control 1)Iniciaci\u00f3n }; {COMMIT GRANT OPTION ]; REVOKE [GRANT OPTION FOR ] privilegios ON objeto FROM usuarios {RESTRICT |CASCADE};Introducci\u00f3n al dise\u00f1o de bases de datos Dolors Costal Costa FUOC 71Z799014MO Introducci\u00f3n al dise\u00f1o de bases de datos \u00cdndice Introducci\u00f3n ............................................................................................... 5 Objetivos ...................................................................................................... 5 1. Introducci\u00f3n al dise\u00f1o de bases de datos ...................................... 7 1.1. Etapas del dise\u00f1o de bases de datos................................................... 7 2. Dise\u00f1o conceptual: el modelo ER ..................................................... 10 2.1. Construcciones b\u00e1sicas...................................................................... 11 2.1.1. Entidades, atributos e interrelaciones.................................... 11 2.1.2. Grado de las interrelaciones................................................... 13 2.1.3. Interrelaciones binarias.......................................................... 16 2.1.4. Ejemplo: base de datos de casas de colonias.......................... 18 2.1.5. Interrelaciones n-arias ............................................................ 21 2.1.6. Interrelaciones recursivas....................................................... 23 2.1.7. Entidades d\u00e9biles.................................................................... 25 2.2. Extensiones del modelo ER ............................................................... 26 2.2.1. Generalizaci\u00f3n/especializaci\u00f3n.............................................. 26 2.2.2. Entidades asociativas.............................................................. 28 2.3. Ejemplo: base de datos del personal de una entidad bancaria ......... 30 3. Dise\u00f1o l\u00f3gico: la transformaci\u00f3n del modelo ER al modelo relacional ............................................... 35 3.1. Introducci\u00f3n a la transformaci\u00f3n de entidades e interrelaciones................................................................................. 35 3.2. Transformaci\u00f3n de entidades ............................................................ 35 3.3. Transformaci\u00f3n de interrelaciones binarias...................................... 36 3.3.1. Conectividad 1:1 .................................................................... 36 3.3.2. Conectividad 1:N ................................................................... 37 3.3.3. Conectividad M:N.................................................................. 38 3.3.4. Influencia de la dependencia de existencia en la transformaci\u00f3n de las interrelaciones binarias ............. 39 3.4. Transformaci\u00f3n de interrelaciones ternarias..................................... 40 3.4.1. Conectividad 40 43 3.5. Transformaci\u00f3n de interrelaciones n-arias ........................................ 44 3.6. Transformaci\u00f3n de interrelaciones recursivas................................... 44 3.7. Transformaci\u00f3n de entidades d\u00e9biles................................................ 46 3.8. Transformaci\u00f3n de la generalizaci\u00f3n/especializaci\u00f3n....................... 47 FUOC 71Z799014MO Introducci\u00f3n al dise\u00f1o de bases de datos 3.9. Transformaci\u00f3n de entidades asociativas....................................... 48 3.10. Resumen de la transf ormaci\u00f3n del modelo ER al modelo relacional....................................................................... 49 3.11. Ejemplo: base de datos del personal de una entidad bancaria ...... 49 Resumen ....................................................................................................... 51 Ejercicios de autoevaluaci\u00f3n .................................................................. 53 ........................................................................................................ 59 Bibliograf\u00eda ................................................................................................. 60 FUOC 71Z799014MO 5 Introducci\u00f3n al dise\u00f1o de bases de datos Introducci\u00f3n al dise\u00f1o de bases de datos Introducci\u00f3n En otras unidades did\u00e1cticas se estudian las bases de datos relacionales y un lenguaje relacional, SQL, que nos proporciona mecanismos para crear, actua - lizar y consultar estas bases de datos. Es necesario complementar estos conoci mientos con un aspecto que es funda - mental para poder utilizar adecuadamente la tecnolog\u00eda de las bases de datos re - lacionales: el dise\u00f1o. \u00c9ste ser\u00e1 el objeto de estudio de esta unidad, que tratar\u00e1 el dise\u00f1o de bases de datos para el caso espec\u00edfico del modelo relacional. Concretamente, en es ta unidad explicaremos en qu \u00e9 consiste el dise\u00f1o de una base de datos, analizaremos las etapas en las que se puede descomponer y des - cribiremos con detalle las etapas del di se\u00f1o conceptual y l\u00f3gico de una base de datos relacional. Objetivos En los materiales did\u00e1cticos de esta unidad encontrar\u00e9is las herramientas indispensables para alcanzar los siguientes objetivos: 1.Conocer las etapas que integran el proc eso del dise\u00f1o de una base de datos. 2.Conocer las estructuras del modelo ER. 3.Saber hacer el dise\u00f1o conceptual de lo s datos de un sistema de informaci\u00f3n mediante el modelo ER. 4.Saber hacer el dise\u00f1o l\u00f3gico de una base de datos relacional partiendo de un dise\u00f1o conceptual expr esado con el modelo ER. FUOC 71Z799014MO 7 Introducci\u00f3n al dise\u00f1o de bases de datos 1. Introducci\u00f3n al dise\u00f1o de bases de datos En otras unidades hemos aprendido c\u00f3mo es una base de datos relacional y hemos estudiado un lenguaje, el SQL, que nos proporciona mecanismos para crear estas bases de datos, as\u00ed como para actualizarlas y consultarlas. Sin embargo, todav\u00eda debemos resolver algunas cuestiones fundamentales para poder emplear la tecn olog\u00eda de las bases de datos relacionales; por ejem - plo, c\u00f3mo se puede decidir qu\u00e9 relaciones debe tener una base de datos deter - minada o qu\u00e9 atributos deben presentar las relaciones, qu\u00e9 claves primarias y qu\u00e9 claves for\u00e1neas se deben declarar, etc. La tarea de tomar este conjunto de decisiones recibe el nombre de dise\u00f1ar la base de datos . Una base de datos sirve para almacenar la informaci\u00f3n que se utiliza en un sis - tema de informaci\u00f3n determ inado. Las necesidades y los requisitos de los fu - turos usuarios del sistema de informaci\u00f3n se deben te ner en cuenta para poder tomar adecuadamente las decisiones anteriores. Si record\u00e1is los tres mundos presentados -el real, el conceptual y el de las re - presentaciones-, observar\u00e9is que el dise\u00f1o de una base de datos consiste en la obtenci\u00f3n de una representaci\u00f3n inform\u00e1t ica concreta a partir del estudio del mundo real de inter\u00e9s. 1.1. Etapas del dise\u00f1o de bases de datos El dise\u00f1o de una base de datos no es un proceso sencillo. Habitualmente, la complejidad de la informaci\u00f3n y la cantid ad de requisitos de los sistemas de informaci\u00f3n hacen que sea complicado. Por este motivo, cuando se dise\u00f1an bases de datos es interesante aplicar la vieja estrategia de dividir para vencer. Por lo tanto, conviene descomponer el pr oceso del dise\u00f1o en varias etapas; en cada una se obtiene un resultado interm edio que sirve de punto de partida de la etapa siguiente, y en la \u00faltima etapa se obtiene el resultado deseado. De este modo no hace falta resolver de golpe toda la problem\u00e1tica que plantea el di - se\u00f1o, sino que en cada etapa se afronta un solo tipo de su bproblema. As\u00ed se divide el problema y, al mismo tiempo, se simplifica el proceso.En resumen, el dise\u00f1o de una base de datos consiste en definir la es - tructura de los datos que debe tener la base de datos de un sistema de informaci\u00f3n determinado. En el caso relacional, esta estructura ser\u00e1 un conjunto de esquemas de relaci\u00f3n con sus atributos, dominios de atri - butos, claves primarias, claves for\u00e1neas, etc.Recordad que las bases de datos relacionales y los lenguajes SQL se han estudiado en las unidades \"El modelo relacional y el \u00e1lgebra relacional\" y \"El lenguaje SQL\", respectivamente. FUOC 71Z799014MO 8 Introducci\u00f3n al dise\u00f1o de bases de datos Descompondremos el dise\u00f1o de bases de datos en tres etapas: 1) Etapa del dise\u00f1o conceptual: en esta etapa se obtiene una estructura de la informaci\u00f3n de la futura BD independ iente de la tecnolog\u00eda que hay que em - plear. No se tiene en cuenta todav\u00eda qu\u00e9 tipo de base de datos se utilizar\u00e1 -rela - cional, orientada a objetos, jer\u00e1rquica, et c.-; en consecuencia, tampoco se tiene en cuenta con qu\u00e9 SGBD ni con qu\u00e9 lenguaje concreto se implementar\u00e1 la base de datos. As\u00ed pues, la etapa del dise\u00f1o conceptual nos permite concentrarnos \u00fanicamente en la problem\u00e1tica de la estr ucturaci\u00f3n de la informaci\u00f3n, sin tener que preocuparnos al mismo tiempo de resolver cuestiones tecnol\u00f3gicas. El resultado de la etapa del dise\u00f1o conceptual se expresa mediante alg\u00fan mo - delo de datos de alto nivel. Uno de los m\u00e1s empleados es el modelo entidad- interrelaci\u00f3n (entity-relationship ), que abreviaremos con la sigla ER. 2) Etapa del dise\u00f1o l\u00f3gico : en esta etapa se parte del resultado del dise\u00f1o conceptual, que se transforma de forma que se adapte a la tecnolog\u00eda que se debe emplear. M\u00e1s concretamente, es preciso que se ajuste al modelo del SGBD con el que se desea implementar la ba se de datos. Por ejemplo, si se trata de un SGBD relacional, esta etapa obtendr\u00e1 un conjunto de relaciones con sus atributos, claves primarias y claves for\u00e1neas. Esta etapa parte del hecho de que ya se ha resuelto la problem\u00e1tica de la es - tructuraci\u00f3n de la informaci\u00f3n en un \u00e1mbito conceptual, y permite concen - trarnos en las cuestiones tecnol\u00f3gicas re lacionadas con el modelo de base de datos. M\u00e1s adelante explicaremos c\u00f3mo se hace el dise\u00f1o l\u00f3gico de una base de datos relacional, tomando como punto de part ida un dise\u00f1o conceptual expresado con el modelo ER; es decir, veremos c\u00f3 mo se puede transformar un modelo ER en un modelo relacional. 3) Etapa del dise\u00f1o f\u00edsico: en esta etapa se transforma la estructura obtenida en la etapa del dise\u00f1o l\u00f3gico, con el objetivo de conseguir una mayor eficien - cia; adem\u00e1s, se completa con aspectos de implementaci\u00f3n f\u00edsica que depende - r\u00e1n del SGBD. Por ejemplo, si se trata de una base de datos relacional, la transformaci\u00f3n de la estructura puede consistir en lo siguiente: tener almacenada alguna relaci\u00f3n que sea la combinaci\u00f3n de varias relaciones que se han obtenido en la etapa del dise\u00f1o l\u00f3gico, partir una relaci\u00f3n en varias, a\u00f1adir alg\u00fan atributo calcula - ble a una relaci\u00f3n, etc. Los aspectos de implementaci\u00f3n f\u00edsica que hay que completar consisten normalme nte en la elecci\u00f3n de estructuras f\u00edsicas de im - plementaci\u00f3n de las relaci ones, la selecci\u00f3n del tama \u00f1o de las memorias inter - medias ( buffers ) o de las p\u00e1ginas, etc. El resultado del dise\u00f1o conceptual Si retomamos la idea de los tres mundos, podemos afirmar que la etapa del dise\u00f1o conceptual obtiene un resultado que se sit\u00faa en el mundo de las concepciones, y no en el mundo de las representaciones. La forma de elaborar un dise\u00f1o conceptual expresado con el modelo ER se explica en el apartado 2 de esta unidad. El resultado del dise\u00f1o l\u00f3gico El resultado del dise\u00f1o l\u00f3gico se sit\u00faa ya en el mundo de las representaciones. El dise\u00f1o l\u00f3gico de una base de datos relacional se explica en el apartado 3 de esta unidad did\u00e1ctica. El resultado del dise\u00f1o f\u00edsico El resultado de la etapa del dise\u00f1o f\u00edsico se sit\u00faa en el mundo de las representa-ciones, al igual que el resultado de la etapa del dise\u00f1o l\u00f3gico. La diferencia con respecto a la etapa anterior es que ahora se tienen en cuenta aspectos de car\u00e1cter m\u00e1s f\u00edsico del mundo de las representaciones. FUOC 71Z799014MO 9 Introducci\u00f3n al dise\u00f1o de bases de datos En la etapa del dise\u00f1o f\u00edsico -con el objetivo de conseguir un buen rendimien - to de la base de datos-, se deben tener en cuenta las caracter\u00edsticas de los pro - cesos que consultan y actu alizan la base de dato s, como por ejemplo los caminos de acceso que utilizan y las fre cuencias de ejecuci\u00f3n. Tambi\u00e9n es ne - cesario considerar los vol\u00fa menes que se espera tener de los diferentes datos que se quieren almacenar. FUOC 71Z799014MO 10 Introducci\u00f3n al dise\u00f1o de bases de datos 2. Dise\u00f1o conceptual: el modelo ER En este apartado trataremos el dise\u00f1o conceptual de una base de datos me - diante el modelo ER. Lo que explicaremos es aplicable al dise\u00f1o de cualquier tipo de bases de datos -relacional, jer\u00e1rquica, etc.-, porque, como ya hemos dicho, en la etapa del dise\u00f1o conceptual todav\u00eda no se tiene en cuenta la tec - nolog\u00eda concreta que se utilizar\u00e1 para implementar la base de datos. El modelo ER es uno de los enfoques de mode lizaci\u00f3n de datos que m\u00e1s se uti - liza actualmente por su simp licidad y legibilidad. Su le gibilidad se ve favoreci - da porque proporciona una notaci\u00f3n di agram\u00e1tica muy comprensiva. Es una herramienta \u00fatil tanto para ayudar al di se\u00f1ador a reflejar en un modelo con - ceptual los requisitos del mundo real de inter\u00e9s como para comunicarse con el usuario final sobre el modelo concep tual obtenido y, de este modo, poder verificar si satisface sus requisitos. El modelo ER resulta f\u00e1cil de aprender y de utilizar en la mayor\u00eda de las aplica - ciones. Adem\u00e1s, existen herramientas info rm\u00e1ticas de ayuda al dise\u00f1o (herra - mientas CASE*) que utilizan alguna variante del modelo ER para hacer el dise\u00f1o de los datos. El nombre completo del modelo ER es entity-relationship , y proviene del hecho de que los principales elementos que incluye son las entidades y las interrelaciones (entities y relationships ). Traduciremos este nombre por 'entidad-interrelaci\u00f3n'. El origen del modelo ER se encuentra en trabajos efectuados por Peter Chen en 1976. Posteriormente, muchos otros auto res han descrito variantes y/o exten - siones de este modelo. As\u00ed pues, en la literatura se encuentran muchas formas diferentes del modelo ER que pueden va riar simplemente en la notaci\u00f3n diagra - m\u00e1tica o en algunos de los conceptos en que se basan para modelizar los datos. Cuando se quiere utilizar el modelo ER para comunicarse con el usuario, es re - comendable emplear una variante del modelo que incluya s\u00f3lo sus elementos m\u00e1s simples -entidades, atributos e inte rrelaciones- y, tal vez, algunas cons - trucciones adicionales, co mo por ejemplo entidades d\u00e9biles y dependencias de existencia. \u00c9stos eran los elementos incl uidos en el modelo original propuesto por Chen. En cambio, para llevar a cabo la tarea de modelizar propiamente di - cha, suele ser \u00fatil usar un modelo ER m\u00e1s completo que incluya construccio - nes m\u00e1s avanzadas que extienden el modelo original. Seg\u00fan la noci\u00f3n de modelo de datos que hemos utilizado en los otros m\u00f3dulos, un modelo de datos tiene en cuenta tres aspectos de los datos: la estructura, la manipulaci\u00f3n y la integridad. Sin emba rgo, el modelo ER habitualmente se * La sigla CASE corresponde al t\u00e9rmino ingl\u00e9s Computer Aided Software Engineering . El modelo entidad- interrelaci\u00f3n Algunos autores denominan entidad-relaci\u00f3n al modelo ER, pero en nuestro caso hemos preferido traducir relationship por 'interrelaci\u00f3n' y no por 'relaci\u00f3n', con el objetivo de evitar confusiones entre este concepto y el de relaci\u00f3n que se utiliza en el modelo relacional. Recordad el modelo relacional, que se ha estudiado en la unidad \"El modelo relacional y el \u00e1lgebra relacional\". FUOC 71Z799014MO 11 Introducci\u00f3n al dise\u00f1o de bases de datos utiliza para reflejar aspectos de la estr uctura de los datos y de su integridad, pero no de su manipulaci\u00f3n. 2.1. Construcciones b\u00e1sicas 2.1.1. Entidades, atributos e interrelaciones Ejemplos de entidad Algunos ejemplos de entidad son un empleado , un producto o un despacho. Tambi\u00e9n son entidades otros elementos del mu ndo real de inter\u00e9s, menos tangibles pero igualmente dife - renciables del resto de objetos; por ejemplo, una asignatura impartid a en una universidad, un pr\u00e9stamo bancario, un pedido de un cliente, etc. Ejemplos de atributo Sobre una entidad empleado nos puede interesar, por ejemplo, tener registrados su DNI, su NSS, su nombre, su apellido y su sueldo como atributos. El t\u00e9rmino entidad se utiliza tanto para denomina r objetos individuales como para hacer referencia a conjuntos de ob jetos similares de lo s que nos interesan los mismos atributos; es de cir, que, por ejemplo, se utiliza para designar tanto a un empleado concreto de una empres a como al conjunto de todos los em - pleados de la empresa. M\u00e1s concretamente, el t\u00e9rmino entidad se puede referir a instancias u ocurrencias concretas (empleados concretos) o a tipos o cla - ses de entidades (el conjunto de todos los empleados). El modelo ER proporciona una notaci\u00f3n diagram\u00e1tica para representar gr\u00e1 - ficamente las entidades y sus atributos: L a s entidades se representan con un rect\u00e1ngulo. El nombre de la entidad se escribe en may\u00fasculas dentro del rect\u00e1ngulo. L o s atributos se representan mediante su nombre en min\u00fasculas unido con un gui\u00f3n al rect\u00e1ngulo de la en tidad a la que pertenecen. Muchas ve - ces, dado que hay muchos atributos para cada entidad, se listan todos apar - te del diagrama para no complicarlo. Cada uno de los atributos de una entida d toma valores de un cierto dominio o conjunto de valores. Los valores de los dominios deben ser at \u00f3micos; es decir, Por entidad entendemos un objeto del mundo real que podemos dis - tinguir del resto de objetos y del que nos interesan algunas propiedades. Las propiedades de los objetos que nos interesan se denominan atributos . Notaci\u00f3n diagram\u00e1tica de entidades y atributos La figura muestra la notaci\u00f3n diagram\u00e1tica para el caso de una entidad empleado con los atributos dni, nss, nombre , apellido y sueldo . FUOC 71Z799014MO 12 Introducci\u00f3n al dise\u00f1o de bases de datos no deben poder ser descompuestos. Adem\u00e1s, todos los atributos tienen que ser univaluados. Un atributo es univaluado si tiene un \u00fanico valor para cada ocu - rrencia de una entidad. Ejemplo de atributo univaluado El atributo sueldo de la entidad empleado , por ejemplo, toma valores del dominio de los reales y \u00fanicamente toma un valor para cada empleado concreto; por lo tanto, ning\u00fan empleado puede tener m\u00e1s de un valor para el sueldo. Como ya hemos comentado anteriormente, una entidad debe ser distinguible del resto de objetos del mundo real. Esto hace que para toda entidad sea posi - ble encontrar un conjunto de atributos que permitan identificarla. Este con - junto de atributos forma una clave de la entidad . Ejemplo de clave La entidad empleado tiene una clave que consta del atributo dni porque todos los empleados tienen n\u00fameros de DNI diferentes. Una determinada entidad puede tener m\u00e1s de una clave; es decir, puede tener varias claves candidatas . Ejemplo de clave candidata La entidad empleado tiene dos claves candidatas, la que est\u00e1 formada por el atributo dni y la que est\u00e1 constituida por el atributo nss, teniendo en cuenta que el NSS tambi\u00e9n ser\u00e1 diferente para cada uno de los empleados. El dise\u00f1ador elige una clave primaria entre todas las claves candidatas. En la notaci\u00f3n diagram\u00e1tica, la clave primaria se subraya para dist inguirla del resto de las claves. Ejemplo de clave primaria En el caso de la entidad empleado , podemos elegir dni como clave primaria. En la figura del margen vemos que la clave primaria se subraya para distinguirla del resto. Las interrelaciones se representan en los diagramas del modelo ER mediante un rombo. Junto al rombo se indica el nombre de la interrelaci\u00f3n con letras may\u00fasculas. Ejemplo de interrelaci\u00f3n Consideremos una entidad empleado y una entidad despacho y supongamos que a los emplea - dos se les asignan despachos donde trabajar. En tonces hay una interrelaci\u00f3n entre la entidad empleado y la entidad despacho . Esta interrelaci\u00f3n, que podr\u00edamos denominar asignaci\u00f3n , asocia a los empleados con los des - pachos donde trabajan. La figura de l margen muestra la interrelaci\u00f3n asignaci\u00f3n entre las en - tidades empleado y despacho . El t\u00e9rmino interrelaci\u00f3n se puede utilizar tanto pa ra denominar asociaciones concretas u ocurrencias de asociaciones como para designar conjuntos o clases de asociaciones similares.Se define interrelaci\u00f3n como una asociaci\u00f3n entre entidades.Recordad que los valores de los atributos de las relaciones tambi\u00e9n deben ser at\u00f3micos, tal y como se ha explicado en la unidad \"El modelo relacional y el \u00e1lgebra relacional\". Los conceptos de clave candidata y clave primaria de una entidad son similares a los conceptos de clave candidata y clave primaria de una relaci\u00f3n, que hemos estudiado en la unidad \"El modelo relacionaly el \u00e1lgebra relacional\". FUOC 71Z799014MO 13 Introducci\u00f3n al dise\u00f1o de bases de datos Ejemplo Una interrelaci\u00f3n se aplica tanto a una asoc iaci\u00f3n concreta entre el empleado de DNI '50.455.234' y el despacho 'Diagonal, 20' como a la asociaci\u00f3n gen\u00e9rica entre la entidad em- pleado y la entidad despacho . Los atributos de las interrelaciones se representan mediante su nombre en min\u00fas - culas unido con un gui\u00f3n al rombo de la interrelaci\u00f3n a la que pertenecen. Ejemplo de atributo de una interrelaci\u00f3n Observemos la entidad estudiante y la entidad asignatura que se muestran en la figura siguiente: Entre estas dos entidades se establece la interrelaci\u00f3n evaluaci\u00f3n para indicar de qu\u00e9 asigna - turas han sido evaluados los estudiantes. Esta interrelaci\u00f3n tiene el atributo nota, que sirve para especificar qu\u00e9 nota han obtenido lo s estudiantes de las asignaturas evaluadas. Conviene observar que el atributo nota deber ser forzosamente un at ributo de la interrelaci\u00f3n evaluaci\u00f3n , y que no ser\u00eda correcto considerarlo un atributo de la entidad estudiante o un atri - buto de la entidad asignatura . Lo explicaremos analizando las ocurrencias de la interrelaci\u00f3n evaluaci\u00f3n que se muestran en la figura anterior. Si nota se considerase un atributo de estudiante , entonces para el estudiante 'E1' de la figura necesitar\u00edamos dos valores del atributo, uno para cada asignatura que tiene el estudiante; por lo tanto, no ser\u00eda univaluado. De forma similar, si nota fuese atributo de asignatura tampoco podr\u00eda ser univaluado porque, por ejemplo, la asignatura 'A1' requerir\u00eda tres valores de nota, una para cada estudiante que se ha matriculad o en ella. Podemos concluir que el atributo nota est\u00e1 relacionado al mismo tiempo con una asignatura y con un estudiante que la cursa y que, por ello, debe ser un atributo de la interrelaci\u00f3n que asocia las dos entidades. 2.1.2. Grado de las interrelacionesEn ocasiones interesa reflejar algunas propiedades de las interrelacio - nes. Por este motivo, las interrelaciones pueden tener tambi\u00e9n atribu - tos. Los atributos de las interrelaciones , igual que los de las entidades, tienen un cierto dominio, deben tomar valores at\u00f3micos y deben ser univaluados. Una interrelaci\u00f3n puede asociar dos o m\u00e1s entidades. El n\u00famero de en - tidades que asocia una interrelaci\u00f3n es el grado de la interrelaci\u00f3n . FUOC 71Z799014MO 14 Introducci\u00f3n al dise\u00f1o de bases de datos Interrelaciones de grado dos Las interrelaciones evaluaci\u00f3n y asignaci\u00f3n de los ejemplos anteriores tienen grado dos: La interrelaci\u00f3n evaluaci\u00f3n asocia la entidad estudiante y la entidad asignatura ; es decir, aso - cia dos entidades. De forma an\u00e1loga, la interrelaci\u00f3n asignaci\u00f3n asocia empleado y despacho . Las interrelaciones de grad o dos se denominan tambi\u00e9n interrelaciones bina - rias. Todas las interrelaciones de grado mayor que dos se denominan, en con - junto, interrelaciones n-arias . As\u00ed pues, una interrelaci\u00f3n n-aria puede tener grado tres y ser una interrelaci\u00f3n ternar ia, puede tener grado cuatro y ser una interrelaci\u00f3n cuaternaria, etc. A continuaci\u00f3n presentaremos un ejemplo que nos ilustrar\u00e1 el hecho de que, en ocasiones, las interrelaciones binari as no nos permiten modelizar correcta - mente la realidad y es necesario utilizar interrela ciones de mayor grado. Consideremos la interrelaci\u00f3n evaluaci\u00f3n de la figura anterior, que tiene un atributo nota. Este atributo permite registrar la nota obtenida por cada estu - diante en cada asignatura de la que ha sido evaluado. Una interrelaci\u00f3n permite establecer una sola asocia ci\u00f3n entre unas entidades individuales determinadas. En otras palabras, s\u00f3lo se puede interrelac ionar una vez al estudiante 'E1' con la asignatura 'A1' v\u00eda la interrelaci\u00f3n evaluaci\u00f3n. Observad que, si pudiese haber m\u00e1s de una interrelaci\u00f3n entre el estudiante 'E1' y la asignatura 'A1', no podr\u00edamos distinguir estas dife rentes ocurrencias de la interrelaci\u00f3n. Esta restricci\u00f3n hace que se registre una sola nota por estu - diante y asignatura. Supongamos que deseamos registrar vari as notas por cada asignatura y estu - diante correspondientes a varios semestre s en los que un mismo estudiante ha cursado una asignatura determinada (desgraciadamente, algunos estudiantes tienen que cursar una asignatura varias ve ces antes de aprobarla). La interrelaci\u00f3n FUOC 71Z799014MO 15 Introducci\u00f3n al dise\u00f1o de bases de datos anterior no nos permitir\u00eda reflejar este caso. Ser\u00eda ne cesario aumentar el grado de la interrelaci\u00f3n, tal y como se muestra en la figura siguiente: La interrelaci\u00f3n ternaria evaluaci\u00f3n-semestral asocia estudiantes, asignaturas y una tercera entidad que denominamos semestre . Su atributo nota nos permite reflejar todas las notas de una asigna tura que tiene un estudiante correspon - dientes a diferentes semestres. De hecho, lo que sucede en este caso es que, seg\u00fan los requisitos de los usua - rios de esta BD, una nota pertenece al mismo tiempo a un estudiante, a una asignatura y a un semestre y, l\u00f3gicamente, debe ser un atributo de una inte - rrelaci\u00f3n ternaria entre estas tres entidades. Este ejemplo demuestra que una interrelaci\u00f3n binaria puede no ser suficiente para satisfacer los requisitos de los us uarios, y puede ser necesario aplicar una interrelaci\u00f3n de mayor grado. Conviene observar que esto tambi\u00e9n puede ocu - rrir en interrelaciones qu e no tienen atributos. Ejemplo de interrelaci\u00f3n ternaria sin atributos Consideremos un caso en el que deseamos saber para cada estudiante qu\u00e9 asignaturas ha cur - sado cada semestre, a pesar de que no queremos registrar la nota que ha obtenido. Entonces aplicar\u00edamos tambi\u00e9n una interrelaci \u00f3n ternaria entre las entidades estudiante , asignatura y se- mestre que no tendr\u00eda atributos, tal y como se muestra en la figura siguiente: Hemos analizado casos en los que era nece sario utilizar interrelaciones ternarias para poder modelizar correctamente cier tas situaciones de inter\u00e9s del mundo FUOC 71Z799014MO 16 Introducci\u00f3n al dise\u00f1o de bases de datos real. Es preciso remarcar que, de forma similar, a veces puede ser necesario uti - lizar interrelaciones de grado todav\u00eda mayor: cuaternarias, etc. En el subapartado siguiente analizaremos con detalle las interrelaciones bina - rias, y m\u00e1s adelante, las interrelaciones n-arias. 2.1.3. Interrelaciones binarias Conectividad de las in terrelaciones binarias Una interrelaci\u00f3n binaria entre dos en tidades puede tener tres tipos de co - nectividad: Conectividad uno a uno (1:1). La conectividad 1:1 se denota poniendo un 1 a lado y lado de la interrelaci\u00f3n. Conectividad uno a muchos (1:N ). La conectividad 1:N se denota po - niendo un 1 en un lado de la interrelaci\u00f3n y una N en el otro. Conectividad muchos a muchos: (M:N) . La conectividad M:N se denota poniendo una M en uno de los lados de la interrelaci\u00f3n, y una N en el otro. Ejemplos de conectividad en una interrelaci\u00f3n binaria A continuaci\u00f3n analizaremos un ejemplo de ca da una de las conectividades posibles para una interrelaci\u00f3n binaria: a) Conectividad 1:1La conectividad de una interrelaci\u00f3n expresa el tipo de corresponden - cia que se establece entre las ocurre ncias de entidades asociadas con la interrelaci\u00f3n. En el caso de las in terrelaciones binarias, expresa el n\u00fa - mero de ocurrencias de una de las entidades con las que una ocurrencia de la otra entidad puede estar asociada seg\u00fan la interrelaci\u00f3n. Las relaciones n-arias se analizan en el subapartado 2.1.4 de esta unidad did\u00e1ctica. FUOC 71Z799014MO 17 Introducci\u00f3n al dise\u00f1o de bases de datos La interrelaci\u00f3n anterior tiene conectividad 1:1. Esta interrelaci\u00f3n asocia las delegaciones de una empresa con las ciudades donde est\u00e1n si tuadas. El hecho de que sea 1:1 indica que una ciudad tiene s\u00f3lo una delegaci\u00f3n, y que una delegaci\u00f3n est\u00e1 situada en una \u00fanica ciudad. b) Conectividad 1:N La interrelaci\u00f3n asignaci\u00f3n entre la entidad empleado y la entidad despacho tiene conectividad 1:N, y la N est\u00e1 en el lado de la entidad empleado . Esto significa que un empleado tiene un solo despacho asignado, pero que, en cambio, un despacho puede tener uno o m\u00e1s emplea - dos asignados. c) Conectividad M:N Para analizar la conectividad M: N, consideramos la interrelaci\u00f3n evaluaci\u00f3n de la figura ante - rior. Nos indica que un estudian te puede ser evaluado de varias asignaturas y, al mismo tiem - po, que una asignatura puede tener varios estudiantes por evaluar. Es muy habitual que las interrel aciones binarias M:N y todas las n-arias tengan atributos. En cambio, las interrelaciones binarias 1: 1 y 1:N no tienen por qu\u00e9 tenerlos. Siempre se pueden asignar estos atributos a la entidad del lado N, en el caso de las 1:N, y a cualquiera de las dos entidades interrelacionadas en el caso de las 1:1. Este cambio de situac i\u00f3n del atributo se puede hacer porque no origina un atributo multivaluado. FUOC 71Z799014MO 18 Introducci\u00f3n al dise\u00f1o de bases de datos Dependencias de existencia en las interrelaciones binarias En el modelo ER, un c\u00edrculo en la l\u00ed nea de conexi\u00f3n entre una entidad y una interrelaci\u00f3n indica que la entidad es op cional en la interrelaci\u00f3n. La obligato - riedad de una entidad a una interrelaci\u00f3n se indica con una l\u00ednea perpendicular. Si no se consigna ni un c\u00edrculo ni una l\u00ednea perpendicular, se considera que la dependencia de existencia es desconocida. Ejemplo de dependencias de existencia La figura siguiente nos servir\u00e1 para entender el significado pr\u00e1ctico de la dependencia de exis - tencia. La entidad empleado es obligatoria en la interrelaci\u00f3n direcci\u00f3n . Esto indica que no pue - de existir un departamento que no tenga un empleado que act\u00faa de director del departamento. La entidad departamento , en cambio, es opcional en la interrelaci\u00f3n direcci\u00f3n . Es posible que haya un empleado que no est\u00e1 interrelacionado con ning\u00fan departamento: puede haber -y es el caso m\u00e1s frecuente- em pleados que no son directores de departamento. Aplicaremos la dependencia de existencia en las interrelacion es binarias, pero no en las n-arias. 2.1.4. Ejemplo: base de da tos de casas de colonias En este punto, y antes de continuar explicando construcciones m\u00e1s complejas del modelo ER, puede result ar muy ilustrativo ver la aplicaci\u00f3n pr\u00e1ctica de las construcciones que hemos estudiado hasta ahora. Por este motivo, analizare - mos un caso pr\u00e1ctico de dise\u00f1o con el modelo ER que corresponde a una base de datos destinada a la gest i\u00f3n de las inscripciones en un conjunto de casas de colonias. El modelo ER de esta base de datos ser\u00e1 bastante sencillo e incluir\u00e1 s\u00f3lo entidades, atributos e interrelaciones binarias (no incluir\u00e1 interrelaciones n-arias ni otros tipos de estructuras).En algunos casos, una entidad individual s\u00f3lo puede existir si hay como m\u00ednimo otra entidad individual asociada con ella mediante una interre - laci\u00f3n binaria determinada. En estos casos, se dice que esta \u00faltima enti - dad es una entidad obligatoria en la interrelaci\u00f3n . Cuando esto no sucede, se dice que es una entidad opcional en la interrelaci\u00f3n . FUOC 71Z799014MO 19 Introducci\u00f3n al dise\u00f1o de bases de datos La descripci\u00f3n siguiente explica con de talle los requisitos de los usuarios que hay que tener en cuenta al hacer el dise\u00f1o conceptual de la futura base de datos: a)Cada casa de colonias tiene un nombre que la identifica. Se desea saber de cada una, aparte del nombre, la capacidad (el n\u00famero de ni\u00f1os que se pueden alojar en cada una como m\u00e1ximo), la comarca donde est\u00e1 situada y las ofertas de actividades que proporciona. Una ca sa puede ofrecer ac tividades como por ejemplo nataci\u00f3n, esqu\u00ed, remo, pintura, fotograf\u00eda, m\u00fasica, etc. b)Es necesario tener en cuenta que en una casa de colonias se pueden practi - car varias actividades (de hecho, cada casa debe ofrecer como m\u00ednimo una), y tambi\u00e9n puede ocurrir que una misma ac tividad se pueda llevar a cabo en va - rias casas. Sin embargo, toda actividad qu e se registre en la base de datos debe ser ofertada como m\u00ednimo en una de las casas. c)Interesa tener una evaluaci\u00f3n de las ofer tas de actividades que proporcio - nan las casas. Se asigna una calificaci\u00f3n num\u00e9rica que indica el nivel de cali - dad que tiene cada una de las actividades ofertadas. d)Las casas de colonias alojan ni\u00f1os que se han inscrito para pasar en ellas unas peque\u00f1as vacaciones. Se quiere tener cons tancia de los ni\u00f1os que se alojan en cada una de las casas en el momento actual. Se debe suponer que hay casas que est\u00e1n vac\u00edas (en las que no se aloja ning\u00fan ni\u00f1o) durante algunas temporadas. e)De los ni\u00f1os que se alojan actualmente en alguna de las casas, interesa cono - cer un c\u00f3digo que se les asigna para iden tificarlos, su nombre, su apellido, el n\u00fa - mero de tel\u00e9fono de sus padres y su comarca de residencia. f)De las comarcas donde hay casas o bien donde residen ni\u00f1os, se quiere te - ner registrados la superficie y el n\u00famero de habitantes . Se debe considerar que puede haber comarcas donde no reside ninguno de los ni\u00f1os que se alojan en un momento determinado en las casas de colonias, y comarcas que no dispo - nen de ninguna casa. La figura siguiente muestra un diagrama ER que satisface los requisitos anterio - res. Los atributos de las entidades no fi guran en el diagrama y se listan aparte.Es posible, ... ... por ejemplo, que una actividad como por ejemplo el esqu\u00ed tenga una calificaci\u00f3n de 10 en la oferta de la casa Gr\u00e9vol, y que la misma actividad tenga una califica-ci\u00f3n de 8 en la casa Ardilla. FUOC 71Z799014MO 20 Introducci\u00f3n al dise\u00f1o de bases de datos Los atributos de las entidades que figuran en el diagrama son los siguientes (las claves primarias est\u00e1n subrayadas): A continuaci\u00f3n comentamos los aspectos m\u00e1s relevantes de este modelo ER: 1)Una de las dificultades que en ocasiones se pres enta durante la modeliza - ci\u00f3n conceptual es decidir si una informaci\u00f3n determinada debe ser una enti - dad o un atributo. En nuestro ejemplo, puede resultar dif\u00edcil decidir si comarca se debe modelizar como una entidad o como un atributo. A primera vista, po dr\u00eda parecer que comarca debe ser un atributo de la entidad casa-colonias para indicar d\u00f3nde est\u00e1 situada una casa de colonias, y tambi\u00e9n un atributo de la entidad ni\u00f1o para indicar la residencia del ni\u00f1o. Sin embargo, esta soluci\u00f3n no ser\u00eda adecuada, porque se quieren tener informaciones adicio - nales asociadas a la comarca: la superfici e y el n\u00famero de habitantes. Es preciso que comarca sea una entidad para poder reflejar estas informaciones adicionales como atributos de la entidad. La entidad comarca tendr\u00e1 que estar, evidenteme nte, interrelaci onada con las entidades ni\u00f1o y casa-colonias . Observad que de este modo, adem\u00e1s, se hace pa - tente que las comarcas de residencia de los ni\u00f1os y las comarcas de situaci\u00f3n de las casas son informaciones de un mismo tipo. 2)Otra decisi\u00f3n que hay que tomar es si el concepto actividad se debe mode - lizar como una entidad o como un atributo. Actividad no tiene informaciones adicionales asociadas; no tiene, por lo tanto, m\u00e1s atributos que los que for - man la clave. Aun as\u00ed, es necesario que actividad sea una entidad para que, me - diante la interrelaci\u00f3n oferta , se pueda indicar que una casa de colonias ofrece actividades. Observad que las actividades ofertadas no se pueden expresar como un atribu - to de casa-colonias , porque una casa puede ofrece r muchas actividades y, en este caso, el atributo no podr\u00eda tomar un valor \u00fanico. 3)Otra elecci\u00f3n dif\u00edcil, que con frecuenci a se presenta al dise\u00f1ar un modelo ER, consiste en modelizar una informaci\u00f3n determinada como una entidad o CASA-COLONIAS nombre-casa , capacidad ACTIVIDAD nombre-actividad NI\u00d1O nombre-comarca , superficie, n\u00famero-habitantes FUOC 71Z799014MO 21 Introducci\u00f3n al dise\u00f1o de bases de datos como una interrelaci\u00f3n. Por ejemplo, podr\u00edamos haber establecido que oferta , en lugar de ser una interrelaci\u00f3n, fues e una entidad; lo habr\u00edamos hecho as\u00ed: La entidad oferta representada en la figura ante rior tiene los atributos que pre - sentamos a continuaci\u00f3n: Esta soluci\u00f3n no acaba de reflejar adecuadamente la realidad. Si analizamos la clave de oferta , podemos ver que se identifica con nombre-casa , que es la clave de la entidad casa-colonias , y con nombre-actividad , que es la clave de la entidad actividad . Esto nos debe hacer sospechar qu e oferta, de hecho, corresponde a una asociaci\u00f3n o interrelaci\u00f3n entre casas y actividades . En consecuencia, re - flejaremos la realidad con m\u00e1s exactitud si modelizamos oferta como una in - terrelaci\u00f3n entre estas entidades. 4)Finalmente, un aspecto que hay que cu idar durante el dise\u00f1o conceptual es el de evitar las redundancias. Por ejemplo, si hubi\u00e9semos interrelacionado comarca con actividad para saber qu\u00e9 actividades se realizan en las casas de cada una de las comarcas, habr\u00edamos tenido informaci\u00f3n redundante. La in - terrelaci\u00f3n oferta junto con la interrelaci\u00f3n situaci\u00f3n ya permiten saber, de for - ma indirecta, qu\u00e9 actividades se hacen en las comarcas. 2.1.5. Interrelaciones n-arias Las interrelaciones n-arias, igual que las binarias, pueden tener diferentes tipos de conectividad. En este subapartado analizaremos pr imero el caso particular de las interrelaciones ternarias y, a co ntinuaci\u00f3n, trataremos las conectivida - des de las interrelaciones n-arias en general. Conectividad de las in terrelaciones ternariasOFERTA nombre-casa, nombre-actividad, nivel Cada una de las tres entidades asociadas con una interrelaci\u00f3n ternaria puede estar conectada con conectivid ad \"uno\" o bien con conectividad \"muchos\". En consecuencia, las inte rrelaciones ternar ias pueden M:M:1, N:1:1 y 1:1:1. Observad que usamos M, N y P para representar \"muchos\", y 1 para representar \"uno\". FUOC 71Z799014MO 22 Introducci\u00f3n al dise\u00f1o de bases de datos Analizaremos c\u00f3mo se decide cu\u00e1l es la conectividad adecuada de una inte - rrelaci\u00f3n ternaria mediante el siguiente ejemplo. Consideremos una interre - laci\u00f3n que denominamos clase y que asocia las entidades asignatura , aula y hora-semanal . Esta interrelaci\u00f3n permite regi strar clases presenciales. Una clase corresponde a una asignatura determinada, se imparte en un aula de - terminada y a una hora de la semana determinada. Por ejemplo, podemos registrar que se hace clase de la asigna tura IBD en el aula D222 el martes a las 9, tal y como se muestra en la figura de la p\u00e1gina siguiente. El atributo duraci\u00f3n nos permite saber cu\u00e1ntas horas dura la clase. Para decidir si el lado de la entidad asignatura se conecta con \"uno\" o con \"mu - chos\" , es necesario preguntarse si, dadas un aula y una hora-semanal , se puede hacer clase de s\u00f3lo una o bien de muchas asignaturas en aquellas aula y hora. La respuesta ser\u00eda que s\u00f3lo se puede ha cer clase de una asignatura en una mis - ma aula y hora. Esto nos indica que asignatura se conecta con \"uno\", tal y como reflejamos en la figura siguiente: Como nos indica este ejemplo, para decidir c\u00f3mo se debe conectar una de las en - tidades, es necesario pregun tarse si, ya fijadas ocurrencias concretas de las otras dos, es posible conectar s\u00f3 lo \"una\" o bien \"muchas\" ocurrencias de la primera entidad. Utilizaremos el mismo procedimiento pa ra determinar c\u00f3mo se conectan las otras dos entidades del ejemplo. Una vez fijadas una asignatura y un aula, es posible que se haga clase de aquella asig natura en aquella au la, en varias horas de la semana; entonces, hora-semana se conecta con \"muc hos\". Finalmente, la FUOC 71Z799014MO 23 Introducci\u00f3n al dise\u00f1o de bases de datos entidad aula se conecta con \"uno\", teniendo en cuenta que, fijadas una asig - natura y una hora de la semana, s\u00f3lo se puede hace r una clase de aquella asig - natura a aquella hora. La conectividad resultante, de este modo, es N:1:1. Caso general: conectividad de las interrelaciones n-arias Lo que hemos explicado sobre la conect ividad para las in terrelaciones terna - rias es f\u00e1cilmente genera lizable a interrelaciones n-arias. Para decidir si una de las entidades se conecta con \"uno\" o con \"muchos\", es necesario preguntarse si, fijadas ocurrencias concretas de las otras n - 1 entidades, es posible conectar s\u00f3lo una o bien much as ocurrencias de la primera entidad: Si la respuesta es que s\u00f3lo una, entonces se conecta con \"uno\". Si la respuesta es que muchas, la entidad se conecta con \"muchos\". 2.1.6. Interrelaciones recursivas Ejemplo de interrelaci\u00f3n recursiva Si, para una entidad persona , queremos tener constancia de qu\u00e9 personas est\u00e1n actualmente casadas entre ellas, ser\u00e1 necesario definir la si guiente interrelaci\u00f3n, que asocia dos veces la en - tidad persona :Una interrelaci\u00f3n n-aria puede tener n + 1 tipos de conectividad, tenien - do en cuenta que cada una de las n entidades puede estar conectada con \"uno\" o con \"muchos\" en la interrelaci\u00f3n*. Una interrelaci\u00f3n recursiva es una interrelaci\u00f3n en la que alguna en - tidad est\u00e1 asociada m\u00e1s de una vez. * Recordad que para las interrelaciones ternarias hay cuatro tipos posibles de conectividad. FUOC 71Z799014MO 24 Introducci\u00f3n al dise\u00f1o de bases de datos Una interrelaci\u00f3n recursiva puede ser tanto binaria como n-aria: 1) Interrelaci\u00f3n re cursiva binaria: interrelaci\u00f3n en la que las ocurrencias asocian dos instancias de la misma entidad*. Las interrelaciones binarias re - cursivas pueden tener cone ctividad 1:1, 1:N o M:N, como todas las binarias. En esta interrelaci\u00f3n tambi\u00e9n es posible expresar la dependencia de existencia igual que en el resto de la s interrelaciones binarias. Ejemplo de interrelaci \u00f3n recursiva binaria La interrelaci\u00f3n boda tiene conectividad 1:1 porque un marido est\u00e1 casado con una sola mu - jer y una mujer est\u00e1 casada con un solo marido. Tambi\u00e9n tiene un c\u00edrculo en los dos lados (seg\u00fan la dependencia de existencia), porque puede haber personas que no est\u00e9n casadas. En una interrelaci\u00f3n recursiva, puede interesar distinguir los diferentes pa - peles que una misma entidad tiene en la interrelaci\u00f3n. Con este objetivo, se puede etiquetar cada l\u00ednea de la interr elaci\u00f3n con un rol. En las interrelacio - nes no recursivas normalmente no se es pecifica el rol; puesto que todas las entidades interrelacionadas son de clases diferentes, sus diferencias de rol se sobreentienden. Roles diferentes Una ocurrencia de la interrelaci\u00f3n boda asocia a dos personas concretas. Para reflejar el papel diferente que tiene cada una de ellas en la interr elaci\u00f3n, una de las personas tendr\u00e1 el rol de marido y la otra tendr\u00e1 el rol de mujer. Algunas interrelaciones recu rsivas no presentan dife renciaci\u00f3n de roles; en - tonces, las l\u00edneas de la in terrelaci\u00f3n no se etiquetan. No-diferencia de roles Consideremos una interrelaci\u00f3n amistad que asocia a personas concretas que son amigas. A diferencia de lo que suce d\u00eda en la interrelaci\u00f3n boda, donde una de las personas es el marido y la otra la mujer, en este caso no hay difere nciaci\u00f3n de roles entre las dos personas interre - lacionadas. A continuaci\u00f3n se mu estra esta interrelaci\u00f3n. Obse rvad que su conectividad es M:N, teniendo en cuenta que una persona pued e tener muchos amigos y, al mismo tiempo, puede haber muchas personas que la consideran amiga.* \u00c9ste es el caso de la interrelaci\u00f3n boda anterior. FUOC 71Z799014MO 25 Introducci\u00f3n al dise\u00f1o de bases de datos 2) Interrelaci\u00f3n recursiva n-aria: interrelaci\u00f3n recursiva en la que las ocu - rrencias asocian m\u00e1s de dos instancias. Ejemplo de interrelaci\u00f3n recursiva ternaria Consideremos una interrelaci\u00f3n que registra todas las bodas que se han producido a lo largo del tiempo entre un conjunto de person as determinado. Esta interrelaci\u00f3n permite tener constancia no s\u00f3lo de las bodas vigentes, sino de todas las bodas realizadas en un cierto periodo de tiempo. Esta interrelaci\u00f3n es recursiva y ternaria. Una oc urrencia de la interrelaci\u00f3n asocia a una per - sona que es el marido, a otra que es la mujer y la fecha de su boda. La conectividad es N:1:1. A los lados del marido y de la mujer les corresponde un 1, po rque un marido o una mujer, en una fecha determinada, se casa con una sola persona. Al lado de la entidad fecha le corres - ponde una N, porque se podr\u00eda dar el caso de que hubiese, en fechas diferentes, m\u00e1s de una boda entre las mismas personas. 2.1.7. Entidades d\u00e9biles Las entidades que hemos considerado hasta ahora tienen un conjunto de atribu - tos que forman su claves primarias y que permiten identificarlas completamente. Estas entidades se denominan, de forma m\u00e1s espec\u00edfica, entidades fuertes . En este subapartado consideraremos otro tipo de entidades que denominaremos en- tidades d\u00e9biles . Una entidad d\u00e9bil se representa con un rect\u00e1ngulo doble, y la interrelaci\u00f3n que ayuda a identificarla se representa con una doble l\u00ednea. Ejemplo de entidad d\u00e9bil Consideremos las entidades edificio y despacho de la figura siguiente. Supongamos que puede haber despachos con el mismo n\u00famero en edific ios diferentes. Entonces, su n\u00famero no iden - tifica completamente un despacho. Para identificar completamente un despacho, es necesa - rio tener en cuenta en qu\u00e9 edificio est\u00e1 situad o. De hecho, podemos identificar un despacho mediante la interrelaci\u00f3n situaci\u00f3n , que lo asocia a un \u00fanico edificio. El nombre del edificio donde est\u00e1 situado junto con el n\u00famero de despacho lo identifican completamente.Una entidad d\u00e9bil es una entidad cuyos atributos no la identifican completamente, sino que s\u00f3lo la id entifican de forma parcial. Esta en - tidad debe participar en una inte rrelaci\u00f3n que ayuda a identificarla. FUOC 71Z799014MO 26 Introducci\u00f3n al dise\u00f1o de bases de datos En el ejemplo anterior, la interrelaci\u00f3n situaci\u00f3n nos ha permitido completar la identificaci\u00f3n de los despachos. Para toda enti dad d\u00e9bil, siempre debe haber una \u00fanica interrelaci\u00f3n que permita comp letar su identificaci\u00f3n. Esta interre - laci\u00f3n debe ser binaria con conectividad 1:N, y la entidad d\u00e9bil debe estar en el lado N. De este modo, una ocurrencia de la entidad d\u00e9bil est\u00e1 asociada con una sola ocurrencia de la entidad del lado 1, y ser\u00e1 posible completar su iden - tificaci\u00f3n de forma \u00fanica. Adem\u00e1s, la entidad del lado 1 debe ser obligatoria en la interrelaci\u00f3n porque, si no fuese as\u00ed, alguna ocurrenc ia de la entidad d\u00e9 - bil podr\u00eda no estar interrelacionada con ninguna de sus ocurrencias y no se po - dr\u00eda identificar completamente. 2.2. Extensiones del modelo ER En este subapartado estudiaremos al gunas construcciones avanzadas que ex - tienden el modelo ER estudiado hasta ahora. 2.2.1. Generalizaci\u00f3n/especializaci\u00f3n En algunos casos, hay ocurrencias de un a entidad que tienen caracter\u00edsticas pro - pias espec\u00edficas que nos interesa modeli zar. Por ejemplo, pu ede ocurrir que se quiera tener constancia de qu\u00e9 coche de la empresa tienen asignado los emplea - dos que son directivos; tambi\u00e9n que, de los empleados t\u00e9cnicos, interese tener una interrelaci\u00f3n con una entidad proyecto que indique en qu\u00e9 proyectos trabajan y se desee registrar su titulaci\u00f3n. Finalm ente, que convenga conocer la antig\u00fcedad de los empleados administrativos. As\u00edm ismo, habr\u00e1 algunas caracter\u00edsticas comu - nes a todos los empleados: todos se iden tifican por un DNI, tienen un nombre, un apellido, una direcci\u00f3n y un n\u00famero de tel\u00e9fono. La generalizaci\u00f3n/especializaci\u00f3n permite reflejar el hecho de que hay una entidad general, que denominamos entidad superclase , que se puede especializar en entidades subclase: FUOC 71Z799014MO 27 Introducci\u00f3n al dise\u00f1o de bases de datos Denotamos la generalizaci\u00f3 n/especializaci\u00f3n con una flecha que parte de las entidades subclase y que se dirige a la entidad superclase. Ejemplo de entidades superclase y subclase En la figura siguiente est\u00e1n re presentadas la entidad superclase , que corresponde al empleado del ejemplo anterior, y las entida des subclase, que corresponden al directivo, al t\u00e9cnico y al administrativo del mismo ejemplo. En la generalizaci\u00f3n/especi alizaci\u00f3n, las caracter\u00edsti cas (atributos o interrela - ciones) de la entidad superclase se prop agan hacia las entidades subclase. Es lo que se denomina herencia de propiedades . En el dise\u00f1o de una generalizaci\u00f3n/especi alizaci\u00f3n, se puede seguir uno de los dos procesos siguientes: 1)Puede ocurrir que el dise\u00f1ador primero identifique la necesidad de la enti - dad superclase y, posterio rmente, reconozca las caracter\u00edsticas espec\u00edficas que hacen necesarias las entidades subclase. En estos casos se dice que ha seguido un proceso de especializaci\u00f3n . 2)La alternativa es que el dise\u00f1ador mode lice en primer lugar las entidades sub - clase y, despu\u00e9s, se d\u00e9 cuenta de sus caracter\u00edsticas comunes e identifique la en - tidad superclase. Entonces se dice que ha seguido un proceso de generalizaci\u00f3n .a)La entidad superclase nos permite modelizar las caracter\u00edsticas co - munes de la entidad vista de una forma gen\u00e9rica. b)Las entidades subclase nos permiten modelizar las caracter\u00edsticas propias de sus especializaciones. Es necesario que se cumpla que toda ocurrencia de una entidad subclase sea tambi\u00e9n una ocurrencia de su entidad superclase. FUOC 71Z799014MO 28 Introducci\u00f3n al dise\u00f1o de bases de datos La generalizaci\u00f3n/especializac i\u00f3n puede ser de dos tipos: a) Disjunta. En este caso no puede suceder que una misma ocurrencia apa - rezca en dos entidades subclase difere ntes. Se denota gr\u00e1ficamente con la etiqueta D. b) Solapada . En este caso no tiene lugar la restricci\u00f3n anterior. Se denota gr\u00e1 - ficamente con la etiqueta S. Adem\u00e1s, una generalizaci\u00f3n/especi alizaci\u00f3n tambi\u00e9n puede ser: 1) Total. En este caso, toda ocurrencia de la entidad superclase debe pertene - cer a alguna de las entidades subclase. Esto se denota con la etiqueta T. 2) Parcial. En este caso no es necesario que se cumpla la condici\u00f3n anterior. Se denota con la etiqueta P. La generalizaci\u00f3n/especializaci\u00f3n de los empleados La generalizaci\u00f3n/especializaci\u00f3n de los empleados es total porque suponemos que todo em - pleado debe ser directivo, t\u00e9cnico o administrativo. Se denota con la etiqueta T. 2.2.2. Entidades asociativas En este subapartado vere mos un mecanismo que nos permite considerar una interrelaci\u00f3n entre entidades como si fuese una entidad. La utilidad de una entidad asociativa co nsiste en que se puede interrelacionar con otras entidades y, de forma indirect a, nos permite tener interrelaciones en las que intervienen interre laciones. Una entidad asociativa se denota recua - drando el rombo de la interre laci\u00f3n de la que proviene. La entidad que resulta de considerar una interrelaci\u00f3n entre entidades como si fuese una entidad es una entidad asociativa , y tendr\u00e1 el mismo nombre que la interrelaci\u00f3n sobre la que se define. Nuestro ejemplo de los empleados... ... corresponde a una generali- zaci\u00f3n/especializaci\u00f3n disjunta porque ning\u00fan empleado puede ser de m\u00e1s de un tipo. Se denota con la etiqueta D. FUOC 71Z799014MO 29 Introducci\u00f3n al dise\u00f1o de bases de datos Ejemplo de entidad asociativa La figura siguiente muestra un ejemplo de entidad asociativa: Recorrido es una interrelaci\u00f3n de conectividad M:N que registra las ciudades por donde han pasado los diferentes viajes organizados por una empresa de reparto de paquetes. Considera - mos recorrido una entidad asociativa con el fin de interrelacionarla con la entidad cliente ; de este modo nos ser\u00e1 posible reflejar por orden de qu\u00e9 clientes se han hecho repartos en una ciudad del recorrido de un viaj e, as\u00ed como el n\u00famero de paqu etes cargados y descargados si - guiendo sus indicaciones. El mecanismo de las entidades asociativa s subsume el de las entidades d\u00e9biles y resulta todav\u00eda m\u00e1s potente. Es deci r, siempre que utilicemos una entidad d\u00e9bil podremos sustituirla por una en tidad asociativa, pero no al rev\u00e9s. Ejemplo de sustituci\u00f3n de una entidad d\u00e9bil por una asociativa A continuaci\u00f3n se muestra la entidad d\u00e9bil despacho , que tiene la interrelaci\u00f3n asignaci\u00f3n con la entidad empleado . Podr\u00edamos modelizar este caso haciendo que despacho fuese una entidad asociativa si consi - deramos una nueva entidad n\u00famero-despacho que contiene simplemente n\u00fameros de despa - chos. Entonces, la entidad asociativa despacho se obtiene de la interrelaci\u00f3n entre edificio y n\u00famero-despacho . FUOC 71Z799014MO 30 Introducci\u00f3n al dise\u00f1o de bases de datos Aunque las entidades d\u00e9biles se puedan sustituir por el mecanismo de las en - tidades asociativas, es adecuado mantener las en el modelo ER porque resultan menos complejas y son suficientes para modelizar muchas de las situaciones que se producen en el mundo real. 2.3. Ejemplo: base de datos del personal de una entidad bancaria En este subapartado veremos un ejemplo de dise\u00f1o conceptual de una base de datos mediante el modelo ER. Se trata de dise\u00f1ar una base de datos para la gesti\u00f3n del personal de una enti - dad bancaria determinada que dispone de muchos empleados y de una amplia red de agencias. La siguiente descripci\u00f3n resume los requisitos de los usuarios de la futura base de datos: a)Los empleados se identifican por un c\u00f3digo de empleado, y tambi\u00e9n desea - mos conocer su DNI, su NSS, su nombre y su apellido. Ser\u00e1 importante regis - trar su ciudad de residencia, considerando que hay ciudades donde no reside ning\u00fan empleado. b)Interesa saber en qu\u00e9 ciudades est\u00e1n ubicadas las diversas agencias de la entidad bancaria. Estas agen cias bancarias se identifi can por la ciudad donde est\u00e1n y por un nombre que permite dist inguir las agencias de una misma ciu - dad. Se quiere tener constancia del n\u00famero de habitantes de las ciudades, as\u00ed como de la direcci\u00f3n y el n\u00famero de te l\u00e9fono de las agencias. Se debe consi - FUOC 71Z799014MO 31 Introducci\u00f3n al dise\u00f1o de bases de datos derar que la base de datos tambi\u00e9n incluye ciudades donde no hay ninguna agencia. c)Un empleado, en un momento determinado, trabaja en una sola agencia, lo cual no impide que pueda ser trasladado a otra o, incluso, que vuelva a tra - bajar en una agencia donde ya hab\u00eda trab ajado anteriormente. Se quiere tener constancia del historia l del paso de los empleados por las agencias. d)Los empleados pueden tener t\u00edtulos acad\u00e9micos (aunque no todos los tie - nen). Se quiere saber qu\u00e9 t\u00ed tulos tienen los empleados. e)Cada empleado tiene una categor\u00eda la boral determinada (auxiliar, oficial de segunda, oficial de primera, etc.). A cada categor\u00eda le corresponde un sueldo base determinado y un prec io por hora extra tambi\u00e9n determinado. Se quiere tener constancia de la categor\u00eda actual de cada empleado, y del sueldo base y el precio de la hora ex tra de cada categor\u00eda. f)Algunos empleados (no todos) est\u00e1n afili ados a alguna cent ral sindical. Se ha llegado al pacto de descontar de la n\u00f3mina mensual la cuota sindical a los afiliados a cada centra l. Esta cuota es \u00fanica para todos los afiliados a una cen - tral determinada. Es nece sario almacenar las afiliacion es a una central de los empleados y las cuotas correspondientes a las diferentes centrales sindicales. g)Hay dos tipos de empleados diferentes: Los que tienen contrato fijo, cu ya antig\u00fcedad queremos conocer. Los que tienen contrato temporal, de lo s cuales nos interesa saber las fechas de inicio y finalizaci\u00f3n de su \u00faltimo contrato. Si un empleado temporal pasa a ser fijo, se le asigna un nuevo c\u00f3digo de emplea - do; consideraremos que un empleado fijo nunca pasa a ser temporal. Todo lo que se ha indicado hasta ahora (traslados, categor\u00edas, afiliaci\u00f3n sindical, etc.) es aplicable tanto a empleados fijos como a temporales. h)Los empleados fijos tienen la posibilid ad de pedir diferentes tipos preesta - blecidos de pr\u00e9stamos (por matrimonio , por adquisici\u00f3n de vivienda, por es - tudios, etc.), que pueden ser concedidos o no. En principio, no hay ninguna limitaci\u00f3n a la hora de pedir varios pr\u00e9s tamos a la vez, siempre que no se pida m\u00e1s de uno del mismo tipo al mismo tiem po. Se quiere regi strar los pr\u00e9stamos pedidos por los empleados, y hacer consta r si han sido concedidos o no. Cada tipo de pr\u00e9stamo tiene establecidas di ferentes condiciones; de estas condicio - nes, en particular, nos interesar\u00e1 saber el tipo de inter\u00e9s y el periodo de vigen - cia del pr\u00e9stamo. FUOC 71Z799014MO 32 Introducci\u00f3n al dise\u00f1o de bases de datos La siguiente figura muestra un diagra ma ER que satisfac e los requisitos an - teriores: Los atributos de las entidades que figuran en el diagrama son los siguientes (las claves primarias se han subrayado): EMPLEADO c\u00f3digo-emplado , dni, nss, nombre, apellido FIJO (entidad subc lase de empleado) c\u00f3digo-empleado , antig\u00fcedad Introducci\u00f3n al dise\u00f1o de bases de datos A continuaci\u00f3n, comentaremos los aspe ctos que pueden resultar m\u00e1s comple - jos de este modelo ER: 1)La entidad agencia se ha considerado una entidad d\u00e9bil porque su atributo nombre-agencia s\u00f3lo permite distinguir las agen cias situadas en una misma ciu - dad, pero para identificar de forma total una agencia, es necesario saber en qu\u00e9 ciudad est\u00e1 situada. De este modo, la interrelaci\u00f3n situaci\u00f3n es la que nos per - mite completar la identi ficaci\u00f3n de la entidad agencia . 2)La interrelaci\u00f3n petici\u00f3n es ternaria y asocia a empleados fijos que hacen pe - ticiones de pr\u00e9stamos, tipos de pr\u00e9sta mos pedidos por los empleados y fechas en las que se hacen estas peticiones. 3)El lado de la entidad fecha se conecta con \"mucho s\" porque un mismo em - pleado puede pedir un mismo tipo de pr\u00e9stamo varias veces en fechas distin - tas. La entidad fijo s e c o n e c t a c o n \" m u c h o s \" p o r q u e u n t i p o d e p r \u00e9 s t a m o determinado puede ser pedido en una misma fecha por va rios empleados. Tambi\u00e9n la entidad tipo-pr\u00e9stamo se conecta con \"muchos\" porque es posible que un empleado en una fecha determinad a pida m\u00e1s de un pr\u00e9stamo de tipo diferente. 4)El atributo concedido/no indica si el pr\u00e9stamo se ha concedido o no. Es un atributo de la interrelaci\u00f3n porque su valor depende al mismo tiempo del em - pleado fijo que hace la petici\u00f3n, del tipo de pr\u00e9stamo pedido y de la fecha de petici\u00f3n. 5)La interrelaci\u00f3n traslado tambi\u00e9n es una interrelaci\u00f3n ternaria que permite re - gistrar el paso de los empleados por las distintas agencias. Un traslado concreto asocia a un empleado, una agencia donde \u00e9l trabajar\u00e1 y una fecha inicial en la que empieza a trabajar en la agencia. El atributo de la interrelaci\u00f3n fecha-fin indica en qu\u00e9 fecha finaliza su asignaci\u00f3n a la agencia ( fecha-fin tendr\u00e1 el valor nulo cuando AGENCIA (entidad d\u00e9bil: nombre-age ncia la identifi ca parcialmente, se identifica con la ci udad de situaci\u00f3n) FUOC 71Z799014MO 34 Introducci\u00f3n al dise\u00f1o de bases de datos un empleado trabaja en una agencia en el momento actual y no se sabe cu\u00e1ndo se le trasladar\u00e1). Observad que fecha-fin debe ser un atributo de la interrelaci\u00f3n. Si se colocase en una de las tres entidades interrelacionadas, no podr\u00eda ser un atribu - to univaluado. Conviene observar que esta interrelaci\u00f3n no registra todas y cada una de las fechas en las que un empleado est\u00e1 asig nado a una agencia, sino s\u00f3lo la fecha inicial y la fecha final de la asignaci\u00f3n . Es muy habitual qu e, para informacio - nes que son ciertas durante todo un periodo de tiempo, se registre en la base de datos \u00fanicamente el inic io y el final del periodo. Notad que la entidad agencia se ha conectad o con \"uno\" en la interrelaci\u00f3n traslado , porque no puede ocurrir que, en una fecha, un empleado determina - do sea trasladado a m\u00e1s de una agencia. 6)Finalmente, comentaremos la generalizaci\u00f3n/especia lizaci\u00f3n de la entidad empleado . Los empleados pueden ser de dos tipos; se quieren registrar propie - dades diferentes para cada uno de lo s tipos y tambi\u00e9n se requieren algunas propiedades comunes a todos los empleados. Por este motivo, es adecuado uti - lizar una generalizaci\u00f3n/especializaci\u00f3n. FUOC 71Z799014MO 35 Introducci\u00f3n al dise\u00f1o de bases de datos 3. Dise\u00f1o l\u00f3gico: la transformaci\u00f3n del modelo ER al modelo relacional En este apartado trataremos el dise\u00f1o l\u00f3gico de una base de datos relacional. Partiremos del resultado de la etapa del dise\u00f1o conceptual expresado median - te el modelo ER y veremos c\u00f3mo se puede transformar en una estructura de datos del modelo relacional. 3.1. Introducci\u00f3n a la tran sformaci\u00f3n de entidades e interrelaciones En el caso de las interrelaciones, es necesario tener en cuenta su grado y su co - nectividad para poder decidir cu\u00e1l es la transformaci\u00f3n adecuada: 1)Las interrelaciones binarias 1:1 y 1:N dan lugar a cl aves for\u00e1neas. 2)Las interrelaciones bina rias M:N y todas las n-arias traducen en nuevas relaciones. En los subapartados siguie ntes explicaremos de form a m\u00e1s concreta las trans - formaciones necesarias para obtener un esquema relacional a partir de un mo - delo ER. M\u00e1s adelante proporcionamos una tabla que resume los aspectos m\u00e1s importantes de cada una de las transformaciones para dar una visi\u00f3n global sobre ello. Finalmente, describimos su aplicaci\u00f3n en un ejemplo. 3.2. Transformaci\u00f3n de entidadesLos elementos b\u00e1sicos del modelo ER son las entidades y las interre - laciones: a)Las entidades, cuando se traducen al modelo relacional, originan re- laciones . b)Las interrelaciones, en cambio, cu ando se transforman, pueden dar lugar a claves for\u00e1neas de alguna relaci\u00f3n ya obtenida o pueden dar lugar a una nueva relaci\u00f3n . Empezaremos el proceso transformando todas las entidades de un mo - delo ER adecuadamente. Cada entidad del modelo ER se transforma en una relaci\u00f3n del modelo relacional. Los atributos de la entidad ser\u00e1n atributos de la relaci\u00f3n y, de forma an\u00e1loga, la clave primaria de la en - tidad ser\u00e1 la clave prim aria de la relaci\u00f3n. Encontrar\u00e9is la tabla de las transformaciones en el subapartado 3.10. de esta unidad; en el subapartado 3.11. veremos el ejemplo de aplicaci\u00f3n. FUOC 71Z799014MO 36 Introducci\u00f3n al dise\u00f1o de bases de datos Ejemplo de transformaci\u00f3n de una entidad Seg\u00fan esto, la entidad de la figura del margen se transforma en la relaci\u00f3n que tenemos a con - tinuaci\u00f3n: Si una entidad interviene en alguna in terrelaci\u00f3n binaria 1:1 o 1:N, puede ser necesario a\u00f1adir nuevos atributos a la relaci\u00f3n obtenida a partir de la entidad. Estos atributos formar\u00e1n claves for\u00e1neas de la relaci\u00f3n. 3.3. Transformaci\u00f3n de interrelaciones binarias Para transformar una interrelaci\u00f3n binari a es necesario tene r en cuenta su co - nectividad, y si las entidades son obligat orias u opcionales en la interrelaci\u00f3n. 3.3.1. Conectividad 1:1 Ejemplo de transformaci\u00f3n de una interrelaci\u00f3n binaria 1:1EMPLEADO( DNI, NSS, nombre, apellido, sueldo) Una vez transformadas todas las entida des en relaciones, es preciso trans - formar todas las interrelaciones en las que intervienen estas entidades. Nuestro punto de partida es que las entidades que intervienen en la in - terrelaci\u00f3n 1:1 ya se han transformado en relaciones con sus correspon - dientes atributos. Entonces s\u00f3lo ser\u00e1 necesario a\u00f1adir a cualquiera de estas dos relaciones una clave for\u00e1nea que refere ncie a la otra relaci\u00f3n. Veremos las transformaciones de las interrelaciones binarias en el siguiente subapartado. FUOC 71Z799014MO 37 Introducci\u00f3n al dise\u00f1o de bases de datos Para la interrelaci\u00f3n de la figura anterior, tenemos dos opciones de transformaci\u00f3n: Primera opci\u00f3n: Segunda opci\u00f3n: Ambas transformaciones nos permiten saber en qu\u00e9 ciudad hay una delegaci\u00f3n, y qu\u00e9 dele - gaci\u00f3n tiene una ciudad. De este modo, reflejan correctamente el significado de la interrela - ci\u00f3n situaci\u00f3n del modelo ER. En la primera transformaci\u00f3n, dado que una dele gaci\u00f3n est\u00e1 situada en una sola ciudad, el atributo nombre-ciudad tiene un \u00fanico valor para cada valor de la clave primaria { nombre-del }. Observad que, si pudiese tener varios valores, la soluci\u00f3n no ser\u00eda correcta seg\u00fan la teor\u00eda re - lacional. En la segunda transformaci\u00f3n, teniendo en cuenta que una ciudad tiene una sola delega - ci\u00f3n, el atributo nombre-del tambi\u00e9n toma un solo valor para cada valor de la clave primaria {nombre-ciudad }. Tambi\u00e9n es necesario tener en cuenta que, en las dos transformaciones , la clave for\u00e1nea que se les a\u00f1ade se convierte en una clave alternat iva de la relaci\u00f3n porque no admite valores repetidos. Por ejemplo, en la segunda trans formaci\u00f3n no puede haber m\u00e1s de una ciudad con la misma delegaci\u00f3n; de este modo, nombre-del debe ser diferente para todas las tuplas de CIUDAD . 3.3.2. Conectividad 1:N Ejemplo de transformaci\u00f3n de 1:NDELEGACI\u00d3N( nombre-del DELEGACI\u00d3N Partimos del hecho de que las entidades que intervienen en la interrela - ci\u00f3n 1:N ya se han trasformado en relaciones con sus correspondientes atributos. En este caso s\u00f3lo es nece sario a\u00f1adir en la relaci\u00f3n correspon - diente a la entidad del lado N, una cl ave for\u00e1nea que referencie la otra re - laci\u00f3n. FUOC 71Z799014MO 38 Introducci\u00f3n al dise\u00f1o de bases de datos La interrelaci\u00f3n de la figura anterior se transforma en: Esta soluci\u00f3n nos permite saber en qu\u00e9 despac ho est\u00e1 asignado cada empleado, y tambi\u00e9n nos permite consultar, para cada despacho, qu \u00e9 empleados hay. Es decir, refleja correctamen - te el significado de la interrelaci\u00f3n asignaci\u00f3n . Teniendo en cuenta que un empleado est\u00e1 asignado a un \u00fanico despacho, el atributo desp tiene un valor \u00fanico para cada valor de la clave primaria { emp}. Si hubi\u00e9semos puesto la clave for\u00e1nea { emp} en la relaci\u00f3n DESPACHO , la soluci\u00f3n habr\u00eda sido incorrecta, porque emp habr\u00eda tomado varios valores, uno para cada uno de los distintos empleados que pue - den estar asignados a un despacho. 3.3.3. Conectividad M:N Ejemplo de transformaci\u00f3n de una interrelaci\u00f3n binaria M:N La interrelaci\u00f3n de la figura anterior se transforma en: Observad que la clave de evaluacion debe constar tanto de la clave de estudiante como de la clave de asignatura para identificar comple tamente la relaci\u00f3n. La soluci\u00f3n que hemos presentado re fleja correctamente la interrelaci\u00f3n evaluaci\u00f3n y su atri - buto nota. Permite saber, para cada estudiante, qu\u00e9 notas obtiene de las varias asignaturas y, para cada asignatura, qu\u00e9 notas tienen los diferentes es tudiantes de aquella asignatura.DESPACHO( desp, ...) EMPLEADO( emp, ..., desp) donde {desp}referencia DESPACHO Una interrelaci\u00f3n M:N se transforma en una relaci\u00f3n. Su clave primaria estar\u00e1 formada por los atributos de la clave primaria de las dos entidades interrelacionadas. Los atributos de la interrelaci\u00f3n ser\u00e1n atributos de la nueva relaci\u00f3n. ESTUDIANTE(est, ...) ASIGNATURA( asig, ...) EVALUACI\u00d3N( est,asig , ESTUDIANTE y {asig} referencia ASIGNATURA FUOC 71Z799014MO 39 Introducci\u00f3n al dise\u00f1o de bases de datos En el caso M:N no podemos utilizar clav es for\u00e1neas para transformar la inte - rrelaci\u00f3n, porque obtendr\u00ed amos atributos que necesitar\u00edan tomar varios valo - res, y esto no se permite en el modelo relacional. 3.3.4. Influencia de la dependencia de existencia en la transformaci\u00f3n de las interrelaciones binarias La dependencia de existencia, o m\u00e1s co ncretamente, el hecho de que alguna de las entidades sea opcional en una interrelaci\u00f3n se debe tener en cuenta al hacer la transformaci\u00f3n de algunas relaciones binarias 1:1 y 1:N. Ejemplo de transformaci\u00f3n de una entidad opcional en la interrelaci\u00f3n En el ejemplo siguiente, la entidad departamento es opcional en direcci\u00f3n y, por lo tanto, pue - de haber empleados que no sean di rectores de ning\u00fan departamento. En principio, hay dos opciones de transformaci\u00f3n: Primera opci\u00f3n: Segunda opci\u00f3n: La segunda transformaci\u00f3n da lugar a una clav e for\u00e1nea que puede tomar valores nulos (por - que puede haber empleados que no son directores de ning\u00fan de partamento). Entonces ser\u00e1 preferible la primera transforma ci\u00f3n, porque no provoca la apar ici\u00f3n de valores nulos en la clave for\u00e1nea y, de este modo, nos ahorra espacio de almacenamiento.Si una de las entidades es opcional en la interrelaci\u00f3n, y la transforma - ci\u00f3n ha consistido en poner una clave for\u00e1nea en la relaci\u00f3n que corres - ponde a la otra entidad, entonces es ta clave for\u00e1nea puede tomar valores nulos. DEPARTAMENTO( dep, ..., emp-dir) donde {emp-dir} referencia EMPLEADO ...) EMPLEADO( emp, ..., dep) donde {dep} DEPARTAMENTO y dep puede tomar valores nulos FUOC 71Z799014MO 40 Introducci\u00f3n al dise\u00f1o de bases de datos En las interrelaciones 1:N, el hecho de que la entidad del lado 1 sea opcional tambi\u00e9n provoca que la clave for\u00e1nea de la transformaci\u00f3n pueda tener valo - res nulos. En este caso, sin embargo, no se pueden evitar estos valores nulos porque hay una \u00fanica transformaci\u00f3n posible. 3.4. Transformaci\u00f3n de interrelaciones ternarias La transformaci\u00f3n de las interrelaciones ternarias pr esenta similitudes impor - tantes con la transformaci\u00f3n de las bina rias M:N. No es posible representar la interrelaci\u00f3n mediante claves for\u00e1neas, sino que es necesario usar una nueva relaci\u00f3n. Para que la nueva relaci\u00f3n re fleje toda la informaci\u00f3n que modeliza la interrelaci\u00f3n, es necesa rio que contenga las claves primarias de las tres en - tidades interrelacionad as y los atributos de la interrelaci\u00f3n. A continuaci\u00f3n analizaremos cu\u00e1l debe ser la clave primaria de la nueva rela - ci\u00f3n seg\u00fan la conectividad. Empezaremos por el caso M:N:P y acabaremos con el caso 1:1:1. 3.4.1. Conectividad M:N:P Ejemplo de transformaci\u00f3n de una interrelaci\u00f3n ternaria M:N:P Analizaremos la transformaci\u00f3n con un ejemplo:As\u00ed pues, la transformaci\u00f3n de una interrelaci\u00f3n ternaria siempre da lu - gar a una nueva relaci\u00f3n, que tendr\u00e1 como atributos las claves primarias de las tres entidades interrelacionadas y todos los atributos que tenga la interrelaci\u00f3n. La clave primaria de la nueva relaci\u00f3n depende de la co - nectividad de la interrelaci\u00f3n. Cuando la conectividad de la interrel aci\u00f3n es M:N:P, la relaci\u00f3n que se ob - tiene de su transformaci\u00f3n tiene como clave primaria todos los atributos que forman las claves primarias de las tres entidades interrelacionadas. FUOC 71Z799014MO 41 Introducci\u00f3n al dise\u00f1o de bases de datos La interrelaci\u00f3n anteri or se transforma en: Para identificar completamente la relaci\u00f3n , la clave debe constar de la clave de estudiante , de la clave de asignatura y de la clave de semestre . Si nos faltase una de las tres, la clave de la relaci\u00f3n podr\u00eda tener valo res repetidos. Consideremos, por ejemplo, que no tuvi\u00e9semos la clave de semestre . Dado que semestre est\u00e1 conectada con \"muchos\" en la interrelaci\u00f3n, puede haber estudiantes que han sido evaluado s de una misma asignatura en m\u00e1s de un semestre. Entonces, para estos casos habr\u00eda valores repetidos en la clave de la relaci\u00f3n EVALUACION-SEMESTRAL . Observad que, del mismo modo que es necesaria la clave de semestre, tambi\u00e9n lo son la de estudiante y la de asignatura . 3.4.2. Conectividad M:N:1 Ejemplo de transformaci\u00f3n de una interrelaci\u00f3n ternaria M:N:1 Lo ilustraremos con un ejemplo: Esta interrelaci\u00f3n refleja los destinos que se dan a los maestros de escuela en los diferentes cursos. El 1 que figura en el lado de escuela significa que un maestro no puede ser destinado a m\u00e1s de una escuela en un mismo curso. El ejemplo de la figura se transforma en:ESTUDIANTE( est, ...) ASIGNATURA( asig, ...) SEMESTRE( sem, ...) asig, sem, nota) donde {est} referencia ESTUDIANTE, {asig} referencia ASIGNATURA y {sem} referencia SEMESTRE Cuando la conectividad de la interrelaci\u00f3n es M:N:1, la relaci\u00f3n que se obtiene de su transformaci\u00f3n tiene como clave primaria todos los atri - butos que forman las claves primaria s de las dos entidades de los lados de la interrelaci\u00f3n et iquetados con M y con N. MAESTRO( y {c\u00f3digo-esc} referencia ESCUELA FUOC 71Z799014MO 42 Introducci\u00f3n al dise\u00f1o de bases de datos No es necesario que la clave incluya c\u00f3digo-esc para identificar completamente la relaci\u00f3n. Si se fijan un maestro y un curso, no puede haber m\u00e1s de una escuela de destino y, por lo tanto, no habr\u00e1 claves repetidas. 3.4.3. Conectividad N:1:1 As\u00ed pues, hay dos posibles claves para la relaci\u00f3n que se obtiene. Son dos claves candidatas entre las cuales el dise\u00f1ador deber\u00e1 escoger la primaria. Ejemplo de transformaci\u00f3n de una interrelaci\u00f3n ternaria N:1:1 Veamos un ejemplo de ello: 1)Una posible transformaci\u00f3n es la siguiente: En este caso, la clave, a pesar de no incluir el atributo asig, identifica completamente la rela - ci\u00f3n porque para una hora-semanal y un aula determinadas hay una \u00fanica asignatura de la que se hace clase a esa hora y en esa aula. 2) La segunda transformaci\u00f3 n posible es esta otra:Cuando la conectividad de la interrelaci\u00f3n es N:1: 1, la relaci\u00f3n que se consigue de su transformaci\u00f3n tiene como clave primaria los atributos que forman la clave primaria de la entidad del lado N y los atributos que forman la clave primaria de cualquiera de las dos entidades que est\u00e1n conectadas con 1. HORA-SEMANAL( y {asig} referencia ASIGNATURA FUOC 71Z799014MO 43 Introducci\u00f3n al dise\u00f1o de bases de datos Ahora la clave incluye el atributo asig y, en cambio, no incluye el atributo c\u00f3digo-aula . La re - laci\u00f3n tambi\u00e9n queda completamente identifica da porque, para una asignatura y hora-sema - nal determinadas, de aq uella asignatura se da clase en una sola aula a aquella hora. 3.4.4. Conectividad 1:1:1 As\u00ed pues, hay tres claves ca ndidatas para la relaci\u00f3n. Ejemplo de transformaci\u00f3n de una interrelaci\u00f3n ternaria 1:1:1 Veamos un ejemplo de ello: Esta interrelaci\u00f3n registra inform aci\u00f3n de defensas de proyectos de fin de carrera. Intervienen en ella el estudiante que presenta el proyecto , el proyecto presentado y el tribunal evaluador. La transformaci\u00f3n del ejemplo anterior se muestra a continuaci\u00f3n: Para la nueva relaci\u00f3n DEFENSA, tene mos las tres posibilidades siguientes: Primera opci\u00f3n: Segunda opci\u00f3n:Cuando la conectividad de la interrela ci\u00f3n es 1:1:1, la relaci\u00f3n que se obtiene de su transformaci\u00f3n tiene como clave primaria los atributos que forman la clave primaria de dos entidades cualesquiera de las tres interrelacionadas. TRIBUNAL( trib, ...) ESTUDIANTE( est, pro, referencia {est} ESTUDIANTE {pro} PROYECTO-FIN-CARRERA DEFENSA( trib, pro , est, fecha-defensa) donde referencia TRIBUNAL, {est} referencia ESTUDIANTE y {pro} referencia PROYECTO-FIN-CARRERA Hemos considerado que, ... ... si dos estudiantes presentan un mismo proyecto de fin de carrera, el tribunal ser\u00e1 necesa-riamente diferente. FUOC 71Z799014MO 44 Introducci\u00f3n al dise\u00f1o de bases de datos Tercera opci\u00f3n: En los tres casos, es posible comprobar que la clave identifica completamente la relaci\u00f3n si se tiene en cuenta la conect ividad de la interrelaci\u00f3n defensa . 3.5. Transformaci\u00f3n de interrelaciones n-arias La transformaci\u00f3n de las interrelaciones n-arias se puede ver como una gene - ralizaci\u00f3n de lo que hemos ex plicado para las ternarias. Podemos distinguir los casos siguientes: a)Si todas las entidades est\u00e1n conectadas con \"muchos\", la clave primaria de la nueva relaci\u00f3n estar\u00e1 formada por todos los atribu tos que forman las claves de las n entidades interrelacionadas. b)Si una o m\u00e1s entidades est\u00e1n conectadas con \"uno\", la clave primaria de la nueva relaci\u00f3n estar\u00e1 fo rmada por las claves de n - 1 de las entidades interre - lacionadas, con la condici\u00f3n de que la entidad, cuya clave no se ha incluido, debe ser una de las que est\u00e1 conectada con \"uno\". 3.6. Transformaci\u00f3n de interrelaciones recursivas Las transformaciones de las interrelacio nes recursivas son similares a las que hemos visto para el rest o de las interrelaciones.DEFENSA( est, pro , trib, fecha-defensa) donde {trib} referencia TRIBUNAL, {est} referencia ESTUDIANTE y {pro} referencia PROYECTO-FIN-CARRERA En todos los casos, la transf ormaci\u00f3n de una interrelaci\u00f3n n-aria consis - tir\u00e1 en la obtenci\u00f3n de una nueva re laci\u00f3n que contiene todos los atribu - tos que forman las claves primarias de las n entidades interrelacionadas y todos los atributos de la interrelaci\u00f3n. De este modo, si una interrelaci\u00f3n re cursiva tiene conectividad 1:1 o 1:N, da lugar a una clave for\u00e1nea, y si tiene conectividad M:N o es n-aria, ori - gina una nueva relaci\u00f3n. FUOC 71Z799014MO 45 Introducci\u00f3n al dise\u00f1o de bases de datos Mostraremos la transformaci\u00f3n de algu nos ejemplos concretos de interrelacio - nes recursivas para ilustrar los de talles de la afirmaci\u00f3n anterior. Ejemplo de transformaci\u00f3n de una interrelaci\u00f3n recursiva binaria 1:1 La interrelaci\u00f3n de la figura anterior es recu rsiva, binaria y tiene conectividad 1:1. Las in - terrelaciones 1:1 originan una clave for\u00e1nea que se pone en la relaci\u00f3n correspondiente a una de las entidades interrelacionadas. En nuestro ejemplo, s\u00f3lo hay una entidad inte - rrelacionada, la entidad persona . Entonces, la clave for\u00e1nea deber\u00e1 estar en la relaci\u00f3n PERSONA . Esta clave for\u00e1nea deber\u00e1 referenciar a la misma relaci\u00f3n para que refleje una interrelaci\u00f3n entre una ocurrencia de persona y otra ocurrencia de persona. As\u00ed, obten - dremos: La clave for\u00e1nea { c\u00f3digo-conyuge } referencia la relaci\u00f3n PERSONA a la que pertenece. Conviene tener en cuenta que, en casos como \u00e9ste, los atributos de la clave for\u00e1nea no pueden tener los mismos nombres que los atri butos de la clave primaria que referencian porque, seg\u00fan la teor\u00eda relacional, una rela ci\u00f3n no puede tener nombres de atributos re - petidos. Ejemplo de transformaci\u00f3n de una interrelaci\u00f3n recursiva M:N Veamos a continuaci\u00f3n un ejemplo en el que interviene una interrelaci\u00f3n recursiva y con conectividad M:N. Las interrelaciones M:N se traducen en nuevas re laciones que tienen como clave primaria las claves de las entida des interrelacionadas. En nuestro ejemplo, la interrelaci\u00f3n vincula oc urrencias de persona con otras ocurrencias de persona . En este caso, la clave primaria de la nuev a relaci\u00f3n estar\u00e1 formada por la clave de la PERSONA ( c\u00f3digo-per , ..., c\u00f3digo-conyuge) donde admite valores nulos FUOC 71Z799014MO 46 Introducci\u00f3n al dise\u00f1o de bases de datos entidad persona dos veces. Convendr\u00e1 dar nombres difere ntes a todos los atributos de la nue - va relaci\u00f3n. De este modo, la traducci\u00f3n del ejemplo anterior ser\u00e1: Ejemplo de transformaci\u00f3n de una interrelaci\u00f3n recursiva n-aria N:1:1 Finalmente, analizaremos un ejemplo en el que la interrelaci\u00f3n recursiva es n-aria: La anterior interrelaci\u00f3n boda es recursiva, ternaria y tiene conectividad N:1:1. Las inte - rrelaciones N:1:1 originan siempre una nueva relaci\u00f3n que contiene, adem\u00e1s de los atri - butos de la interrelaci\u00f3n, todos los atributo s que forman la clave primaria de las tres entidades interrelacionadas. En nuestro ejemplo, la interrelaci\u00f3n asocia ocurrencias de persona con otras ocurrencias de persona y con ocurrencias de fecha . Entonces, la clave de persona tendr\u00e1 que figurar dos veces en la nueva relaci\u00f3n, y la clave de fecha , solo una. La clave primaria de la relaci\u00f3n que se obtien e para interrelaciones N: 1:1 est\u00e1 formada por la clave de la entidad del lado N y por la cl ave de una de las enti dades de los lados 1. En nuestro ejemplo, en los dos lados 1 de la interrelaci\u00f3n tenemos la misma entidad: persona . La clave primaria estar\u00e1 formad a por la clave de la entidad fecha y por la clave de la entidad persona . Seg\u00fan todo esto, la transformaci\u00f3n ser\u00e1 la siguiente: 3.7. Transformaci\u00f3n de {c\u00f3digo-per} referencia PERSONA y {c\u00f3digo-conyuge} referencia PERSONA Las entidades d\u00e9biles se traducen al modelo relacional igual que el resto de entidades, con una peque\u00f1a difere ncia. Estas entidades siempre est\u00e1n en el lado N de una interrelaci\u00f3n 1:N que completa su identificaci\u00f3n. As\u00ed pues, la clave for\u00e1nea originada por esta interrelaci\u00f3n 1:N debe for - mar parte de la clave primaria de la relaci\u00f3n correspondiente a la enti - dad d\u00e9bil. FUOC 71Z799014MO 47 Introducci\u00f3n al dise\u00f1o de bases de datos Ejemplo de transformaci\u00f3n de entidad d\u00e9bil Lo explicaremos con un ejemplo: Este ejemplo se transforma tal y como se muestra a continuaci\u00f3n: Observad que la clave for\u00e1nea { nombre } forma parte tambi\u00e9n de la clave primaria de DESPA - CHO. Si no fuese as\u00ed, y la clave prim aria contuviese s\u00f3lo el atributo n\u00famero , los despachos no quedar\u00edan totalmente identifica dos, teniendo en cuenta que puede haber despachos situados en edificios diferentes que tengan el mismo n\u00famero. 3.8. Transformaci\u00f3n de la ge neralizaci\u00f3n/especializaci\u00f3n Ejemplo de transformaci\u00f3n de la generalizaci\u00f3n/especializaci\u00f3n Veamos un ejemplo (consultad el gr\u00e1fico en la p\u00e1gina siguiente) que contiene una generali - zaci\u00f3n/especializaci\u00f3n y, tambi\u00e9n, una interrel aci\u00f3n M:N en la que interviene una de las en - tidades subclase. Este ejemplo se traduce al mode lo relacional como se indica a continuaci\u00f3n:EDIFICIO( nombre , direcci\u00f3n) DESPACHO( nombre, n\u00famero , superficie) donde {nombre} referencia EDIFICIO Cada una de las entidades superclase y subclase que forman parte de una generalizaci\u00f3n/especializaci\u00f3n se transforma en una relaci\u00f3n: a)La relaci\u00f3n de la entidad superclase tiene como clave primaria la cla - ve de la entidad superclase y co ntiene todos los atributos comunes. b)Las relaciones de las entidades subc lase tienen como clave primaria la clave de la entidad superclase y contienen los atri butos espec\u00edficos de la subclase. EMPLEADO( DNI, nombre, direcci\u00f3n, tel\u00e9fono) DIRECTIVO( DNI, coche) donde {DNI} referencia EMPLEADO FUOC 71Z799014MO 48 Introducci\u00f3n al dise\u00f1o de bases de datos Conviene observar que los atributos co munes se han situado en la relaci\u00f3n EMPLEADO y que los atributos espec\u00edficos se han situado en la relaci\u00f3n de su entidad subclase. De este modo, coche est\u00e1 en DIRECTIVO , t\u00edtulo en T\u00c9CNICO y antig\u00fcedad en ADMINISTRATIVO . Por otro lado, la in terrelaci\u00f3n espec\u00edfica para los empleados t\u00e9cnicos denominada trabaja se transforma en la relaci\u00f3n TRABAJA . Observad que esta relaci \u00f3n tiene una clave for\u00e1nea que referencia s\u00f3lo a los empl eados t\u00e9cnicos, y no a los empl eados directivos o administra - tivos. 3.9. Transformaci\u00f3n de entidades asociativas Ejemplo de transformaci\u00f3n de una entidad asociativa Veamos un ejemplo, que incluye una entidad asociativa interrelacion ada con otra entidad:ADMINISTRATIVO ( DNI, antig\u00fcedad) donde {DNI} referencia EMPLEADO T\u00c9CNICO ( DNI, t\u00edtulo) donde {DNI} referencia EMPLEADO PROYECTO( pro, ...) TRABAJA( DNI, pro , superficie) donde {DNI} referencia T\u00c9CNICO y {pro} referencia PROYECTO Una entidad asociativa tiene su orig en en una interrelaci\u00f3n. En conse - cuencia, sucede que la transformaci\u00f3n de la interrelaci\u00f3n originaria es, al mismo tiempo, la transformaci\u00f3n de la entidad asociativa. FUOC 71Z799014MO 49 Introducci\u00f3n al dise\u00f1o de bases de datos La transformaci\u00f3n del ejemplo anterior ser\u00e1: Tal y como se puede observar, la traducci\u00f3n de la interrelaci\u00f3n recorrido es, al mismo tiempo, la traducci\u00f3n de su entidad asociativa. La relaci\u00f3n REPARTO nos ilustra la transformaci\u00f3n de una interrelaci\u00f3n en la que participa una entidad asociativa. Puesto que se trata de una interrelaci\u00f3n M:N entre recorrido y ciudad , una parte de la clave primaria de REPARTO referencia la clave de RECORRIDO , y el resto, la clave de CIUDAD . 3.10. Resumen de la transformaci\u00f3n del modelo ER al modelo relacional La tabla que mostramos a continuaci\u00f3n re sume los aspectos m\u00e1s b\u00e1sicos de las transformaciones que hemos descrito en las secciones anteriores, con el obje - tivo de presentar una visi\u00f3n r\u00e1pida de los mismos: 3.11. Ejemplo: base de datos del personal de una entidad bancaria En este apartado aplicaremos las transf ormaciones que hemos explicado en el caso pr\u00e1ctico de la base de datos del personal de una entidad bancaria. Antes hemos presentado el dise\u00f1o conceptual de esta base de datos. A continuaci\u00f3n, veremos su transformaci\u00f3n al modelo relacional. Empezaremos por transforma r todas las entidades en relaciones y todas las in - terrelaciones 1:1 y 1:N en claves y {c\u00f3digo-cliente} referencia CLIENTE Elemento del modelo ER Transformaci\u00f3n al modelo relacional Entidad Relaci\u00f3n Interrelaci\u00f3n 1:1 Clave for\u00e1nea Interrelaci\u00f3n 1:1 Clave for\u00e1nea Interrelaci\u00f3n M:N Relaci\u00f3n Interrelaci\u00f3n n-aria Relaci\u00f3n Interrelaci\u00f3n recursivaComo en las interrelaciones no recursivas: Clave for\u00e1nea para binarias 1:1 y 1:N Relaci\u00f3n para binarias M:N y n-arias Entidad d\u00e9bilLa clave for\u00e1nea de la interrelaci\u00f3n identificadora forma parte de la clave primaria Generalizaci\u00f3n/especializaci\u00f3n Relaci\u00f3n para la entidad superclase Relaci\u00f3n para cada una de las entidades subclase Entidad asociativaLa transformaci\u00f3n de la in terrelaci\u00f3n que la origina es a la vez su transformaci\u00f3n Hemos presentado el dise\u00f1o conceptual de la base de datos del personal de la entidad bancaria en el subapartado 2.3 de esta unidad did\u00e1ctica. FUOC 71Z799014MO 50 Introducci\u00f3n al dise\u00f1o de bases de datos Observad que, en la transformaci\u00f3n de la generalizaci\u00f3n/esp ecializaci\u00f3n corres - pondiente a la entidad empleado , hemos situado los atributos comunes a la rela - ci\u00f3n EMPLEADO y los atributos espec\u00edficos se han situado en las relaciones FIJO y TEMPORAL . En la relaci\u00f3n AGENCIA , el atributo nombre-ciudad es una clave for\u00e1nea y al mismo tiempo forma parte de la clave primaria porque agencia es una entidad d\u00e9bil que requiere la interrelaci\u00f3n situacion para ser identificada. Veamos ahora las relaciones que se obtien en a partir de la transformaci\u00f3n de las interrelaciones binarias y n-arias: Para elegir las claves prim arias adecuadas, se ha teni do en cuenta la conectivi - dad de las interrelaciones.EMPLEADO( c\u00f3digo-empleado , {nombre-categ} referencia CATEGOR\u00cdA, {central} referencia CENTRAL-SINDICAL, el atributo central admite valores nulos y {ciudad-res} referencia CIUDAD FIJO( c\u00f3digo-empleado , antig\u00fcedad) donde {c\u00f3digo-empleado EMPLEADO TEMPORAL( c\u00f3digo-empleado nombre-ciudad, } referencia c\u00f3digo-empleado, {fecha} referencia FECHA FUOC 71Z799014MO 51 Introducci\u00f3n al dise\u00f1o de bases de datos Resumen Esta unidad es una introducci\u00f3n a un tema de gran inter\u00e9s: el dise\u00f1o de bases de datos . En primer lugar, hemos exp licado qu\u00e9 se entiende por dise\u00f1ar una base de datos y hemos analizado las etapas en las qu e se puede descomponer el proceso de dise\u00f1o: l a etapa del dise\u00f1o conceptual , l a etapa del dise\u00f1o l\u00f3gico , l a etapa del dise\u00f1o f\u00edsico . En el resto de la unidad hemos tratado el dise\u00f1o conceptual y el dise\u00f1o l\u00f3gico de la base de datos. No hemos estudiado el dise\u00f1o f\u00edsico porque requiere unos conocimientos previos de estructuras de implementaci\u00f3n f\u00edsica que hacen in - adecuado explicarlo en este curso. Para el dise\u00f1o conceptual he mos adoptado el enfoque del modelo ER , un mo - delo de datos muy utilizad o y comprensible. Hemos de scrito las diversas cons - trucciones que proporciona y hemos dado ejemplos de aplicaci\u00f3n a casos pr\u00e1cticos. En lo que respecta al dise\u00f1o l\u00f3gico, lo hemos centrado en el caso de utilizaci\u00f3n de la tecnolog\u00eda relacional . De este modo, hemos ex plicado c\u00f3mo se puede transformar un modelo conceptual expr esado mediante el modelo ER en una estructura de datos del modelo relacional. FUOC 71Z799014MO 53 Introducci\u00f3n al dise\u00f1o de bases de datos Ejercicios de autoevaluaci\u00f3n 1.Haced un dise\u00f1o conceptual de una base de da tos mediante el modelo ER que satisfaga los requisitos que se re sumen a continuaci\u00f3n: a)Un directivo de un club de f\u00fatbol quiere dis poner de una base de datos que le permita con - trolar datos que le interesan sobre competicione s, clubes, jugadores, entrenadores, etc. de \u00e1mbito estatal. b)Los clubes disputan cada tem porada varias competiciones (lig a, copa, etc.) entre s\u00ed. Nues - tro directivo desea informaci\u00f3n hist\u00f3rica de las clasificaciones obtenidas por los clubes en las diferentes competiciones a lo largo de todas la s temporadas. La clasific aci\u00f3n se especificar\u00e1 mediante un n\u00famero de posici\u00f3n: 1 significa campe\u00f3n, 2 significa subcampe\u00f3n, etc. c)Los distintos clubes est\u00e1n agrupados en las fe deraciones regionales correspondientes. Toda federaci\u00f3n tiene como m\u00ednimo un club. Quiere saber el nombre y la fecha de creaci\u00f3n de las federaciones as\u00ed como el nombre y el n\u00famero de socios de los clubes. d)Es muy importante la informaci\u00f3n sobre jugado res y entrenadores. Se identificar\u00e1n por un c\u00f3digo, y quiere saber el nombre, la direcci\u00f3n, el n\u00famero de tel\u00e9fono y la fecha de nacimien - to de todos. Es necesario mencionar que algu nos entrenadores pueden haber sido jugadores en su juventud. De los jugadores, adem\u00e1s, quiere saber el peso, la altura, la especialidad o las especialidades y qu\u00e9 dominio tienen de ellas (g rado de especialidad). Todo jugador debe te - ner como m\u00ednimo una especialidad, pero puede haber especialidades en las que no haya nin - g\u00fan jugador. De los entrenadores le interesa la fecha en que iniciaron su carrera como entrenadores de f\u00fatbol. e)De todas las personas que figura n en la base de datos (jugad ores y entrenadores), quiere co - nocer el historial de contrataciones por parte de los diferentes clubes, incluyendo el importe y la fecha de baja de cada contrataci\u00f3n. En un momento determinado, una persona puede estar contratada por un \u00fanico club, pe ro puede cambiar de club posteriormente e, incluso, puede volver a un club en el que ya hab\u00eda trabajado. f)Tambi\u00e9n quiere registrar las ofertas que las pe rsonas que figuran en la base de datos han recibido de los clubes durante su vida deportiva (y de las que se ha enterado). Considera b\u00e1 - sico tener constancia del importe de las ofertas. Se debe tener en cuenta que, en un momento determinado, una persona puede recibir muchas ofertas, siempre que provengan de clubes distintos. 2.Haced un dise\u00f1o conceptual de una base de da tos mediante el modelo ER que satisfaga los requisitos que se re sumen a continuaci\u00f3n: a)Se quiere dise\u00f1ar una base de datos para faci litar la gesti\u00f3n de una empresa dedicada al transporte internacional de mercanc\u00edas que opera en todo el \u00e1mbito europeo. b)La empresa dispone de varias delegaciones re partidas por toda la geograf\u00eda europea. Las delegaciones se identifican por un nombre, y se quiere registrar tambi\u00e9n su n\u00famero de tel\u00e9 - fono. En una determinada ciudad no hay nunca m\u00e1s de una delegaci\u00f3n. Se desea conocer la ciudad donde est\u00e1 situada cada delegaci\u00f3n. Se debe suponer que no hay ciudades con el nom - bre repetido (por lo menos en el \u00e1mbito de esta base de datos). c)El personal de la empresa se pu ede separar en dos grandes grupos: Administrativos, sobre los cuales interesa saber su nivel de estudios. Conductores, sobre los que interesa saber el a\u00f1o en el que obtuvieron el carnet de conducir y el tipo de ca rnet que tienen. De todo el personal de la empresa, se quiere conocer el c\u00f3digo de empleado (que lo identifica), su nombre, su n\u00famero de tel\u00e9 fono y el a\u00f1o de nacimiento. Todos los empleados est\u00e1n asigna - dos a una delegaci\u00f3n determinada. Se quiere tener constancia hist\u00f3rica de este hecho teniendo en cuenta que pueden ir cambiando de delegaci\u00f3n (incluso pueden volver a una delegaci\u00f3n donde ya hab\u00edan estado anteriormente). d)La actividad de la empresa consiste en efectu ar los viajes pertinentes para transportar las mercanc\u00edas seg\u00fan las peticiones de sus clientes. Todos los clientes se identifican por un c\u00f3di - go de cliente. Se quiere conocer, adem\u00e1s, el nombre y el tel\u00e9fono de contacto de cada uno de ellos. e)La empresa, para llevar a cabo su actividad, dispone de muchos camiones identificados por un c\u00f3digo de cami\u00f3n. Se quiere tener constancia de la matr\u00edcula, la marca y la tara de los camiones. f)Los viajes los organiza siempre una delegaci\u00f3n, y se identifican mediante un c\u00f3digo de via - je, que es interno de cada delegaci\u00f3n (y que se puede repetir en delegaciones diferentes). Para cada uno de los viajes que se han hecho, es necesario saber: Qu\u00e9 cami\u00f3n se ha utilizado (ya que cada viaje se hace con un solo cami\u00f3n). Qu\u00e9 conductor o conductores han ido (considera ndo que en viajes larg os pueden ir varios conductores). Se quiere saber tambi\u00e9n el importe de las dietas pagadas a cada conductor (teniendo en cuenta que las dietas pueden se r diferentes para los diferentes conductores de un mismo viaje). El recorrido del viaje; es decir, la fecha y la hora en que el cami\u00f3n llega a cada una de las ciudades donde deber\u00e1 cargar o descargar. Supondremos que un viaje no pasa nunca dos veces por una misma ciudad. FUOC 71Z799014MO 54 Introducci\u00f3n al dise\u00f1o de bases de datos El n\u00famero de paquetes cargados y de paquet es descargados en cada ciudad, y para cada uno de los clientes. En un mismo viaje se pued en dejar y/o recoger paquetes en diferentes ciudades por encargo de un mi smo cliente. Tambi\u00e9n, en un mismo viaje, se pueden dejar y/o recoger paquetes en una misma ciudad por encargo de diferentes clientes. 3.Haced un dise\u00f1o conceptual de una base de da tos mediante el modelo ER que satisfaga los requisitos que se re sumen a continuaci\u00f3n: a)Es necesario dise\u00f1ar una base de datos para una empresa inmobiliaria con el objetivo de gestionar la informaci\u00f3n relativa a su cartera de pisos en venta. b)Cada uno de los pisos que tienen pendientes de vender tiene asignado un c\u00f3digo de piso que lo identifica. Adem\u00e1s de este c\u00f3digo, se quiere conocer la di recci\u00f3n del piso, la superficie, el n\u00famero de habitaciones y el precio. Tienen estos pisos clasificados por zonas (porque a sus clientes, en ocasiones, s\u00f3lo les interesan los pi sos de una zona determinada) y se quiere saber en qu\u00e9 zona est\u00e1 situado cada piso. Las zonas ti enen un nombre de zona que es diferente para cada una de una misma poblaci\u00f3n, pero que pu eden coincidir en zonas de poblaciones dife - rentes. En ocasiones sucede que en algunas de las zonas no tienen ning\u00fan piso pendiente de vender. c)Se quiere tener el n\u00famero de habitantes de las poblaciones. Se quie re saber qu\u00e9 zonas son lim\u00edtrofes, (porque, en caso de no disponer de pisos en una zona que desea un cliente, se le puedan ofrecer los que tengan en otras zonas lim \u00edtrofes). Es necesario considerar que pueden existir zonas sin ninguna zona lim\u00edtrofe en algunas poblaciones peque\u00f1as que constan de una sola zona. d)Se disponen de diferentes caracter\u00edsticas codificadas de los pisos, como por ejemplo tener ascensor, ser exterior, tener terraza, etc. Cada caracter\u00edstica se identifica mediante un c\u00f3digo y tiene una descripci\u00f3n. Para cada caracter\u00edstica y cada piso se quiere sabe r si el piso satisface la caracter\u00edstica o no. Adem\u00e1s, quieren tener constancia del propietario o los propietarios de cada piso. e)Tambi\u00e9n necesitan disponer de informaci\u00f3n relativa a sus clientes actuales que buscan piso (si dos o m\u00e1s personas busc an piso conjuntamente, s\u00f3lo se guarda informaci\u00f3n de una de ellas como cliente de la empresa). En partic ular, interesa saber las zonas donde busca piso cada cliente (s\u00f3lo en caso de que tenga alguna zona de preferencia). f)A cada uno de estos clientes le asignan un ve ndedor de la empresa para que se ocupe de atenderlo. A veces, estas asignaciones var\u00edan co n el tiempo y se cambia al vendedor asignado a un determinado cliente. Tambi\u00e9n es posible que a un cliente se le vuelva a asignar un ven - dedor que ya hab\u00eda tenido con anterioridad. Se quiere tener constancia de las asignaciones de los clientes actu ales de la empresa. g)Los vendedores, clientes y propietarios se iden tifican por un c\u00f3digo de persona. Se quiere registrar, de todos, su nombre, direcci\u00f3n y n\u00fa mero de tel\u00e9fono. Adem\u00e1s, se quiere disponer del n\u00famero de Seguridad Social y el sueldo de los vendedores, y del NIF de los propietarios. Puede haber personas que sean al mismo tiempo clientes y propietarios, o bien vendedores y propietarios, etc. h)Finalmente, para ayudar a programar y consultar las visitas que los clientes hacen a los pi - sos en venta, se quiere guardar informaci\u00f3n de todas las visitas correspondientes a los clientes y a los pisos actuales de la empres a. De cada visita hay que saber el cliente que la hace, el piso que se va a ver y la hora concreta en que se inicia la visita. Entendemos que la hora de la visita est\u00e1 formada por la fecha, la hora del d\u00eda y el minuto del d\u00eda (por ejemplo, 25-FEB-98, 18:30). Hay que considerar que un mism o cliente puede visitar un mismo piso varias veces para ase - gurarse de si le gusta o no, y tambi\u00e9n que para evitar conflictos no se programan nunca visitas de clientes diferentes a un mismo piso y a la misma hora. 4.Transformad a relacional el dise\u00f1o conceptu al que hab\u00e9is obtenido en el ejercicio 1. 5.Transformad a relacional el dise\u00f1o conceptu al que hab\u00e9is obtenido en el ejercicio 2. 6.Transformad a relacional el dise\u00f1o conceptu al que hab\u00e9is obtenido en el ejercicio 3. FUOC 71Z799014MO 55 Introducci\u00f3n al dise\u00f1o de bases de datos Solucionario Ejercicios de autoevaluaci\u00f3n 1.La siguiente figura muestra un diagrama ER qu e satisface los requisitos que se han descrito: Los atributos de las entidades que figuran en el diagrama son los siguientes (las claves prima - rias se han subrayado): COMPETICI\u00d3N (entidad subclase de persona) c\u00f3digo-persona , peso, altura (entidad subclase fecha-inicio-carrera ESPECIALIDAD nombre-esp FECHA fecha FUOC 71Z799014MO 56 Introducci\u00f3n al dise\u00f1o de bases de datos 2.La siguiente figura muestra un diagrama ER qu e satisface los requisitos que se han descrito: Los atributos de las entidades que figuran en el diagrama son los siguientes (las claves prima - rias se han subrayado): CIUDAD nombre-ciudad DELEGACI\u00d3N nombre-del VIAJE (entidad d\u00e9bil: c\u00f3digo-viaje la identifica parcialmente, se iden - tifica completamente con la delegaci\u00f3n de organizaci\u00f3n). c\u00f3digo-viaje CAMION c\u00f3digo-camion tel\u00e9fono-contacto FUOC 71Z799014MO 57 Introducci\u00f3n al dise\u00f1o de bases de datos 3.La figura que pod\u00e9is ver a continuaci\u00f3n muestra un diagrama ER que satisface los requisitos que se han descrito: Los atributos de las entidades que figuran en el diagrama son los siguientes (las claves prima - rias se han subrayado): POBLACI\u00d3N nombre-pobl , n\u00famero-hab ZONA (entidad d\u00e9bil: nombre-zona la identifica parcialmente, se identifica completamente con la poblaci\u00f3n de localizaci\u00f3n) nombre-zona PISO c\u00f3digo-piso , direcci\u00f3n, c\u00f3digo-persona , (entidad subclase de persona) c\u00f3digo-persona , nss, sueldo CLIENTE (entidad su bclase de persona) c\u00f3digo-persona PROPIETARIO (entidad subclase de persona) c\u00f3digo-persona , nif FECHA fecha HORA (entidad d\u00e9bil: hora-minuto la identifica parcialmente, se identifica completamente co n la fecha de pertenencia) hora-minuto FUOC 71Z799014MO 58 Introducci\u00f3n al dise\u00f1o de bases de datos 4.El resultado de la transformaci\u00f3n a relacional del modelo ER propues to como soluci\u00f3n del ejercicio 1 consta de las siguientes relaciones: 5.El resultado de la transformaci\u00f3n a relacional del modelo ER propues to como soluci\u00f3n del ejercicio 2 consta de las siguientes relaciones:COMPETICI\u00d3N( nombre-comp tel\u00e9fono, fecha-nacimiento) JUGADOR( c\u00f3digo-persona , {c\u00f3digo-persona} referencia PERSONA fecha-inicio-carrera) donde {c\u00f3digo-persona} HABILIDAD( c\u00f3digo-persona, nombre-club, importe-cont, {c\u00f3digo-persona} referencia CLUB OFERTA( c\u00f3digo-persona, fecha, nombre-club , importe-oferta) donde {c\u00f3digo-persona} referencia PERSONA, CLUB nombre-ciudad ) DELEGACI\u00d3N( nombre-del , c\u00f3digo-cami\u00f3n) donde {c\u00f3digo-cami\u00f3n} CAMI\u00d3N( c\u00f3digo-cami\u00f3n , marca, c\u00f3digo-empleado, nombre-ciudad, nombre-del, c\u00f3digo-viaje donde {nombre-ciudad} referencia CLIENTE FUOC 71Z799014MO 59 Introducci\u00f3n al dise\u00f1o de bases de datos 6.El resultado de la transformaci\u00f3n a relacional del modelo ER propues to como soluci\u00f3n del ejercicio 3 consta de las siguientes relaciones: Para la interrelaci\u00f3n visita , hay dos transformaciones posibles: 1) 2) Glosario atributo de una entidad Propiedad que interesa de una entidad. atributo de una interrelaci\u00f3n Propiedad que interesa de una interrelaci\u00f3n. conectividad de una interrelaci\u00f3n Expresi\u00f3n del tipo de correspon dencia entre las ocurrencias de entidades asociadas , nombre-hab) precio, c\u00f3digo-car , direcci\u00f3n, tel\u00e9fono) VENDEDOR( nss, {c\u00f3digo-persona} referencia PERSONA {c\u00f3digo-persona} referencia PERSONA PROPIETARIO( c\u00f3digo-persona , nif) donde {c\u00f3digo-persona} referencia PERSONA FECHA( fecha ) HORA( fecha, hora-minuto ) {fecha} donde {c\u00f3digo-cliente} referencia CLIENTE, VENDEDOR PREFERENCIA( c\u00f3digo-persona, ) donde , satisface/no) referencia ZONA PROPIEDAD( c\u00f3digo-piso, c\u00f3digo-persona ) donde {c\u00f3digo-piso} referencia , c\u00f3digo-persona) hora-minuto} referencia HORA, fecha, , c\u00f3digo-piso) hora-minuto} y {c\u00f3digo-piso} referencia PISO FUOC 71Z799014MO 60 Introducci\u00f3n al dise\u00f1o de bases de datos dise\u00f1o conceptual Etapa del dise\u00f1o de una base de datos que obtiene una estructura de la informaci\u00f3n de la fu - tura BD independiente de la tecnolog\u00eda que se quiere utilizar. dise\u00f1o f\u00edsico Etapa del dise\u00f1o de una base de datos que transf orma la estructura obte nida en la etapa del dise\u00f1o l\u00f3gico con el objetivo de conseguir un a mayor eficiencia y que, adem\u00e1s, la completa con aspectos de implementaci\u00f3n f\u00edsica que depender\u00e1n del SGBD que se debe utilizar. dise\u00f1o l\u00f3gico Etapa del dise\u00f1o de una base de datos que pa rte del resultado del dise\u00f1o conceptual y lo transforma de modo que se adapte al modelo del SGBD con el que se desea implementar la base de datos. entidad Objeto del mundo real que podem os distinguir del resto de los objetos y del cual nos intere - san algunas propiedades. entidad asociativa Entidad resultante de considerar una interrela ci\u00f3n entre entidades como una nueva entidad. entidad d\u00e9bil Entidad cuyos atributos no la identifican completamente, sino que s\u00f3lo la identifican de for - ma parcial. entidad obligatoria en una interrelaci\u00f3n binaria Entidad tal que una ocurrencia de la otra entida d que interviene en la interrelaci\u00f3n s\u00f3lo puede existir si se da como m\u00ednimo una ocurrencia de la entidad obligatoria a la que est\u00e1 asociada. entidad opcional en una interrelaci\u00f3n binaria Entidad tal que una ocurrencia de la otra enti dad que interviene en la interrelaci\u00f3n puede existir aunque no haya ninguna ocurrencia de la entidad opcional a la que est\u00e1 asociada. generalizaci\u00f3n/especializaci\u00f3n Construcci\u00f3n que permite re flejar que existe una entidad general, denominada entidad super - clase, que se puede especializar en entidades su bclase. La entidad superclase nos permite mo - delizar las caracter\u00edsticas comunes de la entidad vista a un nivel gen\u00e9rico, y con las entidades subclase podemos modelizar las caracter\u00eds ticas propias de sus especializaciones. grado de una interrelaci\u00f3n N\u00famero de entidades que asocia la interrelaci\u00f3n. interrelaci\u00f3n Asociaci\u00f3n entre entidades. interrelaci\u00f3n recursiva Interrelaci\u00f3n en la que alguna enti dad est\u00e1 asociada m\u00e1s de una vez. Bibliograf\u00eda Morgan Kaufmann Publishers, Inc.Bases de MySQL Luis Marc Gibert Ginest\u00e0 \u00d3scar P\u00e9rez Mora FUOC 71Z799014MO Bases de datos en MySQL \u00cdndice Introducci\u00f3n .............................................................................................. 5 Objetivos ..................................................................................................... 6 1. Caracter\u00edsticas de MySQL .................................................................. 7 1.1. Prestaciones ...................................................................................... 7 1.2. Limitaciones ..................................................................................... 8 2. Acceso a un servidor MySQL ............................................................. 9 2.1. Conect\u00e1ndose con el servidor .......................................................... 9 2.1.1. Servidores y clientes ............................................................... 9 2.1.2. Conectarse y desconectarse .................................................... 10 2.2. Introducci\u00f3n de sentencias .............................................................. 10 2.2.1. Sentencias ............................................................................... 11 2.2.2. Comandos en m\u00faltiples l\u00edneas ............................................... 11 2.2.3. Cadenas de caracteres ............................................................. 12 2.2.4. Expresiones y variables .......................................................... 13 2.2.5. Expresiones ............................................................................. 14 2.3. Proceso por lotes ............................................................................... 14 2.4. Usar bases de datos ........................................................................... 17 3. Creaci\u00f3n y manipulaci\u00f3n de tablas ................................................ 20 3.1. Crear tablas ....................................................................................... 20 3.2. Tipos de datos ................................................................................... 23 3.2.1. Tipos de datos num\u00e9ricos ...................................................... 23 3.2.2. Cadenas de caracteres ............................................................. 24 3.2.3. Fechas y horas ........................................................................ 25 3.3. Modificar tablas ................................................................................ 25 3.3.1. Agregar y eliminar columnas ................................................. 25 3.3.2. Modificar columnas ............................................................... 26 3.4. Otras opciones .................................................................................. 27 3.4.1. Copiar tablas .......................................................................... 27 3.4.2. Tablas temporales ................................................................... 27 4. Consultas ............................................................................................... 28 4.1. La base de datos demo ...................................................................... 28 4.2. Consultar informaci\u00f3n ..................................................................... 29 4.2.1. Funciones auxiliares ............................................................... 30 4.2.2. La sentencia EXPLAIN ............................................................ 31 4.3. Manipulaci\u00f3n de filas ....................................................................... 33 5. Administraci\u00f3n de MySQL ................................................................ 35 5.1. Instalaci\u00f3n de MySQL ....................................................................... 35 FUOC 71Z799014MO Bases de datos en MySQL 5.2. Usuarios y privilegios ........................................................................ 38 5.2.1. La sentencia GRANT .............................................................. 39 5.2.2. Especificaci\u00f3n de lugares origen de la conexi\u00f3n ................... 40 5.2.3. Especificaci\u00f3n de bases de datos y tablas ............................... 41 5.2.4. Especificaci\u00f3n de columnas ................................................... 42 5.2.5. Tipos de privilegios ................................................................ 42 5.2.6. Opciones de encriptaci\u00f3n ...................................................... 44 5.2.7. Limites uso ........................................................................ 44 5.2.8. privilegios ................................................................ 45 5.2.9. Eliminar usuarios ................................................................... 45 5.2.10. La base de datos de privilegios: mysql ................................. 45 5.3. Copias de seguridad .......................................................................... mysqlhotcopy ........................................................................ 50 5.3.2. mysqldump ............................................................................ 50 5.3.3. Restaurar a partir de respaldos ............................................... 51 5.4. Reparaci\u00f3n de tablas ......................................................................... 52 5.4.1. myisamchk MySQL ........................................... 58 5.6. Replicaci\u00f3n ....................................................................................... 59 5.6.1. Preparaci\u00f3n previa .................................................................. 60 5.6.2. Configuraci\u00f3n del servidor maestro ...................................... 60 5.6.3. Configuraci\u00f3n del servidor esclavo ........................................ 61 5.7. Importaci\u00f3n y exportaci\u00f3n de datos ................................................ 62 5.7.1. mysqlimport ........................................................................... 63 5.7.2. 65 6.2. mysql-query-browser ........................................................................ ...................................................................................................... 70 Bibliograf\u00eda ................................................................................................ 71 FUOC 71Z799014MO 5 Bases de datos en MySQL Introducci\u00f3n MySQL es un sistema gestor de bases de datos (SGBD, DBMS por sus siglas en ingl\u00e9s) muy conocido y ampliamente us ado por su simplicidad y notable ren - dimiento. Aunque carece de algunas ca racter\u00edsticas avanza das disponibles en otros SGBD del mercado, es una opci\u00f3n atractiva tanto para aplicaciones co - merciales, como de entretenimiento pr ecisamente por su facilidad de uso y tiempo reducido de puesta en marcha. Esto y su libre distribuci\u00f3n en Internet bajo licencia GPL le otorgan como be neficios adicionales (no menos impor - tantes) contar con un alto grado de estabilidad y un r\u00e1pido desarrollo. MySQL est\u00e1 disponible para m\u00faltiples plataformas, la seleccionada para los ejemplos de este libro es GNU/Linux. Sin embargo, las diferencias con cual - quier otra plataforma son pr\u00e1cticament e nulas, ya que la herramienta utiliza - da en este caso es el cliente mysql-client, que permite interactuar con un servidor MySQL (local o remoto) en modo texto. De este modo es posible rea - lizar todos los ejercicios sobre un servid or instalado localmente o, a trav\u00e9s de Internet, sobre un servidor remoto. Para la realizaci\u00f3n de todas las actividades, es imprescindible que disponga - mos de los datos de acceso del usuario administrador de la base de datos. Aun - que en algunos de ellos los privilegios necesarios ser\u00e1n menores, para los cap\u00edtulos que tratan la administraci\u00f3n del SGBD ser\u00e1 imprescindible disponer de las credenciales de administrador. Nota Las sentencias o comandos escrit os por el usuario estar\u00e1n en fuente monoespaciada , y las palabras que tienen un significado especial en MySQL estar\u00e1n en negrita . Es importante ha - cer notar que estas \u00faltimas no siempre son pala bras reservadas , sino comandos o sentencias de mysql-client . La versi\u00f3n de MySQL que se ha utilizado durante la redac ci\u00f3n de este material, y en los ejemplos, es la 4.1, la \u00faltima ve rsi\u00f3n estable en ese momento, aunque no habr\u00e1 ning\u00fan problema en ejecutarlos en versiones an teriores, hasta la 3.23.Nota Podremos utilizar la licencia GPL de MySQL siempre que el programa que lo use tambi\u00e9n lo sea, en caso contrario se debe adquirir la \"licencia co-mercial\", entre 250 y 500 \u20ac, en el momento de escribir este material. FUOC 71Z799014MO 6 Bases de datos en MySQL Objetivos Adquirir las habilidades y conocimiento s de MySQL necesarios para utilizar y administrar este SGBD (sistema gestor de bases de datos). FUOC 71Z799014MO 7 Bases de datos en MySQL 1. Caracter\u00edsticas de MySQL En este apartado enumeraremos las pres taciones que caracterizan a este SGBD, as\u00ed como las deficiencias de dise\u00f1o, lim itaciones o partes de l est\u00e1ndar a\u00fan no implementadas. 1.1. Prestaciones MySQL es un SGBD que ha ganado popularidad por una serie de atractivas ca - racter\u00edsticas: Est\u00e1 desarrollado en C/C++. Se distribuyen ejecutables para cerca de diecinueve plataformas diferentes. La API se encuentra disponible en C, C++, Eiffel , Java, Perl, PHP, Python, Ruby y TCL. Est\u00e1 optimizado para equipos de m\u00faltiples procesadores. Es muy destacable su velocidad de respuesta. Se puede utilizar como cliente-serv idor o incrustado en aplicaciones. Cuenta con un rico conj unto de tipos de datos. Soporta m\u00faltiples m\u00e9todos de almacenamiento de las tablas, con prestacio - nes y rendimiento diferentes para po der optimizar el SGBD a cada caso concreto. Su administraci\u00f3n se basa en usuarios y privilegios. Se tiene constancia de casos en lo s que maneja cincuenta millones de re - gistros, sesenta mil tablas y cinco millones de columnas. Sus opciones de conectividad abarcan TCP/IP, sockets UNIX y sockets NT, adem\u00e1s de soportar completamente ODBC. Los mensajes de error pueden estar en espa\u00f1ol y hacer ordenaciones correc - tas con palabras acentuadas o con la letra '\u00f1'. Es altamente confiable en cuan to a estabilidad se refiere. Para todos aquellos que son adeptos a la filosof\u00eda de UNIX y del lenguaje C/C++, el uso de MySQL les ser\u00e1 muy familiar, ya que su dise\u00f1o y sus inter - faces son acordes a esa filosof\u00eda: \"crear herramientas que hagan una sola cosa y que la hagan bien\". MySQL tiene como principal objetivo ser una base de datos fiable y eficiente. Ninguna caracter\u00edstica es implementada en MySQL si antes no se tiene la certeza que funciona r\u00e1 con la mejor velocidad de respuesta y, por supuesto, sin causar problemas de estabilidad. La influencia de C/C++ y UNIX se puede observar de igual manera en su sin - taxis. Por ejemplo, la uti lizaci\u00f3n de expresiones regula res, la diferenciaci\u00f3n de funciones por los par\u00e9ntesis , los valores l\u00f3gicos como 0 y 1, la utilizaci\u00f3n del tabulador para completar sent encias, por mencionar algunos. FUOC 71Z799014MO 8 Bases de datos en MySQL 1.2. Limitaciones Al comprender sus principios de dise\u00f1o, se puede explicar mejor las razones de algunas de sus carencias. Por ejemplo, el soporte de transacciones o la inte - gridad referencial (la gesti\u00f3n de claves for\u00e1neas) en MySQL est\u00e1 condicionado a un esquema de almacenamiento de tabla concreto, de forma que si el usuario no va a usar transacciones, puede usar el esquema de almacenamiento \"tradi - cional\" (MyISAM) y obtendr\u00e1 mayor rend imiento, mientras que si su aplica - ci\u00f3n requiere transacciones, deber\u00e1 us ar el esquema que lo permite (InnoDB), sin ninguna otra restricci\u00f3n o implicaci\u00f3n. Otras limitaciones so n las siguientes: No soporta procedimientos almacenados (se incluir\u00e1n en la pr\u00f3xima versi\u00f3n 5.0). No incluye disparadores (se inclui r\u00e1n en la pr\u00f3xima versi\u00f3n 5.0). No incluye vistas (se incluir\u00e1 n en la pr\u00f3xima versi\u00f3n 5.0). No incluye caracter\u00edsticas de objetos como tipos de datos estructurados de - finidos por el usuario, herencia etc.Nota El esquema de tabla que hay que usar se decide para cada una en el momento de su crea-ci\u00f3n, aunque puede cambiarse posteriormente. Actualmente, MySQL soporta varios esque-mas y permite la incorporaci\u00f3n de esquemas definidos por el usuario. FUOC 71Z799014MO 9 Bases de datos en MySQL 2. Acceso a un servidor MySQL En este apartado veremos las distintas formas de acceso a un servidor MySQL existente que nos proporciona el propio SGBD. El acceso desde lenguajes de programaci\u00f3n o herramientas en modo gr\u00e1fico se tratar\u00e1 en otros apartados. 2.1. Conect\u00e1ndose con el servidor Para conectarse con el servidor deberemos asegurarnos de que \u00e9ste est\u00e1 funcio - nando y de que admite conexiones, sean \u00e9stas locales (el SGBD se est\u00e1 ejecu - tando en la misma m\u00e1quina que in tenta la conexi\u00f3n) o remotas. Adicionalmente, deberemos di sponer de las credenciales necesarias para la co - nexi\u00f3n. Distintos tipos de credenciales nos permitir\u00e1n distintos niveles de acce - so. Para simplificar, supondremos que disponemos de las credenciales (usuario y contrase\u00f1a) del administrador de la base de datos (normalmente, usuario root y su contrase\u00f1a). En el apartado que co ncierne a la administraci\u00f3n de MySQL, se comenta detalladamente los aspectos re lacionados con el sistema de usuarios, contrase\u00f1as y privilegios del SGBD. 2.1.1. Servidores y clientes El servidor MySQL es el servicio mysqld , que puede recibir so licitudes de clien - tes locales o remoto s a trav\u00e9s TCP/IP, sockets o pipes en forma de ficheros loca - les a la m\u00e1quina en que se est\u00e1 ejecutan do. En la distribuci\u00f3n se incluye un cliente llamado mysql-client , al que en adelante no s referiremos simplemente como mysql (as\u00ed es como se llama el programa ejecutable). Si se invoca sin pa - r\u00e1metros, mysql realiza una conexi\u00f3n al servidor local utilizando el nombre del usuario UNIX que lo ha invocado, y supo ne que este usuario no requiere con - trase\u00f1a. La conexi\u00f3n a un servidor remo to y un nombre de usuario espec\u00edficos requiere de al menos dos argumentos: -h para especificar el nombre del servidor. -u para el nombre del usuario. Para que el programa client e pregunte la contrase\u00f1a de conexi\u00f3n al usuario, deberemos proporcionar adicionalmente el par\u00e1metro -p. $ mysql -h servidor.misitio.org -u <usuario> -pNota El servidor MySQL es mysqld . A \u00e9l se pueden conectar m\u00falti-ples clientes. mysql es el cliente en modo texto que proporcio-na el propio SGBD. FUOC 71Z799014MO 10 Bases de datos en MySQL 2.1.2. Conectarse y desconectarse Si se tiene alg\u00fan problema para realizar la conexi\u00f3n, es ne cesario consultar con el administrador del sistema, que nos proporcionar\u00e1 un nombre de usuario, contrase\u00f1a y el nombre del servidor, se g\u00fan sea necesario, y nos informar\u00e1 de las restricciones que tiene nuestra cuenta. La administraci\u00f3n y seguridad de MySQL est\u00e1 dise\u00f1ada sobre un esquema de usuarios y privilegios. Los usuarios debe n ser creados por el administrador con sus respectivos privilegios y restricciones. Es el administrador quien decide si los nombres de los usuarios de MySQL se corresponden o no a los del sistema operativo. Apariencia de mysql al ingresar en el modo interactivo: Con el comando help obtenemos una serie de opciones (veremos las m\u00e1s uti - lizadas). Para salir del cliente podemos escribir ' \\q' o 'quit': Tanto para el comando quit como para el comando help, el punto y coma al final es opcional. 2.2. Introducci\u00f3n de sentencias El cliente de MySQL en modo interact ivo nos permite tanto la introducci\u00f3n de sentencias SQL para trabajar con la base de datos (crear tablas, hacer con - sultas y ver sus resultados, etc.) como la ejecuci\u00f3n de comandos propios del SGBD para obtener informaci\u00f3n sobre las tablas, \u00edndices, etc. o ejecutar opera - ciones de administraci\u00f3n.Nota Los usuarios del sistema opera- tivo y los de MySQL no son los mismos, aunque el administra-dor de MySQL (con fines pr\u00e1c-ticos) pueda utilizar los mismos nombres para las cuentas de los usuarios MySQL. Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 5 to server version: 3.23.49-log Type 'help;' or '\\h' for clear the buffer. mysql> mysql> quit; Sentencias Las sentencias en mysql pue- den abarcar m\u00faltiples l\u00edneas y terminan con punto y coma. FUOC 71Z799014MO 11 Bases de datos en MySQL 2.2.1. Sentencias A continuaci\u00f3n presentamos un a ejecuci\u00f3n de la sentencia select con cuatro columnas de datos: En esta consulta se solicita, a trav\u00e9s de funciones incorporadas en el SGBD, el nom - bre del usuario actual de MySQL, el n\u00famero de conexi\u00f3n al servidor, la versi\u00f3n del servidor y la base de datos en uso. Las funciones se reconocen por los par\u00e9ntesis al final. mysql entrega sus resultados en tablas, en la que el primer rengl\u00f3n son los en - cabezados de las columnas. Es importante no dejar espacio entre el nombre de una funci\u00f3n y los par\u00e9ntesis, de otro modo, mysql marcar\u00e1 un mensaje de error. La \u00faltima l\u00ednea entregada por mysql informa sobre el n\u00famero de filas encon - trado como resultado de la consulta y el tiempo estimado que llev\u00f3 su realiza - ci\u00f3n. Esta medida de tiempo no se debe considerar muy precisa para medir el rendimiento del servidor, se trata simp lemente de un valor aproximado que puede verse alterado po r m\u00faltiples factores. Observamos que la columna con el nombre de la base de datos actual esta va - c\u00eda. Esto es natural, ya que no hemos creado a\u00fan ninguna base de datos ni le hemos indicado al gestor sobre cu\u00e1l queremos trabajar. 2.2.2. Comandos en m\u00faltiples l\u00edneas Los comandos pueden expand irse en varias l\u00edneas por comodidad, sobre todo al escribir largas sentencias SQL. El c liente no enviar\u00e1 la sentencia SQL al ser - vidor hasta encontrar el punto y coma, de este modo, el comando anterior puede escribirse as\u00ed:mysql> select user(), connection_id(), version(), database(); +--------------+-----------------+-------------+------------+ | user() | version() | database() | +--------------+-----------------+-------------+------------+ | yo@localhost | 4 | 3.23.49-log | | +--------------+-----------------+-------------+------------+ 1 row version() | database() | +--------------+-----------------+-------------+------------+ | yo@localhost | 4 | 3.23.49-log | | +--------------+-----------------+-------------+------------+ 1 row in set (0.00 sec) mysql> FUOC 71Z799014MO 12 Bases de datos en MySQL Obs\u00e9rvese el indicador de mysql que se transforma en ->, signo que significa que el comando a\u00fan no es t\u00e1 completo. Tambi\u00e9n pued en escribirse varios co - mandos en una sola l\u00ednea, cada uno de be llevar su respec tivo punto y coma: Se ejecutar\u00e1n en el orden que est\u00e1n escr itos. Los comandos se pueden cancelar con la combinaci\u00f3n \\c, con lo que el cliente nos volver\u00e1 a mostrar el indica - dor para que escribamos de nuevo la sentencia. 2.2.3. Cadenas de caracteres Las cadenas de caracteres pueden delim itarse mediante comillas dobles o sim - ples. Evidentemente, debe n cerrarse con el mismo delimitador con el que se han +-----------------------+ 1 row in set (0.00 sec) +-----------------------+ | user() | +-----------------------+ | yo@localhost | +-----------------------+ 1 row in set (0.01 select now(), -> uso -> ver \\c mysql> Indicadores de mysql Indicador Significado mysql> Espera una nueva sentencia -> La sentencia a\u00fan no se ha terminado con ; \"> Una cadena en comillas do bles no se ha cerrado '> Una cadena en comillas simples no se ha cerrado mysql> select \"Hola mundo\",'Felicidades'; FUOC 71Z799014MO 13 Bases de datos en MySQL y pueden escribirse en diversas l\u00edneas: Al principio, es com\u00fan olvidar el punt o y coma al introducir un comando y, tambi\u00e9n, olvidar cerrar las comillas. Si \u00e9ste es el caso, hay que recordar que mysql no interpreta lo que est\u00e1 entre com illas, de tal modo que para utilizar el comando de cancelaci\u00f3n '\\ c' es preciso antes cerr ar las comillas abiertas: 2.2.4. Expresiones y variables MySQL dispone de variables de sesi\u00f3n, visibles \u00fanicamente durante la co - nexi\u00f3n actual. \u00c9stas pueden almacenar valores de tipos enteros, flotantes o ca - denas, pero no tablas . Se definen como en el siguiente ejemplo: La variable local @x tiene ahora el va lor 1 y puede utilizarse en expresiones: Las variables locales permiten almacenar datos entr e consultas y, en la pr\u00e1cti - ca, es recomendable utiliz arlas exclusivamente con este fin, por ejemplo:mysql> select texto \"> | sin(@x) @x + 10 | @x > 10 | +------+----------+----------+---------+---------+ | 1 | 1.000000 | 0.841471 | 11 | 0 | +------+----------+----------+---------+---------+ 1 row in set (0.01 sec) mysql> | +-------------------+ | 20040124138051 +-------------------+ 1 row in set (0.00 sec) FUOC 71Z799014MO 14 Bases de datos en MySQL 2.2.5. Expresiones Hay que tener cuidado con el uso de la s variables locales por los motivos si - guientes: Se eval\u00faan en el servidor al ser enviadas por el cliente. Se realizan conversiones de tipo impl\u00edcitas. Las variables no requiere n declaraci\u00f3n y, por omis i\u00f3n, contienen el valor NULL que significa \"ausencia de valor\", observad en la siguiente consulta los resultados de utili zar valores nulos: La raz\u00f3n de este comportamiento es que no es posible realizar ninguna opera - ci\u00f3n cuando se desconoce alg\u00fan valor. La entrada de valores NULL siempre significar\u00e1 salida de valores NULL. 2.3. Proceso por lotes MySQL puede procesar por lotes las sentenci as contenidas en un archivo de texto. Cada sentencia deber\u00e1 terminar en ';' igual que si la escribi\u00e9ramos en el cliente. La sintaxis es la siguiente: En este caso, se realizar\u00e1 una conexi\u00f3n con el servidor, nos pedir\u00e1 la contrase\u00f1a del usuario 'juan' y, si \u00e9sta es correcta, ejecutar \u00e1 los comandos incluidos en el archivo demo.sql , uno a uno y por el mismo orden. Imprimir\u00e1 los resultados (o errores) en la salida est\u00e1ndar (o de error) y terminar\u00e1. De este modo evitaremos la molestia de procesarlo s uno por uno de forma ) | @y + 10 | @y < 1 | +------+------------+---------+--------+ | NULL | NULL | NULL | NULL | +------+------------+---------+--------+ 1 row in set (0.00 sec) $ mysql -u juan -h servidor.misitio.org -p < demo.sqlNota El comando do eval\u00faa expre- siones sin mostrar los resulta-dos en pantalla. Se puede evaluar cualquier expresi\u00f3n que admite el comando select . Nota En una expresi\u00f3n donde cual- quiera de sus elementos sea NULL, autom\u00e1ticamente entre-gar\u00e1 como resultado el valor NULL. FUOC 71Z799014MO 15 Bases de datos en MySQL Otra forma de procesar un archivo es mediante el comando source desde el indicador interactivo de MySQL: El archivo demo.sql crea una nueva base de datos. El usuario debe tener permisos para crea r bases de datos si quiere que sea pro - cesado el archivo demo.sql . Si el administrador crea la base de datos por noso - tros, ser\u00e1 necesario editarlo, comentando la l\u00ednea donde se crea la base de datos con el s\u00edmbolo '#' al inicio: Es necesario procesar el contenido del fichero demo.sql tal como los transcribi - mos aqu\u00ed, con el fin de poder realizar los ejemplos del resto del apartado. Si se observa su contenido, posiblemente muchas cosas se expliquen por s\u00ed mismas, de cualquier manera, ser\u00e1n explicadas en este apartado. Tambi\u00e9n pueden eje - cutarse sus \u00f3rdenes en el cliente directamente. mysql> source demo.sql 'proveedor' -- create table proveedores ( empresa varchar(20) not null, pago set('cr\u00e9dito','efectivo'), primary key (empresa) ); -- -- Valores de la tabla 'proveedor' -- insert null, precio float(6,2), foreign key (empresa) references proveedores, foreign key de datos en MySQL Si se desea llevar un registro de todas las operaciones de una sesi\u00f3n, se puede utilizar la expresi\u00f3n siguie nte; de este modo se gu ardar\u00e1n todos los comandos y sus resultados en archivo_registro.txt : Para cancelar la captura, basta con teclear lo siguiente: 2.4. Usar bases de datos La siguiente consulta in forma sobre la base de datos actualmente en uso. El campo esta vac\u00edo porque no estamo s haciendo uso de ninguna base de da - tos. Para ver las bases de datos existentes en el sistema, se debe efectuar la si in set (0.13 sec) mysql> show databases ; +-------------+ | Database | +-------------+ | demo | | mysql | | test | +-------------+ 3 rows in set (0.01 sec) FUOC 71Z799014MO 18 Bases de datos en MySQL MySQL nos muestra el listado de las bases de datos definidas en el servidor. Debe aparecer la base de datos demo que creamos con el archivo demo.sql. Para poder trabajar con ella, tenemos que abrirla: Nota Es posible realizar consultas en una base de datos sin utilizar el comando use, en ese caso, todos los nombres de las tablas deben llevar el nombre de la base de datos a que pertenecen de la forma: demo.productos . Otra posibilidad consiste en proporcionar el nombre de la base de datos al ini - ciar una sesi\u00f3n interactiva con mysql: La consulta de las tablas qu e contiene la base de datos demo se realiza con la sentencia show de la siguiente manera: Asimismo, podemos consul tar las columnas de cada una de las tablas:mysql> use demo ; $ mysql demo -u juan -p mysql> show tables ; +----------------+ | Tables_in_demo | +----------------+ | partes | | proveedores | +----------------+ 2 rows in set (0.00 sec)use El comando use base_de_datos permite abrir una base de datos para su uso. Nota El comando show es \u00fatil para mostrar informaci\u00f3n sobre las bases de datos, tablas, varia-bles y otra informaci\u00f3n sobre el SGBD. Podemos utilizar help show en el int\u00e9rprete de comandos para obtener todas las variantes de esta sentencia. mysql> describe productos; +---------------+----------------------+------+------+----------+------------------+ | Field | Type | Null | Key | Default | Extra | +---------------+----------------------+------+------+----------+------------------+ | parte | varchar(20) | YES | | NULL | | | tipo | varchar(20) | YES | | NULL | | | especificicaci\u00f3n | varchar(20) | YES | | NULL | | | Field | float(6,2) | YES | | NULL | | | Field | int(3) unsigned zerofill | YES | PRI | NULL | auto_increment | +---------------+----------------------+------+------+----------+------------------+ 5 rows in set (0.00 sec) FUOC 71Z799014MO 19 Bases de datos en MySQL Para crear una nueva base de datos usaremos la sentencia create database : Para eliminar una base de da tos, usaremos la sentencia drop database : MySQL es sensible al uso de may\u00fasculas y min\u00fasculas, tanto en la definici\u00f3n de bases de datos, como de tablas o columnas. Bases de datos en MySQL 3. Creaci\u00f3n y manipulaci\u00f3n de tablas 3.1. Crear tablas Una vez realizada la conexi\u00f3n con el servidor MySQL y despu\u00e9s de abrir una base de datos, podemos crear tablas en ella de la siguiente manera: En este caso, la sentencia create table construye una nueva tabla en la base de datos en uso. La tabla contiene tres columnas, nombre , direcci\u00f3n y tel\u00e9fono , todas de tipo car\u00e1cter y de longitudes 30, 40 y 15 respectiva mente. Si se inten - ta guardar en ellas valores que sobrepas en esos l\u00edmites, ser\u00e1n truncados para poderlos almacenar. Por ese motivo, es importante reservar espacio suficiente para cada columna. Si se prev\u00e9 que mu chos registros ocupar\u00e1n s\u00f3lo una frac - ci\u00f3n del espacio reservado, se puede utilizar el tipo varchar , similar a char , con la diferencia de que el valor ocupar \u00e1 un espacio menor al especificado si la cadena es m\u00e1s corta que el m\u00e1ximo indicado, ahorrando as\u00ed espacio de al - macenamiento. Los nombres de las columnas admiten caracteres acentuados. Las tablas pueden eliminarse con drop table : Alternativamente, se puede ut ilizar la drop table personas; if exists personas; FUOC 71Z799014MO 21 Bases de datos en MySQL Atributos de columna Ve\u00e1moslo con un ejemplo: En este caso la tabla contiene cuatro columnas, de las cuales nombre y edo_civil permiten valores nulos, en edo_civil est\u00e1 impl\u00edcito al no de clarar lo contrario. La columna num_registro no acepta valores nulos po rque est\u00e1 definida como clave primaria. Aunque la creaci\u00f3n de una clave primar ia puede declararse como atributo de columna, es conveniente de finirla como restricci\u00f3n de tabla, como se ver\u00e1 en - seguida. Tambi\u00e9n es posible indicar restricciones sobre la tabla y no sobre columnas es - pecificas:Atributo Significado nullSe permiten valores nulos, atributo por omisi\u00f3n si no se especifica lo contrario. not null No se permiten valores nulos. default valor Valor por omisi\u00f3n que se asigna a la columna. auto_incrementEl valor se asigna autom\u00e1ticament e incrementando en uno el m\u00e1ximo valor registrado hasta ahora. Se aplica s\u00f3lo a las columnas marcadas como clave primaria. primary keySe\u00f1ala al campo como clave primaria, impl\u00edcitamente tambi\u00e9n lo declara como not null . mysql> create null , Query OK, 0 rows affected (0.01 sec)Nota La definici\u00f3n de columnas tie- ne el siguiente formato: nombre_columna tipo atributos. FUOC 71Z799014MO 22 Bases de datos en MySQL Restricciones de tabla Se definen tres restricciones sobre la tabla despu\u00e9s de la definici\u00f3n de cuatro columnas: La primera restricci\u00f3n se refiere a la clave primaria, compuesta por las co - lumnas nombre y nacimiento : no puede haber dos personas que se llamen igual y que hayan nacido en la mism a fecha. La clave primaria permite identificar de manera un\u00edvoca cada registro de la tabla. La segunda restricci\u00f3n define que la pa reja de una persona debe ser \u00fanica: dos personas no pueden tener la misma pareja. Todo intent o de insertar un nuevo registro donde el nombre de la p a r e j a y a e x i s t a , ser\u00e1 rechazado. Cuando se restringe una columna con unique , los valores null reciben un trato especial, pues se perm iten m\u00faltiples valores nulos . La tercera restricci\u00f3n afecta a la columna proveedor , s\u00f3lo puede tomar valo - res que existan en la clav e primaria de la tabla proveedores . Las restricciones de tabla pueden defini rse con un identifica dor \u00fatil para hacer referencias posteriore s a la restricci\u00f3n: key / index La definici\u00f3n de \u00edndices puede hacerse tambi\u00e9n en el momento de creaci\u00f3n de la tabla, me - diante la palabra clave key (o index), a la qu e deberemos proporcionar el nombre que vamos a asignar a esta clave y las columnas que la forman, entre par\u00e9ntesis. Existen modificadores opcionales sobre el \u00edndice que nos permiten especificar si se trata de un \u00edndice \u00fanico o m\u00fal - tiple (seg\u00fan puedan existir o no varios valores iguales del \u00edndice en la tabla). En versiones recientes de MySQL existen otros tipos de \u00edndices (espaciales, de texto comple - to, etc.) para tipos de datos concretos y que ofrecen prestaciones adicionales.Restricci\u00f3n Significado primary keyDefine la o las columnas que servir\u00e1n como clave primaria. Las columnas que forman parte de la clave primaria deben de ser not null . uniqueDefine las columnas en las que no pueden duplicarse valores. Ser\u00e1n las claves candidatas del modelo relacional. foreign key (columna ) references tabla (columna2 ) Define que los valores de columna se permitir\u00e1n s\u00f3lo si existen en tabla(columna2). Es decir, columna hace referencia a los registros de tabla , esto asegura que no se realicen referencias a registros que no existen. mysql> create table personas ( -> nombre null , Las restricciones de tabla foreign key no tienen efecto alguno en MySQL 4.0 y ante-riores, ya que esta caracter\u00edsti-ca no est\u00e1 implementada. Se admite en la sintaxis por com-patibilidad, ya que ser\u00e1 imple-mentada en una versi\u00f3n posterior. En la versi\u00f3n 4.1, est\u00e1 soportada si se utiliza el tipo de tabla InnoDB. FUOC 71Z799014MO 23 Bases de datos en MySQL 3.2. Tipos de datos MySQL cuenta con un rico conjunto de tipos de datos para las columnas, que es necesario conocer para elegir mejor c\u00f3mo definir las tablas. Los tipos de da - tos se pueden clasificar en tres grupos: N u m \u00e9 r i c o s . Cadenas de caracteres Fechas y horas El valor null es un caso especial de dato, ya que al significar ausencia de valor se aplica a todos los tipos de columna. Los siguientes s\u00edmbolos se utilizan en la definici\u00f3n y descripci\u00f3n de los tipos de datos en MySQL: M - El ancho de la columna en n\u00famero de caracteres. D - N\u00famero de decimales que hay que mostrar. L - Longitud o tama\u00f1o real de una cadena. [ ] - Lo que se escriba entre ellos es opcional. 3.2.1. Tipos de datos num\u00e9ricos Los tipos de datos num\u00e9ricos comprenden dos categor\u00edas, los enteros y los n\u00fa - meros con punto flotante. N\u00fameros enteros La principal diferencia entre cada uno de los tipos de enteros es su tama\u00f1o, que va desde 1 byte de almacenamiento hasta los 8 bytes. Las columnas de tipo en - tero pueden recibir dos atributos adicionales, que deben especificarse inmedia - tamente despu\u00e9s del nombre del tipo: unsigned. Indica que el entero no podr\u00e1 almacenar valores negativos. Es responsabilidad del usuario verificar, en este caso, que los resultados de las restas no sean negativos, porque MySQL los convierte en positivos. zerofill. Indica que la columna, al ser mo strada, rellenar\u00e1 con ceros a la iz - quierda los espacios vac\u00ed os. Esto de acuerdo al valor especificado por M en la declaraci\u00f3n del tipo. Un a columna con el atributo zerofill es al mismo tiempo unsigned aunque no se especifique. Ejemplo El comando anterior crea una tabla con dos columnas. Ambas ocupar\u00e1n un espacio de 4 bytes, pero al mostrarse, la columna x ocupar\u00e1 un espacio de 4 d\u00edgitos y la columna y, de 5.create table n\u00fameros ( x unsigned ); FUOC 71Z799014MO 24 Bases de datos en MySQL Tanto zerofill como unsigned deben escribirse siempre antes que cualquier otro atributo de columna. Tipos enteros N\u00fameros con punto flotante MySQL cuenta con los tipos float y double , de 4 y 8 bytes de almacenamiento. Adem\u00e1s incluye el tipo decimal, que se almacena como una cadena de carac - teres y no en formato binario. N\u00fameros de punto flotante 3.2.2. Cadenas de caracteres Cadenas de caracteres Si observamos la tabla, vemos que el \u00fan ico tipo de dato que siempre utiliza el tama\u00f1o especificado por M es el tipo char . Por este motivo, se ofrece el tipo varchar que ocupa s\u00f3lo el espacio requer ido por el valor de la columna. EjemploTipo Espacio de almacenamiento Significado tinyint [(M)] 1 byte Entero muy peque\u00f1o smallint [(M)] 2 bytes Entero peque\u00f1o mediumint [(M)] 3 bytes Entero mediano int[(M)] 4 bytes Entero bigint [(M)] 8 bytes Entero grande TipoEspacio de almacenamientoSignificado float 4 bytes Simple precisi\u00f3n double 8 bytes Doble precisi\u00f3n decimal M + 2 bytesCadena de caracteres representando un n\u00famero flotante Tipo EquivalenteTama\u00f1o m\u00e1ximoEspacio de almacenamiento char[(M)] M bytes M bytes varchar M bytes L+1 bytes tinytext tinyblob 281 ) 64 valores 1 a 8 persona( comentario char(250), recado varchar(250) ); FUOC 71Z799014MO 25 Bases de datos en MySQL La columna comentario ocupar\u00e1 250 bytes de espacio de almacenamiento, sin importar el va - lor almacenado. Por el contrario, la columna recado ocupar\u00e1 s\u00f3lo el espacio necesario seg\u00fan el valor asignado; por ejemplo, la cadena \" Instalar MySQL \" tiene 14 bytes de longitud, y el campo recado ocupar\u00eda 15 bytes para almacenarla. Los tipos text y blob son equivalentes , pero text respeta las may\u00fasculas, mi - n\u00fasculas y caracteres acentuados en la ordenaci\u00f3n. Ejemplo del uso de los tipos enumerados o enum La columna edo_civil de la tabla en la sentencia anteri or, solo podr\u00e1 almacenar los valores 'soltero ', 'casado ', 'viudo ', 'divorciado ', que son especificados por el tipo enum . La columna ocupar\u00e1 el espacio de un byte, ya que los valores enum son repres entados internamente por n\u00fameros. 3.2.3. Fechas y horas Fechas y horas 3.3. Modificar tablas 3.3.1. Agregar y eliminar columnas Alterar la estructura de una tabla es un a tarea m\u00e1s frecuente de lo que uno pue - de imaginar en un pr incipio. La sentencia alter table permite una amplia gama de formas de modifi car una tabla. La siguient e sentencia nos recuerda un poco a la estructura de la sentencia create table , en donde modificamos la tabla personal creada en la secci\u00f3n anterior. create table persona( edo_civil enum('soltero','casado','viudo','divorciado') ); TipoEspacio de almacenamientoRango '9999-12-31' time bytes a char (20) not null -> );Nota Siempre es posible consultar la estructura de una tabla con el comando describe tabla . FUOC 71Z799014MO 26 Bases de datos en MySQL Despu\u00e9s de ejecutar la sentencia anteri or, aparecen dos nuevas columnas en la tabla. Si queremos agregar una sola columna, podemos us ar la sintaxis si - guiente: Este formato de alter table permite, adem\u00e1s, insert ar las columnas antes (before ) o despu\u00e9s ( after ) de una columna en cuesti\u00f3n. Las columnas no deseadas pued en eliminarse con la opci\u00f3n drop . 3.3.2. Modificar columnas La modificaci\u00f3n de una columna con la opci\u00f3n modify es parecida a volver a definirla. Despu\u00e9s de la sentencia anterior, los atributos y tipo de la columna han cam - biado por los especificados. Lo que no se puede cambiar con esta sintaxis es el nombre de la columna. Para el lo, se debe utilizar la opci\u00f3n change: La columna que se llamaba nom cambia a nombre . Con el mismo comando alter table podemos incluso realizar la ordenaci\u00f3n f\u00ed - sica de una tabla bajo una columna espec\u00edfica: mysql> alter table personal add capital int not null after nom; mysql> alter nom nombre char(20); mysql> alter table order sec) Records: 0 Duplicates: 0 Warnings: 0Nota En general, una tabla no puede durar mucho tiempo con un order respecto a una colum- na, ya que las inserciones no se realizar\u00e1n respetando el orden establecido. Solamente en ta-blas que no van a ser actualiza-das es \u00fatil aplicar este comando. FUOC 71Z799014MO 27 Bases de datos en MySQL Finalmente, podemos cambia r de nombre la tabla: 3.4. Otras opciones 3.4.1. Copiar tablas Aunque no existe un coma ndo expl\u00edcito para copiar tablas de una base de da - tos a otra, es posibl e utilizar el comando rename table para este prop\u00f3sito; basta con especificar la base de datos a la que pertenece una tabla: Tambi\u00e9n es posible crear una tabla nueva con el contenido de otra ya existente (copiando los datos): La siguiente sentencia es equivalente, pero no copia los datos de la tabla origen: 3.4.2. Tablas temporales MySQL permite la creaci\u00f3n de tablas temp orales, visibles exclusivamente en la se - si\u00f3n abierta, y guardar datos entre consul tas. La creaci\u00f3n de una tabla temporal s\u00f3lo requiere la utiliz aci\u00f3n de la palabra temporary en cualquier formato del co - mando create table . La utilidad de las tablas temp orales se limita a consultas com - plejas que deben generar resultados in termedios que debemos consultar (hacer 'join' con ellas) varias veces o en consultas separadas. Internamente, MySQL ge - nera tambi\u00e9n tablas temporales para resolver determinadas consultas:mysql> alter nuevo_nombre es una forma alternativa de cambiar el nombre a una tabla. FUOC 71Z799014MO 28 Bases de datos en MySQL 4. Consultas Como ya hemos explicado, las consultas sobre la base de datos se ejecutan me - diante sentencias SELECT introducidas en el propio progra ma cliente y los re - sultados se presentan en forma de tabla. 4.1. La base de datos demo En esta secci\u00f3n utilizarem os la base de datos demo que hemos creado con el comando source demo.sql . As\u00ed que, antes de estudiar las consultas en MySQL, revisaremos brevemente la estructura de esta base de datos, que consta de las siguientes tablas: Las cuatro tablas representan, de manera ficticia , la base de datos de un distribuidor de equi - pos de procesamiento. Est\u00e1n dise\u00f1adas para serv ir de ejemplo a los casos presentados en este cap\u00edtulo, por lo que no necesariamente ser\u00e1n \u00fatiles en la vida real. En nuestro ejemplo imaginario repr esentamos la siguiente situaci\u00f3n. Nuestro vendedor tiene una relaci\u00f3n de proveedores que venden sus produc - tos a cr\u00e9dito, en efectivo o ambos. Las compras a cr\u00e9dito pagan intereses, pero son \u00fatiles porque no siempre es posible pagar en efectivo. Se utiliza una columna de tipo conjunto para pago, que puede tomar los valores ' cr\u00e9dito ', 'efectivo ' o ambos: Los productos que se distribuyen son partes de equipo de c\u00f3mputo. Para la mayor\u00eda de los productos en el mercado, los fabricantes sugieren un precio de venta al p\u00fablico que, aunque no es obligatorio, los consumidores no est\u00e1n dis - puestos a pagar m\u00e1s. Las claves de los productos son asignadas para control mysql> show tables ; +----------------+ | Tables_in_demo | +----------------+ | ganancia | | precios | | productos | | proveedores | +----------------+ create table proveedores ( empresa set('cr\u00e9dito','efectivo'), primary key (empresa) );Pode\u00eds ver la creaci\u00f3n de la base de datos demo en el apartado \"Proceso por lotes\" de esta misma unidad did\u00e1ctica. FUOC 71Z799014MO 29 Bases de datos en MySQL interno con un n\u00famero consecutivo. Con estas especificaciones, la tabla pro- ductos se define de la manera siguiente: La empresa define una pol\u00edtica para las ganancias m\u00edni mas que se deben obtener en ventas: el 5% al por mayor y el 12% al por menor. Estos valores se almacenan en la tabla ganancias , donde se decidi\u00f3 incluir una columna de nombre factor , con el n\u00famero por el que se multiplica el precio de compra para obtener el precio de venta. Los tipos de venta ' Por mayor ' y 'Por menor ' se definen con un tipo de datos enum : La lista de precios se define a partir de la empresa proveedor y el producto, asign\u00e1ndole un precio. Por ese motivo, las columnas empresa y clave se de - finen como foreign key . 4.2. Consultar informaci\u00f3n MySQL ofrece un conjunto muy amplio de funciones auxiliares (tanto est\u00e1nda - res como propias) que nos pueden ayudar mucho en determinados momentos, dejando parte del trabajo de manipular los resultados al propio gestor. Debido al r\u00e1pido ritmo en el desarrollo de este SGBD, es muy conveniente consultar siempre la documentaci\u00f3n de nuestra versi\u00f3n para conocer sus posibilidades concretas. create table productos ( not foreign key (clave) references productos ); FUOC 71Z799014MO 30 Bases de datos en MySQL En el m\u00f3dulo 3 de este curso ya estudiam os en detalle el Lenguaje SQL, por lo que no vamos a extendernos aqu\u00ed en su uso y posibilidades . \u00danicamente mos - traremos los aspectos dest acables, facilidades o limit aciones que ofrece MySQL respecto a \u00e9l. 4.2.1. Funciones auxiliares Las funciones auxiliares que podemos utiliz ar en nuestras consultas (tanto en la proyecci\u00f3n de las columnas como en condiciones en su selecci\u00f3n) se pue - den clasificar seg\u00fan el tipo de datos con el que trabajan. Ejemplo Algunos ejemplos de la s funciones m\u00e1s usadas: Operadores l\u00f3gicos Comparaci\u00f3n. Aparte de los est\u00e1ndares =, !=, <, >, IS NULL, IS NOT NULL, BETWEN, IN, destacan COALESCE, INTE RVAL, LEAST, GREATEST para tra - bajar con listas de valores. Control del flujo de ejecuci\u00f3n CASE .. WHEN .. THEN .. ELSE .. END: Similar a la estr uctura que mediante cualquier | producto | precio sugerido | precio_con_envio | +--------------------+-----------------+------------------+ | Procesador 2 GHz | NULL | NULL | | Procesador 2.4 GHz | 35.00 | 45.00 | | Procesador 1.7 GHz | 205.00 | 215.00 | | Procesador 3 GHz | 560.00 | 570.00 | | RAM 128MB | 10.00 | 20.00 | | RAM 256MB | 35.00 | 45.00 | | Disco Duro 80 GB | 60.00 | 70.00 | | Disco Duro 120 GB | 78.00 | 88.00 | | Disco Duro 200 GB | 110.00 | 120.00 | | Disco Duro 40 GB | NULL | NULL | | Monitor 1024x876 | 80.00 | 90.00 | | Monitor 1024x876 | | 12 THEN ELSE 'false' END | +--------------------------------------------+ | true | +--------------------------------------------+ 1 row in set (0.00 sec) FUOC 71Z799014MO 31 Bases de datos en MySQL I F ( e x p r 1 ,expr2 ,expr3): T\u00edpica estructura condic ional, si la expr1 es cierta, devuelve la expr2, en ca so contrario, la expr3: Funciones para trabajar con cadenas de caracteres (s\u00f3lo algunos ejemplos) CONCAT, INSTR (encontrar en una cadena), SUBSTRING, LCASE/RCASE, LENGTH, REPLACE, TRIM, entre otras, son funciones similares a las que podemos encontrar en leng uajes de programaci\u00f3n para manipular cadenas de caracteres. QUOTE: delimita una cadena de texto correctamente para evitar proble - mas al usarla en sentencias SQL. La cadena resultante estar\u00e1 delimitada por comillas simples. Las comillas, el va lor ASCII NUL y otros potencialmente conflictivos ser\u00e1n devueltos pr ecedidos del car\u00e1cter '\\'. ENCODE/DECODE, CRYPT, COMPRESS /UNCOMPRESS, MD5, etc. son funciones que nos pueden ayudar mucho en el almacenamiento de datos sensibles como co ntrase\u00f1as, etc. Funciones num\u00e9ricas Los operadores aritm\u00e9ticos cl\u00e1sicos para realizar todo tipo de operaciones, suma, resta, divisi\u00f3n, producto, divisi\u00f3n entera, etc. Funciones matem\u00e1ticas de todo tipo, trigonom\u00e9tricas, logar\u00edtmicas, etc. Funciones para trabajar con fechas y horas Obtenci\u00f3n de fechas en cualquie r formato: DATE_FORMAT, DATE, NOW, CURRDATE, etc. Manipulaci\u00f3n y con fechas : ADDDATE, ADDTIME, CONVERT_TZ, DATE_DIFF, etc. 4.2.2. La sentencia EXPLAIN MySQL nos ofrece tambi\u00e9n facilidades a la hora de evaluar la s sentencias SQL, gracias a la sentencia EXPLAIN.mysql> SELECT IF(STRCMP('test','test1'),'no','yes'); +---------------------------------------+ | IF(STRCMP('test','test1'),'no','yes') | +---------------------------------------+ | 1 row in set (0.00 sec) FUOC 71Z799014MO 32 Bases de datos en MySQL Presentamos primero la ej ecuci\u00f3n de una sentencia SQL m\u00e1s o menos compleja: Ahora utilizamos la sentencia EXPLAIN para que MySQL nos explique c\u00f3mo ha realizado esta consulta: mysql> explain select productos.clave, provee dores.empresa , precio , pago from productos natural join precios natural jo in proveedores; En cada fila del resultad o, nos explica c\u00f3mo ha ut ilizado los \u00edndices de cada tabla involucrada en la cons ulta. La columna 'type' nos indica el tipo de \"join\" que ha podido hacer. En nuestro caso, 'e q_ref', 'ref' o 'ref_or_null' indica que se ha consultado una fila de esta tabl a para cada combinac i\u00f3n de filas de las otras. Es una buena se\u00f1al, se est\u00e1n utiliz ando los \u00edndices, tal como indican el resto de columnas (en concreto el atri buto 'clave' que es su clave primaria). Vemos que en las otras dos ta blas, el tipo de 'join' es ALL, esto indica que el gestor ha tenido que leer toda la tabl a para comprobar las condiciones que le hemos exigido en la consulta. En el caso de la tabla proveedores, habr\u00eda podi - do utilizar la clave primaria ('poss ible_keys'), pero no lo ha hecho.mysql> select productos.clave, especificaci\u00f3n) as producto, proveedores.em - presa , precio , pago from productos natural join precios natural join proveedores; +-------+----------------------------+----------+--------+------------------+ | clave | producto | empresa | precio | pago | +-------+----------------------------+----------+--------+------------------+ | 003 | Procesador 1.7 GHz 64 bits | Tecno-k | 198.34 | cr\u00e9dito | | 005 | RAM 128MB 333 MHz | Tecno-k | 9.27 | cr\u00e9dito | | 006 | RAM 256MB 400 MHz | Tecno-k | 34.85 | cr\u00e9dito | | 007 | Disco Duro 80 GB 7200 rpm | Tecno-k | 59.95 | cr\u00e9dito | | 010 | Disco Duro 40 GB 4200 rpm | Tecno-k | 61.22 | cr\u00e9dito | | 012 | Monitor 1024x876 60 Hz | Tecno-k | 62.29 | cr\u00e9dito | | 001 | Procesador 2 GHz 32 bits | Patito | 30.40 | efectivo | | 002 | Procesador 2.4 GHz 32 bits | Patito | 33.63 | efectivo | | 003 | Procesador 1.7 GHz 64 bits | Patito | 195.59 | efectivo | | 005 | RAM 128MB 333 MHz | Patito | 9.78 | efectivo | | 006 | RAM 256MB 400 MHz | Patito | 32.44 | efectivo | | 007 | Disco Duro 80 GB 7200 rpm | Patito | 59.99 | efectivo | | 010 | Disco Duro 40 GB 4200 rpm | Patito | 62.02 | efectivo | | 001 | Procesador 2 GHz 32 bits | Nacional | 30.82 | cr\u00e9dito,efectivo | | 002 | Procesador 2.4 GHz 32 bits | Nacional | 32.73 | cr\u00e9dito,efectivo | | 003 | Procesador 1.7 GHz 64 bits | Nacional | 202.25 | cr\u00e9dito,efectivo | | 005 | RAM 128MB 333 MHz | Nacional | 9.76 | cr\u00e9dito,efectivo | | 006 | RAM 256MB 400 MHz | Nacional | 31.52 | cr\u00e9dito,efectivo | | 007 | Disco Duro 80 GB 7200 rpm | Nacional | 58.41 | cr\u00e9dito,efectivo | | 010 | Disco Duro 40 GB 4200 rpm | Nacional | 64.38 | cr\u00e9dito,efectivo | +-------+----------------------------+----------+--------+------------------+ 20 rows in set (0.00 sec) +-------------+--------+---------------+---------+---------+---------------+------+------------+ | table | type | possible_keys | key | key_len | ref | rows | Extra | +-------------+--------+---------------+---------+---------+---------------+------+------------+ | precios | ALL | NULL | NULL | NULL | NULL | 20 | | | productos | eq_ref | PRIMARY | PRIMARY | 4 | precios.clave| 1 | | | proveedores | ALL | PRIMARY | NULL | NULL | NULL | 3 | where used | +-------------+--------+---------------+---------+---------+---------------+------+------------+ 3 rows in set (0.00 sec) FUOC 71Z799014MO 33 Bases de datos en MySQL Vamos a intentar mejorar esta consulta. Vemos que en la tabla precios no se ha definido ning\u00fan \u00edndice, lo qu e facilitar\u00eda la labor al SGBD: Las cosas han cambiado sustancialmente. El gestor ha pasado de leer 24 filas de datos, a leer 11. Tambi\u00e9n ha cambiado el orden de lectura de las tablas, ha - ciendo primero una lectura total de la tabla proveedores (que es inevitable ya que no hemos puesto ning una condici\u00f3n en el SELECT) y, despu\u00e9s, ha apro - vechado los \u00edndices definidos en 'precios' y en 'productos'. 4.3. Manipulaci\u00f3n de filas Para la manipulaci\u00f3n de filas dispon emos de las sentencias SQL INSERT, UP - DATE y DELETE, su uso y sintaxis ya se ha visto en el m\u00f3dulo 3 de este curso. En algunos casos, MySQL nos proporci ona extensiones o modificadores que nos pueden ayudar mucho en determinadas situaciones. INSERT [DELAYED]. Cuando la senten cia INSERT puede tardar mucho en devolver el resultado (tablas muy grandes o con muchos \u00edndices que deben recalcularse al insertar una nueva fila ) puede ser interesante a\u00f1adir la pala - bra clave DELAYED para que MySQL nos devuelva el control y realice la in - serci\u00f3n en segundo plano. INSERT [[LOW_PRIORITY] | [HIGH_PRIO RITY]]. En tablas muy ocupadas, donde muchos clientes realizan cons ultas constantemen te, una inserci\u00f3n lenta puede bloquear al resto de clie ntes durante un tiempo. Mediante es - tos modificadores podemos variar este comportamiento. INSERT [IGNORE]. Este mo dificador convierte los e rrores de inserci\u00f3n en avisos. Por ejemplo, si intentamos in sertar una fila que duplica una clave primaria existente, el SG BD nos devolver\u00e1 un aviso (y no insertar\u00e1 la nueva fila), pero nuestro programa cliente po dr\u00e1 continuar con su cometido si el resultado de la inserci\u00f3n no era im portante para su correcta ejecuci\u00f3n.mysql> alter table precios add index (empresa); , precio , pago from productos natural join precios natural join proveedores; +-------------+--------+-----------------------+-------------+---------+--------------+-----+-----------+ | table | type | possible_keys | key | key_len | ref |rows | Extra | +-------------+--------+-----------------------+-------------+---------+--------------+-----+-----------+ | proveedores | ALL | PRIMARY | NULL | NULL | NULL | 3 | | | precios | ref | empresa_idx,clave_idex| empresa_idx | 20 | productos.emp| 7 | | | productos | eq_ref | PRIMARY | PRIMARY | 4 | precios.clave| 1 | | +-------------+--------+-----------------------+-------------+---------+--------------+-----+-----------+ 3 rows in set (0.00 sec) Veremos m\u00e1s sobre los \u00edndices en el subapartado 5.5 \"An\u00e1lisis y optimizaci\u00f3n\" de esta unidad did\u00e1ctica. FUOC 71Z799014MO 34 Bases de datos en MySQL UPDATE [LOW_PRIORITY] [IGNORE]. Se comportan de igual modo que en la sentencia INSERT. DELETE [QUICK]. Borra el/los registros sin actualizar los \u00edndices. TRUNCATE. Es una forma muy r\u00e1pida de borrar todos los registros de una tabla, si no necesitamos saber el n\u00fa mero de registros que ha borrado. DE - LETE FROM <tabla> realiza el mismo cometido, pero devuelve el n\u00famero de registros borrados. LAST_INSERT_ID(). Devuelve el \u00falti mo identificador asignado a una co - lumna de tipo AUTO_INCREMENT despu\u00e9s de una sentencia INSERT. FUOC 71Z799014MO 35 Bases de datos en MySQL 5. Administraci\u00f3n de MySQL Las tareas administrativas como la instal aci\u00f3n, gesti\u00f3n de usuarios, copias de seguridad, restauraciones, entre otras, son tareas ineludibles en cualquier or - ganizaci\u00f3n. Las pol\u00edticas, los recursos y preferencias de los administradores ge - neran una gran variedad de estilos y mecanismos para llevar a cabo estas tareas, por lo que no es posible habl ar de m\u00e9todos completamente estandari - zados en estas \u00e1reas. En este apartado se contemplan las opciones de uso com\u00fan para la adminis - traci\u00f3n de un servidor MySQL. Existen ta ntas alternativas que no es posible in - cluirlas todas en un curso. Por tal motivo, en este cap\u00edtulo se tratan algunos temas de importancia para el administ rador, desde una pe rspectiva general, que permiten obtener una visi\u00f3n global de las posibilidades pr\u00e1cticas de las herramientas administrativas. En este sentido, el manual de MySQL es la referencia principal para encontrar posibilidades y resolver dudas. En especial se recomienda leer los siguientes cap\u00edtulos: Cap\u00edtulo 2. Instalaci\u00f3n de MySQL. Cap\u00edtulo 4. Administraci\u00f3n bases de datos. C a p \u00ed t u l o 5 . O p t i m i z a c i \u00f3 n . La informaci\u00f3n contenida en el los es muy amplia y clara, y representa una excelente gu\u00eda para resolver dudas. Asimismo, se deben tener en cuenta las listas de correo incluidas en el sitio oficial www.mysql.com. Este cap\u00edtulo se inicia con una breve rese \u00f1a del proceso de instalaci\u00f3n de MySQL. En la actualidad es posible realizar la instalaci\u00f3n a partir de binarios empaqueta - dos que facilitan enormemente el proceso. La administraci\u00f3n de usuarios se trata con algo m\u00e1s de detalle, incluyendo una breve descripci\u00f3n de las tablas del directorio de datos. Para los temas de copias de seguridad y restauraci\u00f3n se muestran los comand os y utilidades de mayor uso en la pr\u00e1ctica omitiendo al - gunos detalles t\u00e9cnicos poco usuales. La optimizaci\u00f3n se trata de manera muy general, exponiendo los temas b\u00e1sicos que en la pr\u00e1ctica son pasados por alto. Finalmente, se describe brevemente c\u00f3mo realizar la replicaci\u00f3n de datos en un servidor esclavo. 5.1. Instalaci\u00f3n de MySQL La instalaci\u00f3n de MySQL no representa mayores problemas, ya que muchas distribuciones incluyen paquetes con lo s que realizar la instalaci\u00f3n y configu - raci\u00f3n b\u00e1sica. Sin embargo, aqu\u00ed veremos la instalaci\u00f3 n de MySQL utilizando el c\u00f3digo fuente que se puede obtener en www.mysql.com. Cabe destacar que el uso de una versi\u00f3n de MySQL compilada ti ene la ventaja de que, probablemente, FUOC 71Z799014MO 36 Bases de datos en MySQL se adaptar\u00e1 mucho mejor al entorno del servidor donde se ejecutar\u00e1, proporcio - nando as\u00ed un mejor rendimiento. Por contra, implicar\u00e1 m\u00e1s trabajo en caso de que surjan errores en la versi\u00f3n y teng amos que actualizarla. Las instrucciones que se describen en este apartado se ba san en la documentaci\u00f3n incluida en la distribuci\u00f3n. En primer lugar, debemos asegurarnos de que contamos con las librer\u00edas y uti - lidades necesarias para compilar los ficher os fuente. Principalmente la lista de verificaci\u00f3n debe incluir los ficheros siguientes: C o m p i l a d o r g c c Librer\u00edas libgc El proceso de instalaci\u00f3n in cluye los siguientes pasos: Descomprimir los archivos fuente Configurar la versi\u00f3n de MySQL que va mos a obtener. El script 'configure' admite muchos par\u00e1metros que debere mos examinar mediante la opci\u00f3n '--help'. Seg\u00fan los esquemas de tabl a que necesitemos o extensiones muy concretas que debamos utilizar, debe remos examinar con cuidado sus op - ciones. En su versi\u00f3n m\u00e1s simple lo ejecutar\u00edamos de la siguiente manera: Compilar. Procederemos a compilar si no ha habido problemas con la con - figuraci\u00f3n. El par\u00e1metro -prefix especifi ca la ruta del sistema de ficheros donde ser\u00e1 instalado. Instalar el sistema el servidor ya compilado, mediante la siguiente ins - trucci\u00f3n:cd /usr/local/src tar xzvf install FUOC 71Z799014MO 37 Bases de datos en MySQL Crear la base de datos in icial del servidor, la que almacenar\u00e1 los usuarios y privilegios. Esta base de datos es impr escindible para qu e los usuarios se puedan conectar al servidor. Crear un nuevo usuario y su grupo, para que el servicio se ejecute en un entorno de privilegios restringido en el sistema operativo. En ning\u00fan caso se recomienda que el usuario que ejecute el servicio mysqld sea root. Todos los archivos deben ser propiedad de root (mysql no debe poder modifi - carse a s\u00ed mismo) y del grupo mysql. El directorio de datos ser\u00e1 del usuario mysql para que pueda trabajar con las bases de datos, ficheros de registro, etc. Crear el archivo de configuraci\u00f3n. La distribuci\u00f3n incluye varios archivos de configuraci\u00f3n que sirven como plan tilla para adaptarl o a nuestras nece - sidades. En este caso, utilizamos la configur aci\u00f3n media como plantilla. Opcionalmente podemos editar el archivo /etc/my.cnf Lanzar el servidor En este estado, el servidor no puede servir a\u00fan de SGBD. Por defecto, ten - dremos creado un usuario ' root' sin contrase\u00f1a que po dr\u00e1 acceder tanto des - de el equipo local como remotamente. El siguiente paso ser\u00e1 asignar una contrase\u00f1a a este usuario y repasar los usuarios y privilegios definidos. Para asignar la contrase\u00f1a, debe remos hacer lo siguiente:scripts/mysql_istall_db Bases de datos en MySQL Podemos probar el funcionamiento del SGBD conectando con el cliente 'mysql': Veamos ahora algunas caracter\u00edsticas del servidor que acabamos de instalar: mysqld . El primer m\u00e9todo es lanzarlo di rectamente, se le pueden especifi - car las opciones que el administrador desee. mysqld_safe . Es un script que ejecuta mysqld garantizando una configuraci\u00f3n segura. Es mucho m\u00e1s reco mendable que ejecutar mysqld directamente. mysql_server . Es un gui\u00f3n que realiza dos tare as: iniciar y detener el servidor mysqld con los par\u00e1metros start y stop respectivamente. Utiliza mysqld_safe para lanzar el servidor mysqld . No es com\u00fan encontrarlo con ese nombre, ya que generalmente se copia como el archivo /etc/init.d/mysql mysql_multi . Permite la ejecuci\u00f3n de m\u00falt iples servidores de forma si - multanea. Para detener el servidor b\u00e1 sicamente tenemos dos m\u00e9todos: /etc/init.d/mysql stop. Es el mecanismo est\u00e1ndar en los sistemas tipo UNIX. Aunque los direct orios pueden cambiar. $ mysqladmin -u root -p shutdown. Es la utilidad para realizar tareas ad - ministrativas en un servidor MySQL, en este caso le pasamos el par\u00e1metro 'shutdown' para de tener el servicio. Para que los mensajes del se rvidor aparezcan en espa\u00f1ol, se debe ejecutar con el par\u00e1metro -language: Otra opci\u00f3n es agregar en el archivo /e tc/my.cnf una l\u00ednea en la secci\u00f3n [mysqld] 5.2. Usuarios y privilegios El acceso al servidor MySQL est\u00e1 cont rolado por usuarios y privilegios. Los usuarios del servidor MySQL no tienen ninguna correspondencia con los mysql -u root -p $ mysqld --language=spanish [mysqld] language = /usr/share/mysql/spanish FUOC 71Z799014MO 39 Bases de datos en MySQL usuarios del sistema operativo. Aunque en la pr\u00e1ctica es com\u00fan que alg\u00fan ad - ministrador de MySQL asigne los mismos nombres que los usuarios tienen en el sistema, son mecanismos totalmente independientes y suele ser aconsejable en general. El usuario administrador del sistema MySQL se llama root. Igual que el supe - rusuario de los sistemas tipo UNIX. Adem\u00e1s del usuario root, las instalaciones nuevas de MySQL incluyen el usua - rio an\u00f3nimo, que tiene permisos sobre la base de datos test. Si queremos, tam - bi\u00e9n podemos restringirlo asign\u00e1ndole una contrase\u00f1a. El usuario an\u00f3nimo de MySQL se representa por una cadena va c\u00eda. Vemos otra fo rma de asignar con - trase\u00f1as a un usuario, desde el cliente de mysql y como usuario root: La administraci\u00f3n de privilegios y usuari os en MySQL se realiza a trav\u00e9s de las sentencias: GRANT . Otorga privilegios a un usuario, en caso de no existir, se crear\u00e1 el usuario. REVOKE . Elimina los privilegios de un usuario existente. SET PASSWORD . Asigna una contrase\u00f1a. DROP USER . Elimina un usuario. 5.2.1. La sentencia GRANT La sintaxis simplificada de grant consta de tres secciones. No puede omitirse ninguna, y es importante el orden de las mismas: grant lista de privilegios on base de datos.tabla to usuario Ejemplo Creaci\u00f3n de un nuevo usuario al que se otorga algunos privilegios En la primera l\u00ednea se especifica n los privilegios que ser\u00e1n otorga dos, en este caso se permite actualizar ( update ), insertar (i nsert) y consultar ( select ). La segunda l\u00ednea especifica que los privilegios se aplican a la tabla precios de la base de datos demo . En la \u00faltima l\u00ednea se encuen - tra el nombre del usuario y el equipo desd e el que se va a permitir la conexi\u00f3n.mysql> set password for ''@'localhost' = ; FUOC 71Z799014MO 40 Bases de datos en MySQL El comando grant crea la cuenta si no existe y, si existe, agrega los privilegios especificados. Es posible asignar una co ntrase\u00f1a a la cuenta al mismo tiempo que se crea y se le otorgan privilegios: En la misma sentencia es posible tamb i\u00e9n otorgar permisos a m\u00e1s de un usua - rio y asignarles, o no, contrase\u00f1a: 5.2.2. Especificaci\u00f3n de luga res origen de la conexi\u00f3n MySQL proporciona mecanismos para permitir que el usuario realice su co - nexi\u00f3n desde diferentes equipos dentro de una red espec\u00edfica, s\u00f3lo desde un equipo, o \u00fanicamente desde el propio servidor. El car\u00e1cter % se utiliza de la misma forma que en el comando like: sustituye a cualquier cadena de caracteres. En este ca so, se permitir\u00eda el acceso del usuario 'visitante' (con contrase\u00f1a, si la tuviese definida) desde cualquier equipo del dominio 'empresa.com'. Obs\u00e9rvese que es necesario entrecomillar el nombre del equipo origen con el fin de que sea aceptado por MySQL. Al igual que en like, puede utilizarse el car\u00e1cter '_'. Entonces, para permitir la entrada desd e cualquier equipo en Internet, escribi - r\u00edamos:mysql> 41 de datos en MySQL Obtendr\u00edamos el mismo resultado omitie ndo el nombre del equipo origen y escribiendo simplemente el nombre del usuario: Los anfitriones v\u00e1lidos tambi\u00e9n se pued en especificar con sus direcciones IP. Los caracteres ' %' y '_' no se permiten en los nombres de los usuarios. 5.2.3. Especificaci\u00f3n de bases de datos y tablas Despu\u00e9s de analizar las opciones refere ntes a los lugares de conexi\u00f3n permiti - dos, veamos ahora c\u00f3mo podemos limitar los privilegios a bases de datos, ta - blas y columnas. En el siguiente ejemplo otorgamos privilegi os sobre todas las tablas de la base de datos demo . Podemos obtener el mismo resultado de esta forma: De igual modo, al especifica r s\u00f3lo el nombre de una tabla se interpretar\u00e1 que pertenece a la base de datos en uso:-> to visitante to visitante@192.168.128.10 to visitante@'192.168.128.%' to 'visitante'@'localhost'; FUOC 71Z799014MO 42 Bases de datos en MySQL Opciones para la clausula on del comando grant 5.2.4. Especificaci\u00f3n de columnas A continuaci\u00f3n presentamos un ejempl o donde se especifican las columnas sobre las que se otorgan privilegios con el comando grant : Podemos especificar privilegios diferentes para cada columna o grupos de co - lumnas: 5.2.5. Tipos de privilegios MySQL proporciona una gran variedad de tipos de privilegios. Privilegios relaci onados con tablas: super reload, replication client, grant . El privilegio all otorga todos los privilegios exceptuando el privilegio grant option . Y el privilegio usage no otorga ninguno, lo cual es \u00fatil cuando se desea, por ejemplo, simplemente cambiar la contrase\u00f1a:Opci\u00f3n Significado *.* Todas las bases de datos y todas las tablas base.* Todas las tablas de la ba se de datos especificada tabla Tabla especificada de la base de datos en uso * Todas las tablas de la base de datos en uso mysql> grant update (precio,empresa) -> on demo.precios -> 'secreto'; FUOC 71Z799014MO 43 Bases de datos en MySQL Tipos de privilegios en MySQL En entornos grandes, es frecuente enco ntrarse en la necesidad de delegar el trabajo de administrar un servidor de bases de datos para que otros usuarios, adem\u00e1s del administrador, puedan resp onsabilizarse de otorgar privilegios so - bre una base de datos particular. Esto se puede hacer en MySQL con el privile - gio grant option : El mismo resultado se puede obtener con la siguiente sintaxis alternativa:Tipo de privilegio Operaci\u00f3n que permite all [privileges] Otorga todos los privilegios excepto grant option usage No otorga ning\u00fan privilegio alter Privilegio para alterar la estructura de una tabla create Permite el uso de create table delete Permite el uso de delete drop Permite el uso de drop table index Permite el uso de index y drop index insert Permite el uso de insert select Permite el uso de select update Permite el uso de update file Permite le uso de select . . . into outfile y load data infile process Permite el uso de show full procces list super Permite la ejecuci\u00f3n de comandos de supervisi\u00f3n reload Permite el uso de flush replication client Permite preguntar la localizaci\u00f3n de maestro y esclavo replication slave Permite leer los binlog del maestro grant option Permite el uso de grant y revoke shutdown Permite dar de baja al servidor lock tables Permite el uso de lock tables show tables Permite el uso de show tables el grant option ; FUOC 71Z799014MO 44 Bases de datos en MySQL De este modo el usuario operador podr\u00e1 disponer de todos los privilegios sobre la base de datos demo , incluido el de controlar el acceso a otros usuarios. 5.2.6. Opciones de encriptaci\u00f3n MySQL puede establecer conexiones seguras encript\u00e1ndolas mediante el pro - tocolo SSL*; de esta manera, los datos qu e se transmiten (tanto la consulta, en un sentido, como el resultado, en el ot ro) entre el cliente y el servidor estar\u00e1n protegidos contra intrusos. Para especi ficar que un usuario debe conectarse obligatoriamente con este protoc olo, se utiliza la cl\u00e1usula require : Las conexiones encriptadas ofrecen protecci\u00f3n co ntra el robo de informaci\u00f3n, pero suponen una carga adicional para el serv icio, que debe desencriptar la petici\u00f3n del cliente y encriptar la respuesta (adem\u00e1s de un proceso m\u00e1s largo de negociaci\u00f3n al conectar), por ello, merman el rendimiento del SGBD. 5.2.7. Limites de uso Los recursos f\u00edsicos del servidor siempr e son limitados: si se conectan muchos usuarios al mismo tiempo al servidor y realizan consultas o manipulaciones de datos complejas, es probable que pued a decaer el rendimiento notablemente. Una posible soluci\u00f3n a este problema es limitar a los usuarios el trabajo que pueden pedir al servidor con tres par\u00e1metros: M \u00e1 x i m o n \u00fa m e r o d e c o nexiones por hora. M \u00e1 x i m o n \u00fa m e r o d e consultas por hora. M\u00e1ximo n\u00famero de actualizaciones por hora. La sintaxis de estas lim itaciones es como se muestra a continuaci\u00f3n:mysql> grant Sockets FUOC 71Z799014MO 45 Bases de datos en MySQL 5.2.8. Eliminar privilegios El comando revoke permite eliminar priv ilegios otorgados con grant a los usuarios. Veamos un ejemplo representativo: Al ejecutar este comando se le retiran al usuario visitante todos sus privilegios sobre todas las bases de datos, cuando se conecta desde localhost . El comando anterior no retira todos los privilegios del usuario visitante , s\u00f3lo se los retira cuando se conecta desde localhost . Si el usuario se conecta desde otra localidad (y ten\u00eda permiso para hacerlo) sus privilegi os permanecen intactos. 5.2.9. Eliminar usuarios Antes de proceder a la elim inaci\u00f3n de un usuario, es necesario asegurarse de que se le han quitado primero todos su s privilegios. Una vez asegurado este detalle, se procede a elimin arlo mediante el comando drop user : 5.2.10. La base de datos de privilegios: mysql MySQL almacena la informaci\u00f3n sobre lo s usuarios y sus privilegios en una base de datos como cualqu ier otra, cuyo nombre es mysql . Si exploramos su estructura, entenderemos la manera como MySQL almacena la informaci\u00f3n de sus usuarios y privilegios: revoke all on *.* from | columns_priv | | db | | func | | host | | tables_priv | | user | +-----------------+ FUOC 71Z799014MO 46 Bases de datos en MySQL Es posible realizar modificaciones direct amente sobre estas tablas y obtener los mismos resultados que si utiliz\u00e1ramos los comandos grant , revoke , set pas- sword o drop user:mysql> show columns from user; +-----------------+------------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-----------------+------------------+------+-----+---------+-------+ | Host | char(60) binary | PRI | | | | | User | char(16) binary | PRI | | | | | Password | char(16) binary | | | | | | Select_priv | enum('N','Y') | N | | | | | Insert_priv | enum('N','Y') | | N | | | | Update_priv | enum('N','Y') | N | | | | | Delete_priv | enum('N','Y') | | N | | | | Create_priv | enum('N','Y') | N | | | | | Drop_priv | enum('N','Y') | N | | | | | Reload_priv | enum('N','Y') | | N | | | | Shutdown_priv | enum('N','Y') | N | | | | | Process_priv | enum('N','Y') | N | | | | | File_priv | enum('N','Y') | | N | | | | Grant_priv | enum('N','Y') | | N | | | | References_priv | enum('N','Y') | | N | | | | Index_priv | enum('N','Y') | | N | | | | Alter_priv | enum('N','Y') | |N | | | +-----------------+------------------+------+-----+---------+-------+ 17 rows in set (0.04 sec) mysql> show columns from db; +-----------------+------------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-----------------+------------------+------+-----+---------+-------+ | Host | char(60) binary | PRI | | | | | Db | char(64) binary | PRI | | | | | User | char(16) binary | PRI | | | | | Select_priv | enum('N','Y') | | N | | | | Insert_priv | enum('N','Y') | | N | | | | Update_priv | enum('N','Y') | | N | | | | Delete_priv | enum('N','Y') | | N | | | | Create_priv | enum('N','Y') | | N | | | | Drop_priv | enum('N','Y') | | N | | | | Grant_priv | enum('N','Y') | | N | | | | References_priv | enum('N','Y') | | N | N | | | Index_priv | enum('N','Y') | | N | | | | Alter_priv | enum('N','Y') | | N | | | +-----------------+------------------+------+-----+---------+-------+ 13 rows in set (0.00 sec) mysql> show columns +-----+ | Host | char(60) binary |PRI | | | Db | char(64) binary |PRI | | | | | User | char(16) binary |PRI | | | | | Table_name | char(60) binary || N | | | | Grantor | char(77) || N | | | | Timestamp | timestamp(14) || N | | | | Table_priv | set('Select','Insert','Update','Delete','Create','Drop','Grant','References','Index','Alter')| | N | | | | Column_priv | set('Select','Insert','Update','References') |N | | | | +--------------+----------------------------------------------------------------------------------------------+----+---+------- +-----+ rows in set (0.00 sec) mysql> update -> set Password = password('nuevapasswd') privileges ; FUOC 71Z799014MO 47 Bases de datos en MySQL El comando flush privileges solicita a MySQL que vuelva a leer las tablas de privilegios. En el momento de ejecutarse , el servidor lee la informaci\u00f3n de es - tas tablas sobre privilegios. Pero si se han alterado las tablas manualmente, no se enterar\u00e1 de los cambios ha sta que utilicemos el comando flush privileges . Tablas de la base de datos mysql El acceso directo a las tablas de privilegios es \u00fatil en varios casos; por ejemplo, para borrar un usuario del sistema en las ve rsiones de MySQL anteriores a la 4.1.1: No es posible eliminar me diante un solo comando revoke todos los privilegios de un usuario. Ejemplo Se otorgan derechos a un usuario con dos comandos grant . Observando el contenido de la base de datos de privilegios, podemos entender el comporta - miento de los comandos grant y revoke . Primero asignamos privilegios para usar el coman - do select al usuario visitante con dos comandos grant : el primero de ellos le permite el ingreso desde el servidor nuestra-ong.org y el segundo le otorga el mismo tipo de privilegio, pero desde cualquier equipo en Internet. Consultando la tabla user de la base de datos de privilegios , podemos observar los valores 'Y' en la columna del privilegio select . Tabla Contenido user Cuentas de usuario y su s privilegios globales db Privilegios sobres bases de datos tables_priv Privilegios sobre tablas columns_priv Privilegios sobre columnas host Privilegios de otros equipos anfitriones sobre bases de datos mysql> delete from user -> where User = 'visitante' and = 'visitante'; FUOC 71Z799014MO 48 Bases de datos en MySQL Ahora solicitamos eliminar el privilegio select de todas las bases de dato s y de todos los equipos en Internet. En la tabla user observamos que, efectivamente, se ha eliminado el privilegio para visi - tante@'%' pero no para 'visitante@nuestra -ong.org'. MySQL considera que son direccio - nes diferentes y respeta los privilegios otorgados a uno cuando se modifica otro. 5.3. Copias de seguridad Ning\u00fan sistema es perfecto ni est\u00e1 a salv o de errores humanos, cortes en el sumi - nistro de la corriente el\u00e9c trica, desperfectos en el hardware o errores de software ; as\u00ed que una labor m\u00e1s que recomendable de l administrador del servidor de bases de datos es realizar copias de seguridad y dise\u00f1ar un plan de contingencia. Se de - ben hacer ensayos del plan para asegurar su buen funcionamiento y, si se descu - bren anomal\u00edas, realizar los ajustes necesarios. No existe una receta universal que nos indique c\u00f3mo llevar nuestras copias de seguridad de datos. Cada administrador de be dise\u00f1ar el de su sistema de acuer - do a sus necesidades, recursos, ries gos y el valor de la informaci\u00f3n. MySQL ofrece varias alternativas de copi a de seguridad de la informaci\u00f3n. La primera que podemos mencio nar consiste simplemente en copiar los archivos de datos. Efectivamente, es una opci\u00f3n v\u00e1lida y sencilla. En primera instancia son necesarios dos requisitos para llevarla a cabo: Conocer la ubicaci\u00f3n y estruc tura del directorio de datos. Parar el servicio MySQL mi entras se realiza la copia.+-----------+-----------------+-------------+ | user | host | select_priv | +-----------+-----------------+-------------+ | visitante | nuestra-ong.org | Y | | visitante | % | Y | +-----------+-----------------+-------------+ 2 rows in set (0.00 = 'visitante'; +-----------+-----------------+-------------+ | user | host | select_priv | +-----------+-----------------+-------------+ | visitante | nuestra-ong.org | Y | | visitante | % | N | +-----------+-----------------+-------------+ 2 rows in set (0.01 sec) FUOC 71Z799014MO 49 Bases de datos en MySQL En cuanto a la ubicaci\u00f3n y estructura del directorio, record emos que la distri - buci\u00f3n de MySQL ubica el directorio de datos en /usr/local/mysql/var, las dis - tribuciones GNU/Linux basa das en paquetes como DEB o RPM ubican, por lo general, los datos en /var/lib/mysql. Si por alg\u00fan motivo no encontramos el direct orio de datos, podemos consultarlo a MySQL. El comando show variables nos muestra todas las variables di sponibles, basta realizar un fil - tro con la clausula like: Una vez ubicados los archivos, detenemo s la ejecuci\u00f3n del servidor: un modo sencillo de asegurarnos de que la base de datos no ser\u00e1 modificada mientras terminamos la copia: Finalmente, copiamos el directorio co mpleto con todas las bases de datos: Por supuesto podemos elegir otras formas de copiarlo o comprimirlo, de acuer - do a nuestras preferencias y necesidades. Si queremos copiar s\u00f3lo una base de datos, copiamos el directorio con el mis - mo nombre de la base de datos: Tambi\u00e9n es posible hacer copia de seguridad de una sola tabla. Como podemos observar, la organizaci\u00f3n de la base de datos en MySQL es muy simple: Todas las bases de datos se almacenan en un directorio, llamado el directo - rio de datos( datadir ).mysql> show variables like 'datadir'; +---------------+-----------------+ +---------------+-----------------+ | /var/lib/mysql/ | (0.00 algun_dir/backup_demo/ FUOC 71Z799014MO 50 Bases de datos en MySQL Cada base de datos se almacena como un subdirectorio del directorio de datos. Cada tabla se almacena en un archivo, acompa\u00f1ada de otros archivos auxi - liares con el mismo nombre y diferente extensi\u00f3n. El problema de este mecanismo es que debemos detener el servicio de bases de datos mientras realizamos el respaldo. 5.3.1. mysqlhotcopy Un mecanismo que permite realizar la co pia de los archivos del servidor sin necesidad de detener el servicio es el script 'mysqlhotcopy '. El script est\u00e1 escrito en Perl y bloquea las tablas mientras re aliza el respaldo para evitar su modifi - caci\u00f3n. Se usa de la siguiente manera: En este caso, crear\u00e1 un directorio /algun_direc torio/demo con todos los archivos de la base de datos. El comando mysqlhotcopy puede recibir s\u00f3lo el nombre de una base de datos como par\u00e1metro: En este caso, crear\u00e1 un direct orio /var/lib/mysql/demo_copy. Este m\u00e9todo no funciona para tablas con el mecanismo de almacenamiento tipo InnoDB. 5.3.2. mysqldump Las dos opciones anteriores representan copias binarias de la base de datos. El comando mysqldump , en cambio, realiza un volcad o de las bases de datos pero traduci\u00e9ndolas a SQL; es decir, entrega un archivo de texto con todos los co - mandos necesarios para volver a reconstruir las bases de datos, sus tablas y sus datos. Es el m\u00e9todo m\u00e1s \u00fatil para copiar o distribuir una base de datos que de - ber\u00e1 almacenarse en otros servidores. $ mysqlhotcopy demo /algun_directorio $ mysqlhotcopy demo $ mysqldump demo > demo.sql FUOC 71Z799014MO 51 Bases de datos en MySQL El comando mysqldump ofrece multitud de par\u00e1me tros para modificar su com - portamiento o el tipo de volcado gene rado: por defecto, genera sentencias SQL, pero puede generar ficheros de da tos tipo CSV u otros formatos. Tambi\u00e9n podemos especificarle que haga el volcado de todas las bases de datos o que s\u00f3lo vuelque los datos y no la creaci\u00f3n de las tablas, etc. Las primeras l\u00edneas del archivo demo.sql seg\u00fan el ejemplo anterior tendr\u00edan el siguiente aspecto: La ventaja de utilizar mysqldump es que permite que los archivos puedan ser le\u00eddos (y modificados) en un simple ed itor de textos, y pu eden ser utilizados para migrar la informaci\u00f3n a otro SG BD que soporte SQL. Adem\u00e1s soporta to - dos los tipos de tablas. La desventaja es que su procesamiento es lento y los archivos que se obtienen son muy grandes. 5.3.3. Restaurar a partir de respaldos En alg\u00fan momento, sea por el motivo qu e sea, necesitaremo s realizar la res - tauraci\u00f3n de nuestras bases de datos. Si tenemos una copia binaria del directorio de datos, bastar\u00e1 con copiarla al directorio original y reiniciar el servidor:~$ mysqldump demo | head -25 -- MySQL dump 8.21 -- -- Host: localhost Database: -- Dumping data Bases de datos en MySQL Es importante restau rar tambi\u00e9n el due\u00f1o y el grup o de los archivos de datos, para tener los accesos corre ctamente establecidos. En este ejemplo se adopta el supuesto que el usuario mysql es el que ejecuta el servidor mysqld . La restauraci\u00f3n de un archivo SQL obtenido con mysqldump , se realiza desde el cliente mysql , la base de datos debe existir, ya que el archivo demo.sql no la crea por defecto. 5.4. Reparaci\u00f3n de tablas En determinadas circunstancias de uso muy frecuente, como la inserci\u00f3n y bo - rrado masivos de datos, coincidiendo con bloqueos del sistema o llenado del espacio en disco u otras circunstancias, es posible que una tabla o algunos de sus \u00edndices se corrompan. Podemos consultar el estado de integridad de una tabla con el comando check table , que realiza algunas verificaciones so bre la tabla en busca de errores y nos entrega un informe con las sigu ientes columnas de informaci\u00f3n: La columna Op describe la operaci\u00f3n que se realiza sobre la tabla. Para el comando check table esta columna siempre tiene el valor check porque \u00e9sa es la operaci\u00f3n que se realiza. La columna Msg_type pude contener uno de los valores status , error, info, o warning . Y la columna Msg_text es el texto que reporta de alguna situaci\u00f3n encontrada en la tabla. Es posible que la informaci\u00f3n entregada incluya varias filas con diversos men - sajes, pero el \u00faltimo mensaje siempre debe ser el mensaje OK de tipo status . En otras ocasiones check table no realizar\u00e1 la verificaci \u00f3n de tabla, en su lugar entregar\u00e1 como resultado el mensaje Table is already up to date , que significa que el gestor de la tabla indica que no hay necesidad de revisarla. MySQL no permite realizar consultas sobre una tabla da\u00f1ada y enviar\u00e1 un mensaje de error sin desple gar resultados parciales:$ demo -u | Msg_text | +--------------+-------+----------+----------+ | demo.precios | check | status | OK | +--------------+-------+----------+----------+ 1 row in set (0.03 sec) mysql> select * from precios; ERROR 'precios.MYD'. (Error: 145) FUOC 71Z799014MO 53 Bases de datos en MySQL Para obtener informaci\u00f3n del significado del er ror 145, usaremos la utilidad en l\u00ednea de co - mandos perror : Despu\u00e9s de un mensaje como el anterior, es el momento de realizar una veri - ficaci\u00f3n de la integridad de la tabla para obtener el reporte. En este caso localizam os dos errores en la tabla. La opci\u00f3n extended es uno de los cinco ni - veles de comprobaci\u00f3n que se pueden solicitar para verificar una tabla. Tipos de verificaci\u00f3n La sentencia repair table realiza la reparaci\u00f3n de ta blas tipo MyISAM corruptas: El segundo mensaje informa de la p\u00e9rdida de 13 filas durante el proceso de repa - raci\u00f3n. Esto significa, como es natural, que el comando repair table es \u00fatil s\u00f3lo en casos de extrema necesidad, ya que no garantiza la recuperaci\u00f3n total de la in - formaci\u00f3n. En la pr\u00e1ctica, si empre es mejor realizar la restauraci\u00f3n de la informa - ci\u00f3n utilizando las copias de seguridad. En caso de desastre, se debe conocer el motivo que origina la corrupci\u00f3n de las ta blas y tomar las medidas adecuadas para evitarlo. En lo que respecta a la estabilidad de MySQL, se puede confiar en que muy probablemente nunca ser\u00e1 necesario utilizar el comando repair table .$ perror 145 145 = +-------------+------+----------+--------------------------------------+ 2 rows in set (0.00 sec) Tipo Significado quick No revisa las filas en busc a de referencias incorrectas. fast Solamente verifica las tablas que no fueron cerradas adecuadamente. changedVerifica s\u00f3lo las tablas mo dificadas desde la \u00faltima verificaci\u00f3n o que no se han cerrado apropiadamente. mediumRevisa las filas para verificar que los ligados borrados son correctos, verifica las sumas de comprobaci\u00f3n de las filas. extendedRealiza una b\u00fasqueda completa en todas las claves de cada columna. Garantiza el 100% de la integridad de la tabla. mysql> repair table precios; | changed from 20 to 7 | |demo.precios |repair| status | OK | +-------------+-------+--------+--------------------------------------+ 3 rows in set (0.04 sec) FUOC 71Z799014MO 54 Bases de datos en MySQL El comando optimize table puede tambi\u00e9n realizar algunas correcciones so - bre una tabla. 5.4.1. myisamchk El programa myisamchk es una utilidad en l\u00ednea de comandos que se incluye con la distribuci\u00f3n de MySQL y sirve pa ra reparar tablas tipo MyISAM. Para utilizarlo con seguridad el servidor no debe estar ejecut\u00e1n dose y se recomien - da realizar un respaldo del director io de datos antes de su utilizaci\u00f3n. Recibe como par\u00e1metro pr incipal los archivos .MYI correspondientes a las ta - blas que hay que revisar; es decir, myisamchk no conoce la ubicaci\u00f3n del di - rectorio de datos. Por ejemplo, si el directorio de datos est\u00e1 ubicado en /val/ lib/mysql, las siguientes se r\u00edan dos maneras de realizar una comprobaci\u00f3n de los archivos de la base de datos demo : Se pueden revisar todas las bases de da tos utilizando '*' para denominar el di - rectorio de la base de datos: Para realizar una comproba ci\u00f3n r\u00e1pida, el manual su giere utilizar el siguiente comando: Y para realizar la correcci\u00f3n de las tabl as corruptas, el manual sugiere la sin - taxis siguiente: Las opciones dadas por -O se refieren al uso de memoria, que permiten acelerar de forma no - toria el proceso de reparaci\u00f3n. --force reinicia myisamchk con el par\u00e1metro --recover cuando encuentra alg\u00fan error. --updatestate almacena informaci\u00f3n sobre el resu ltado del an\u00e1lisis en la tabla MYI.# write_buffer=1M *.MYINota En la pr\u00e1ctica con estas opcio- nes se logran corregir los errores m\u00e1s comunes. Para co-nocer otras opciones de recu-peraci\u00f3n con myisamchk , pod\u00e9is consultar el manual que acompa\u00f1a a la distribu-ci\u00f3n de MySQL. FUOC 71Z799014MO 55 Bases de datos en MySQL 5.5. An\u00e1lisis y optimizaci\u00f3n El dise\u00f1o de MySQL le permite funcio nar con un rendimiento notable, sin em - bargo, se pueden cometer f\u00e1cilmente errores que disminuyan la capacidad de respuesta del servidor. Tambi\u00e9n se pueden realizar algunos ajustes a la confi - guraci\u00f3n de MySQL que incrementan su rendimiento. 5.5.1. Indexaci\u00f3n La indexaci\u00f3n es la principal herram ienta para optimizar el rendimiento ge - neral de cualquier base de datos. Es tambi\u00e9n la m\u00e1s conocida por los usuarios de servidores MySQL y, parad\u00f3jicamente, su no utilizaci\u00f3n es una de las prin - cipales causas de bajo rendimiento en servidores de bases de datos. Muchos administradores y dise\u00f1adores simplemente parecen olvidar usar \u00edndices para opti - mizar los accesos a las bases de datos. Por otro lado, algunas personas tienden a indexar todo, esperando que de esta manera el servidor acelere cualquier tipo de consulta que se le solicite. En realidad, esta pr\u00e1ctica pued e causar una disminuci\u00f3n en el rendimiento, sobre todo en lo que respecta a inserciones y modificaciones. Para ver las ventajas de utilizar \u00edndice s, analizaremos en primer t\u00e9rmino una simple b\u00fasqueda en una tabla sin \u00edndice alguno: El constante acceso de escritura de una tabla la mantiene desordenada. La ordenaci\u00f3n de una tabla es una op eraci\u00f3n costosa: el servidor tendr\u00eda que detenerse un tiempo consider able para ordenar sus tablas. Muchas tablas tienen m\u00e1s de un criterio de ordenaci\u00f3n: ordenar seg\u00fan una columna implica desordenar otra. La inserci\u00f3n y eliminaci\u00f3n de datos sin alterar el orden en una tabla es cos - tosa: la inserci\u00f3n de un registro en una tabla grande implicar\u00eda una larga espera en la actualizaci\u00f3n de la misma. Si se opta por mantener la tabla desord enada (que es la opci\u00f3n m\u00e1s viable), una b\u00fasqueda implicar\u00eda forzosamente un recorrido secuencial (tambi\u00e9n denominado full scan ), registro por registro. El uso de \u00edndices en la ordenaci\u00f3n de las bases de datos ofrece las ventajas si - guientes: Permite ordenar las tablas por varios criterios simult\u00e1neamente. Es menos costoso ordenar un archivo \u00edndice, porque incluye s\u00f3lo referen - cias a la informaci\u00f3n y no la informaci\u00f3n en s\u00ed. El coste de inserci\u00f3n y eliminaci\u00f3n es menor. Con los registros siempre ordenados se utilizaran algoritmos mucho m\u00e1s eficientes que el simple recorr ido secuencial en las consultas. FUOC 71Z799014MO 56 Bases de datos en MySQL El uso de \u00edndices tambi\u00e9n co mporta alguna desventaja: Los \u00edndices ocupan espacio en disco. A\u00fan teniendo registros peque\u00f1os, el mantener en orden un \u00edndice dismi - nuye la velocidad de las operacio nes de escritura sobre la tabla. A pesar de estos inconvenientes, la ut ilizaci\u00f3n de \u00edndices ofrece mayores ven - tajas que desventajas, sobre todo en la consulta de m\u00faltiples tablas, y el au - mento de rendimiento es mayor cuanto mayor es la tabla. Consideremos por ejemplo un a consulta sobre las tablas A, B, y C, indepen - dientemente del conten ido de la cl\u00e1usula where, las tres tablas se deben de combinar para hacer posible posteriormen te el filtrado se g\u00fan las condiciones dadas: Consideremos que no son ta blas grandes, que no sobrepasan los 1.000 regis - tros. Si A tiene 500 registros, B tiene 600 y C 700, la tabla resultante de la con - sulta anterior tendr\u00e1 210 millones de registros. MySQL har\u00eda el producto cartesiano de las tres tabl as y, posteriormente, se re correr\u00eda la relaci\u00f3n resul - tante para buscar los registros que satisf acen las condiciones dadas, aunque al final el resultado incluya solamente 1.000 registros. Si utilizamos \u00edndices MySQL los utilizar\u00eda de una forma parecida a la siguiente: Tomar\u00eda cada uno de los registros de A. Por cada registro de A, buscar\u00eda los registros en B que cumpliesen con la con - dici\u00f3n A.a = B.b. Como B est\u00e1 indexado por el atributo 'b', no necesitar\u00eda ha - cer el recorrido de todos los registro s, simplemente acceder\u00eda directamente al registro que cumpliese la condici\u00f3n. Por cada registro de A y B encontrado en el paso anterior, buscar\u00eda los re - gistros de C que cumpliesen la condici\u00f3 n B.b = C.c. Es el mismo caso que en el paso anterior. Comparando las dos alternativas de b\u00fasqueda, la segunda ocupar\u00eda cerca del 0,000005% del tiempo original. Por supu esto que s\u00f3lo se trata de una aproxi - maci\u00f3n te\u00f3rica, pero adecuada para comp render el efecto de los \u00edndices en las consultas sobre bases de datos. select * from A,B,C where A.a = B.b and B.b = C.c; FUOC 71Z799014MO 57 Bases de datos en MySQL 5.5.2. Equilibrio El \u00edndice ideal deber\u00eda tener las siguientes caracter\u00edsticas: Los registros deber\u00edan ser lo m\u00e1s peque\u00f1os posible. S\u00f3lo se debe indexar valores \u00fanicos. Analicemos cada recomendaci\u00f3n: Cuanto m\u00e1s peque\u00f1os sean los registros, m\u00e1s r\u00e1pidamente se podr\u00e1n cam - biar de lugar (al insertar, modificar o borrar filas), adem\u00e1s, en un momento dado, el \u00edndice puede permanecer en memoria. Consideremos las dos defi - niciones posibles: En esta tabla el \u00edndi ce se realiza sobre nombre , que es un campo de 30 caracteres, y se utiliza como clave para hacer los ' joins' con otras tablas. Ahora consid\u00e9rese la siguiente alternativa: Se agrega una columna que servir\u00e1 como identifi cador de la empresa. Desde el punto de vista de rendimiento implica una mejora, ya que el \u00edn dice se realiza sobre n\u00fa meros enteros, por lo tanto, ocupar\u00e1 menos espacio y funcionar\u00e1 m\u00e1s r\u00e1pido. Consideremos el \u00edndice siguiente, creado para disminuir la necesidad de efectuar accesos a la tabla: create table Empresa( nombre char(30), tel\u00e9fono char(20), index table Empresa( id int , nombre char(30), tel\u00e9fono char(20), index (id) ); Cuanto m\u00e1s peque\u00f1a sea la columna indexada mayor velocidad se ten - dr\u00e1 en el acceso a la tabla. create table Empresa( nombre char(30), cr\u00e9dito enum{'SI','NO'}, index(cr\u00e9dito) ); FUOC 71Z799014MO 58 Bases de datos en MySQL Si consideramos que un \u00edndice se crea para evitar la necesidad de recorrer la tabla, veremos que el \u00edndice creado es pr\u00e1cticamente in\u00fatil, ya que algu - no de los valores ocurre el 50% o m\u00e1s de las veces: para encontrar todos los resultados hay que recorre r gran parte de la tabla. MySQL no utiliza los \u00edn - dices que implican un 30% de ocurrencias en una tabla. Aun as\u00ed, y exceptuando casos ex agerados como este \u00faltimo, puede ser interesante indexar una tabla por alg\u00fan atributo que no sea \u00fanico, si ese atributo se utiliza para ordenar los resul - tados. Tambi\u00e9n puede ser conveniente crear un \u00edndice por varios atributos simult\u00e1neamente si se usan todos en alguna consulta en la cl\u00e1usula ORDER BY. 5.5.3. La cache de consultas de MySQL El servidor MySQL incluye la posibilidad de utilizar una cache * con los resul - tados de las \u00faltimas consultas para acelerar la velocidad de respuesta. Esta so - luci\u00f3n es \u00fatil cuando las tablas ti enen relativamente pocos cambios y se realizan los mismos tipos de cons ultas. El funcio namiento de la cache se basa en las premisas siguientes: La primera vez que se recibe una consulta se almacena en la cache . Las siguientes veces la consul ta se realiza primero en la cache ; si tiene \u00e9xito, el resultado se env\u00eda inmediatamente. La cache tiene las siguientes caracter\u00edsticas: El servidor compara el texto de la co nsulta; aunque t\u00e9cn icamente sea igual si difiere en uso de may\u00fa sculas-min\u00fasculas o cualqu ier otro cambio, no se considera la solicitud id\u00e9ntica y no ser\u00e1 tratada por la cache . Si alguna tabla incluida en alguna co nsulta cambia, el contenido de la con - sulta es elim inado de la cache . La configuraci\u00f3n de la cache se realiza a trav\u00e9s de variables globales: query_cache_limit . No almacena resultados que sobrepasen dicho tama\u00f1o. Por omisi\u00f3n es de 1M. query_cache_size . Tama\u00f1o de la memoria cache expresada en bytes. Por omisi\u00f3n es 0; es de cir, no hay cache. query_cache_type . Puede tener tres valores: ON , OFF o DEMAND.Cuanto menor sea la repetici\u00f3n de valores en una columna indexada, me - nor ser\u00e1 la necesidad de acceder a la tabla y m\u00e1s eficiente ser\u00e1 el \u00edndice. * Memoria intermedia de acceso r\u00e1pido. FUOC 71Z799014MO 59 Bases de datos en MySQL Tipos de cache Cuando la cache del servidor esta en modo DE MAND, se debe solicitar expl\u00edci - tamente que la consulta utilice o no la cache : 5.6. Replicaci\u00f3n La replicaci\u00f3n es la copia sincronizada entre dos servidores de bases de datos de forma que cualquiera de los dos pued e entregar los mismos resultados a sus clientes. MySQL incluye la posibilidad de replicac i\u00f3n con las siguient es caracter\u00edsticas: Funciona con el esquema maestro-esclavo : existe un servidor maestro que lleva el control central y uno o varios servidores esclavos que se mantienen sincronizados con el servidor maestro. La r\u00e9plica se realiza mediante un regi stro de los cambios realizados en la base de datos: no se realizan las copias de las bases de datos para mantener - las sincronizadas, en su lugar se inform a de las operaciones realizadas en el servidor maestro (insert, delete , update ...) para que las realicen a su vez los servidores esclavos. No es posible realizar cambios en lo s servidores esclavos, son exclusiva - mente para consultas. Este sencillo esquema perm ite la creaci\u00f3n de rep licas sin mayores complica - ciones obteniendo los siguientes beneficios: Se distribuye la carga de trabajo. El sistema es redundante, por lo que en caso de desastre hay menos proba - bilidades de perder los datos. Es posible realizar los respaldos de un esclavo sin interrumpir el trabajo del servidor maestro.Valor Tipo Significado 0 OFF Cache desactivado 1 ON Cache activado 2 DEMAND S\u00f3lo bajo solicitud explicita select sql_cache select sql_no_cache FUOC 71Z799014MO 60 Bases de datos en MySQL 5.6.1. Preparaci\u00f3n previa El equipo maestro debe tener acceso por red. Antes de realizar la configuraci\u00f3n de los servidores maestro y esclavo es ne cesario realizar las siguientes tareas: Asegurarse de que en ambos est\u00e1 in stalada la misma versi\u00f3n de MySQL. Asegurarse de que ninguno de los servid ores atender\u00e1 peticiones durante el proceso de configuraci\u00f3n. Asegurarse de que las bases de datos del servidor maestro han sido copiadas manualmente en el servidor esclavo, de manera que en ambos se encuentre exactamente la misma informaci\u00f3n. Asegurarse de que ambos atienden co nexiones v\u00eda TCP/IP. Por seguridad, esta opci\u00f3n est\u00e1 desactivada por omisi\u00f3n. Para activarla se debe comentar la l\u00ednea skip_networking en el archivo de configuraci\u00f3n /etc/my.cnf 5.6.2. Configuraci\u00f3n del servidor maestro En el servidor maestro creamos una cuen ta de usuario con permisos de repli - caci\u00f3n para autorizar, en el servidor ma estro, al nuevo usuario para realizar r\u00e9 - plicas: Replicador es el nombre del nuevo usuario. Esclavo.empresa.com es la di recci\u00f3n del servidor esclavo. 'Secreto' es la contrase\u00f1a. El servidor maestro llevar\u00e1 un archivo de registro ' binlog ' donde se registrar\u00e1n todas las solicitudes de actu alizaci\u00f3n que se realicen en las bases de datos. Para activar la creaci\u00f3n de este archivo debemos editar el archivo /etc/my.cnf y agregar las siguientes l\u00ednea s en la secci\u00f3n [mysqld]:mysql> grant replication slave FUOC 71Z799014MO 61 Bases de datos en MySQL El servidor maestro debe identificarse co n un id, en este caso ser\u00e1 el n\u00famero 1. a continuaci\u00f3n, reiniciamos el servidor: Finalmente, consultamos el nombre del archivo ' binlog ' y la posici\u00f3n de com - pensaci\u00f3n (estos datos son necesarios para co nfigurar el esclavo): 5.6.3. Configuraci\u00f3n del servidor esclavo En el servidor esclavo, editamos el ar chivo /etc/my.cnf y agregamos, al igual que en el maestro, la activaci\u00f3n del archivo ' binlog ' y un identificador del ser - vidor (que debe ser distinto del id entificador del se rvidor maestro): Reiniciamos el servidor esclavo: Configuramos los dato s del maestro en el servidor esclavo:. El \u00faltimo paso es iniciar el servidor esclavo: Y ya tendremos el servid or esclavo funcionando. /etc/init.d/mysql restart mysql> show master status; +-----------------+----------+--------------+------------------+ | File | Binlog_do_db | Binlog_ignore_db | +-----------------+----------+--------------+------------------+ | maestro-bin.001 | 76 | server-id 71Z799014MO 62 Bases de datos en MySQL 5.7. Importaci\u00f3n y exportaci\u00f3n de datos En muchas ocasiones es necesario mover datos de una aplicaci\u00f3n a otra, para ello son necesarios format os est\u00e1ndares que puedan ser escritos por la aplica - ci\u00f3n origen y le\u00eddos por la aplicaci\u00f3n de stino. El m\u00e1s simple de esos formatos es el texto plano, donde cada archivo es un a tabla, cada fila es un registro y los valores de los campos se separan por tabuladores. MySQL puede leer este tipo de archiv os, incluyendo valo res nulos representa - dos por '\\N'(N may\u00fascula).s Utilizando el cliente mysql , podemos introducir los datos del archivo local proveedores.txt en la tabla proveedores : Si se omite la palabra local , MySQL buscar\u00e1 el archivo en el servidor y no en el cliente. En un archivo se pueden entrecomilla r los campos, utilizar comas para sepa - rarlos y terminar las l\u00edneas con los ca racteres '\\r\\n' (como en los archivos Windows). El comando load data tiene dos clausulas opcionales, fields, en el que se especifican estos par\u00e1metros. La opci\u00f3n enclosed by puede tener la forma optionaly enclosed by , en caso de que los campos num\u00e9ri cos no sean delimitados. Adem\u00e1s pueden omitirse la s primeras lineas del arch ivo si contienen informa - ci\u00f3n de encabezados:mysql> load data local infile 1 71Z799014MO 63 datos en MySQL 5.7.1. mysqlimport La utilidad mysqlimport que se incluye en la distribuci\u00f3n puede realizar el mismo trabajo que load data . Estos son algunos de sus par\u00e1metros: Estos son algunos de los argumentos de mysqlimport para realizar las tareas equivalentes a la sentencia load data : La forma m\u00e1s simple para exportar datos es redireccionando la salida del cliente mysql . El par\u00e1metro -e permite ejecutar un comando en modo de procesamiento por lotes. MySQL detecta si la salida es en pantalla o est\u00e1 redireccionada a un archivo y elige la presentaci\u00f3n adecuada: con encabezados y l\u00edneas de separa - ci\u00f3n para la salida en pantalla, y sin encabezados y con tabuladores para un archivo: La sentencia select tambi\u00e9n cuenta con una opci\u00f3n para realizar la tarea in - versa de la sentencia load data : 5.7.2. mysqldump La utilidad mysqldump realiza el volcado de base s de datos y puede utilizarse para transportar datos de una base a otra que tambi\u00e9n entienda SQL. Sin em - bargo, el archivo debe se r editado antes de utilizarse, ya que algunas opciones mysqlimport basededatos archivo.txt FUOC 71Z799014MO 64 Bases de datos en MySQL son exclusivas de MySQL. Por lo general, basta con eliminar el tipo de tabla que se especifica al final de un comando create table . El siguiente comando realiza el vaci ado completo de la base de datos demo : En algunos casos, los comandos insert son suficientes y no necesitamos las de - finiciones de las tablas. El siguiente comando realiza un vaciado de la tabla proveedores de la base de datos demo filtrando la salid a con el comando grep de UNIX que selecciona s\u00f3lo las l\u00edneas que contienen la palabr a INSERT. De este modo, el archivo pro- veedores-insert.txt contiene exclusivamente comandos insert :$ mysqldump demo > mysqldump demo proveedores | grep INSERT FUOC 71Z799014MO 65 Bases de datos en MySQL 6. Clientes gr\u00e1ficos Existen m\u00faltiples clientes de entorno gr\u00e1fico que perm iten la interacci\u00f3n con un servidor MySQL. Analizaremos brev emente los que distribuye la empresa MySQL AB ( mysqlcc, mysql-query-browser y mysql-administrator ) y que se pueden descargar del sitio ofical www.mysql.com. 6.1. mysqlcc Al ejecutarse por primera vez abrir\u00e1 el di\u00e1logo que permite realizar el registro de un nuevo servidor MySQL: En la ventana principal se pueden apreci ar los servidores registrados, que en este caso es solamente uno. Con el bot\u00f3n derecho del rat\u00f3n sobre \"C onexi\u00f3n de Demostraci\u00f3n\", se puede activar la conexi\u00f3n. Despu\u00e9s de eso, mysqlcc muestra las propiedades de los elementos de la base de datos.Nota Actualmente, mysqlcc se ha dado por obsoleto en favor de los otros dos. FUOC 71Z799014MO 66 Bases de datos en MySQL Ahora ya estamos en disposici\u00f3n de realizar consultas SQL con Ctrl-Q (o haciendo click sobre el icono 'SQL'). Se abrir\u00e1 un a nueva ventana en la que podremos escri - bir la consulta que, una vez escrita, se ej ecutar\u00e1 al teclear Ctrl-E. Los resultados se mostrar\u00e1n en forma de tabla como en la captura de pantalla anterior. mysqlcc ofrece m\u00faltiples opciones para re alizar inserciones, eliminaciones, configurar teclas de acceso r\u00e1pido y una serie de caracter\u00edsticas de uso muy in - tuitivo. Tambi\u00e9n ofrece prestaciones pa ra exportar el resultado de una consul - ta a un fichero de texto. 6.2. mysql-query-browser Tanto mysql-query-browser como mysql-administrator comparten la informa - ci\u00f3n relativa a las conexiones almacena das. La pantalla in icial nos permitir\u00e1 seleccionar una existente o configurar una nueva: FUOC 71Z799014MO 67 Bases de datos en MySQL El aspecto de este programa es mejor que el de mysqlcc y ofrece prestaciones de ayuda en la generaci\u00f3n de consultas, favoritos, marcadores, accesos r\u00e1pidos a EXPLAIN , etc. Asimismo, ofrece varios fo rmatos de exportaci\u00f3n de los resultados de una con - sulta y m\u00e1s facilidades a la hora de navegar por los resultados. 6.3. mysql-administrator Esta novedosa herramienta es extremad amente potente y completa en cuanto a tareas de administraci\u00f3n se refiere. FUOC 71Z799014MO 68 Bases de datos en MySQL mysql-administrator permite, entre otras cosas: Encender y parar el SGBD. Gestionar el fichero de configuraci\u00f3n /etc/my.cnf de forma gr\u00e1fica. Gestionar usuarios y privilegios. Monitorizar el uso del gestor que se es t\u00e1 haciendo del mismo, el n\u00famero de conexiones, consultas simult\u00e1neas y todo tipo de informaci\u00f3n estad\u00edstica. Consultar los ficheros de registro ( log) del servidor. Gestionar copias de seguridad. Gestionar la replicaci\u00f3n de bases de datos. Crear y borrar bases de datos (SCHEMA). FUOC 71Z799014MO 69 Bases de datos en MySQL FUOC 71Z799014MO 70 Bases de datos en MySQL Resumen MySQL es un SGBD relacional de f\u00e1cil us o y alto rendimiento, dos caracter\u00edsticas muy valiosas para un desarrollador de si stemas: su facilidad de uso permite la creaci\u00f3n de bases de datos con rapidez y sin muchas complicaciones, y su alto rendimiento lo hace sumamente atractiv o para aplicaciones comerciales impor - tantes o portales web de mucho tr\u00e1fico. Si a ello le a\u00f1adimos la disponibilidad de c\u00f3digo y su licencia dual, se comp rende que MySQL sea atractivo y accesible para todo el mundo. Estos atributos tienen sus costes: mant enerlo con un alto rendimiento hace algo m\u00e1s lento su desarrollo, por lo que no es el m\u00e1s avanzado en cuanto a prestaciones y compatibilidad con est\u00e1ndares. MySQL ca rece de caracter\u00edsticas que muchos otros SGBD poseen. Pero no se debe olvidar que est\u00e1 en continuo desarrollo, por lo qu e futuras versiones incluir\u00e1n nuevas caracter\u00edsticas. Por supuesto, para MySQL es m\u00e1 s importante la eficiencia que incluir prestaciones s\u00f3lo por competir o satisfacer a algunos usuarios. FUOC 71Z799014MO 71 Bases de datos en MySQL Bibliograf\u00eda DuBois, P. (2003). MySQL Second Edition: The definitive guide programming, and administering MySQL 4 databases Indianapolis: Developer's Library. http://dev.mysql.com/doc/). Silberschatz, A.; Korth, H.; Sudarshan, de Datos (4.\u00aa ed.). Madrid: McGraw Hill. Bases de datos en PostgreSQL Marc Gibert Ginest\u00e0 Oscar P\u00e9rez Mora FUOC 71Z799014MO Bases de datos en PostgreSQL \u00cdndice Introducci\u00f3n .............................................................................................. 5 Objetivos ..................................................................................................... 6 1. Caracter\u00edsticas de PostgreSQL .......................................................... 7 1.1. Breve historia .................................................................................... 7 1.2. Prestaciones ...................................................................................... 7 1.3. Limitaciones ..................................................................................... 8 2. Introducci\u00f3n a la orientaci\u00f3n a objetos ....................................... 9 2.1. El modelo orientado a objetos .......................................................... 92.2. Objetos: clase frente a instancia ....................................................... 102.3. Propiedades: atributo frente a operaci\u00f3n ......................................... 11 2.4. Encapsulamiento: implementaci\u00f3n frente a interfaz ....................... 11 2.4.1. Atributo frente a variable de instancia ................................... 13 2.5. Herencia: jerarqu\u00eda de clases ............................................................ 14 2.5.1. Tipo y clase ............................................................................. 17 2.6. Agregaci\u00f3n: jerarqu\u00eda de objetos ...................................................... 172.7. Persistencia ....................................................................................... 18 2.8. PostgreSQL y la orientaci\u00f3n a objetos .............................................. 18 3. Acceso a un servidor PostgreSQL .................................................... 20 3.1. La conexi\u00f3n con el servidor ............................................................. 20 3.2. El cliente psql .................................................................................... 203.3. Introducci\u00f3n de sentencias .............................................................. 21 3.3.1. Expresiones y variables .......................................................... 22 3.4. Proceso por lotes y formatos de salida ............................................. 233.5. Usar bases de datos ........................................................................... 27 4. Creaci\u00f3n y manipulaci\u00f3n de tablas ................................................ 29 4.1. Creaci\u00f3n de tablas ............................................................................ 294.2. Herencia ............................................................................................ 32 4.3. Herencia y OID ................................................................................. 34 4.4. Restricciones ..................................................................................... 37 4.4.1. Restricciones de tabla ............................................................. 40 4.5. Indexaci\u00f3n ........................................................................................ 424.6. Consulta de informaci\u00f3n de bases de datos y tablas ........................ 424.7. Tipos de datos ................................................................................... 44 en PostgreSQL Tipos de caracteres ................................................................. 46 4.7.5. Operadores Arrays ...................................................................................... 484.7.8. BLOB ....................................................................................... 50 4.8. Modificaci\u00f3n de la estructura de una tabla ...................................... 53 5. Manipulaci\u00f3n de datos ...................................................................... 54 5.1. Consultas .......................................................................................... 545.2. Actualizaciones e inserciones ........................................................... 555.3. Transacciones .................................................................................... 56 6. Funciones y disparadores .................................................................. 57 6.1. Primer programa ............................................................................... 576.2. Variables ........................................................................................... 586.3. Sentencias ......................................................................................... 586.4. Disparadores ..................................................................................... 7. Administraci\u00f3n de PostgreSQL ........................................................ 63 7.1. Instalaci\u00f3n ........................................................................................ 63 7.1.1. Internacionalizaci\u00f3n .............................................................. 64 7.2. Arquitectura de PostgreSQL .............................................................. 657.3. El administrador de postgres ............................................................ 66 7.3.1. Privilegios ............................................................................... 67 7.4. Creaci\u00f3n de tipos de datos ............................................................... 68 7.5. Plantilla de creaci\u00f3n de bases de da tos ......... .......... .......... .......... ...... 70 7.6. Copias de seguridad .......................................................................... 717.7. Mantenimiento rutinario de la base de vacuum .................................................................................... gr\u00e1fico: pgAdmin3 74 Resumen ...................................................................................................... 76 Bibliograf\u00eda ................................................................................................ 77 FUOC 71Z799014MO 5 Bases de datos en PostgreSQL Introducci\u00f3n PostgreSQL es un gestor de bases de datos orientadas a objetos (SGBDOO o ORDBMS en sus siglas en ingl\u00e9s) muy co nocido y usado en entornos de software libre porque cumple los est\u00e1ndares SQL92 y SQL99, y tambi\u00e9n por el conjuntode funcionalidades avanzadas que soporta, lo que lo sit\u00faa al mismo o a un mejor nivel que muchos SGBD comerciales. El origen de PostgreSQL se sit\u00faa en el gestor de bases de datos POSTGRES desarro- llado en la Universidad de Berkeley y qu e se abandon\u00f3 en favor de PostgreSQL a partir de 1994. Ya entonces, contaba con prestaciones que lo hac\u00edan \u00fanico en el mercado y que otros gestores de bases de datos comerciales han ido a\u00f1adiendo durante este tiempo. PostgreSQL se distribuye bajo licencia BSD, lo que perm ite su uso, redistribuci\u00f3n, modificaci\u00f3n con la \u00fanica restricci\u00f3n de mantener el copyright del software a sus autores, en concreto el PostgreSQL Gl obal Development Group y la Universidad de California. PostgreSQL puede funcionar en m\u00faltiples plataformas (en general, en todas las modernas basadas en Unix) y, a partir de la pr\u00f3xima vers i\u00f3n 8.0 (actualmente en su segunda beta), tamb i\u00e9n en Windows de forma na tiva. Para las versiones anteriores existen versiones binarias para este sistema operativo, pero no tie- nen respaldo oficial. Para el seguimiento de los ejemplos y la realizaci\u00f3n de las actividades, es im- prescindible disponer de los datos de acceso del usuario administrador del ges- tor de bases de datos. Aunque en algu nos de ellos los privilegios necesarios ser\u00e1n menores, para los cap\u00edtulos que tratan la administraci\u00f3n del SGBDOO ser\u00e1 imprescindible disponer de las credenciales de administrador. Las sentencias o comandos escritos por el usuario estar\u00e1n en fuente monoes- paciada, y las palabras que tienen un si gnificado especial en PostgreSQL esta- r\u00e1n en negrita . Es importante hacer notar qu e estas \u00faltimas no siempre son palabras reservadas, sino comandos o sent encias de psql (el cliente interactivo de PostgreSQL). La versi\u00f3n de PostgreSQL que se ha ut ilizado durante la reda cci\u00f3n de este ma- terial, y en los ejemplos, es la 7.4, la \u00faltima versi\u00f3n estable en ese momento, aunque no habr\u00e1 ning\u00fan problema en ejecutarlos en versiones anteriores, hasta la 7.0. FUOC 71Z799014MO 6 Bases de datos en PostgreSQL Objetivos El objetivo principal de esta unidad es conocer el gestor de bases de datos relacio- nales con soporte para objetos PostgreSQL , y comentar tanto sus caracter\u00edsticas comunes a otros gestores de bases de dato s, como las que lo distinguen de sus competidores de c\u00f3digo abierto. Adem\u00e1s, se ofrece la oportunidad de aplicar los conocimi entos aprendidos en el m\u00f3dulo referido a SQL sobre un sistem a gestor de base de datos real y exa- minar las diferencias entre el est\u00e1ndar y la implementaci\u00f3n que hace de \u00e9l el SGBD. Por \u00faltimo, se presentan las tareas de administraci\u00f3n del SGBD m\u00e1s habituales que un usuario debe llevar a cabo como administrador de Post-greSQL. FUOC 71Z799014MO 7 Bases de datos en PostgreSQL 1. Caracter\u00edsticas de PostgreSQL En este apartado comentaremos las caracter\u00edsticas m\u00e1s relevantes de este SGBD con soporte para objetos, tanto sus pres taciones m\u00e1s interesantes o destacadas, como las limitaciones en su dise\u00f1o o en implementaci\u00f3n de los est\u00e1ndares SQL. Tambi\u00e9n es interesante conocer un poco su historia, ya que tanto por las personas que han participado en su desarrollo como por su relaci\u00f3n con otros gestores de bases de datos, nos ayudar\u00e1 a tener una mejor visi\u00f3n de la evoluci\u00f3n del mismo. 1.1. Breve historia La historia de PostgreSQL se inicia en 1986 con un proyecto del profesor Michael Stonebraker y un equipo de de sarrolladores de la Universidad Berkeley (California), cuyo nombre original era PO STGRES. En su dise\u00f1o se incluyeron al- gunos conceptos avanzados en bases de da tos y soporte parcial a la orientaci\u00f3n a objetos. POSTGRES fue comercializ ado por Illustra, una empresa que posteriormente form\u00f3 parte de Informix (que comercializaba el co nocido SGBD del mismo nombre, recientemente absorbida por IB M y su DB/2). Lleg\u00f3 un momento en que mantener el proyecto absorb\u00eda de masiado tiempo a los investigadores y acad\u00e9micos, por lo que en 1993 se liber\u00f3 la versi\u00f3n 4.5 y oficialmente se dio por terminado el proyecto. En 1994, Andrew Yu y Jolly Chen incluy eron SQL en Postgres para posterior- mente liberar su c\u00f3digo en la web con el nombre de Postgres95. El proyecto inclu\u00eda m\u00faltiples cambios al c\u00f3digo or iginal que mejoraban su rendimiento y legibilidad. En 1996 el nombre cambi\u00f3 a PostgreSQL retomando la secuencia original de versiones, por lo que se liber\u00f3 la versi\u00f3 n 6.0. En el a\u00f1o 2004 la \u00faltima versi\u00f3n estable oficial es la 7.4.6, mientras que la versi\u00f3n 8.0 est\u00e1 ya en fase final de estabilizaci\u00f3n. 1.2. Prestaciones PostgreSQL destaca por su ampl\u00edsima lista de prestaciones que lo hacen capaz de competir con cualquier SGBD comercial: Est\u00e1 desarrollado en C, con herramientas como Yacc y Lex.Los desarrolladores de proyectos basados en software libre tienen muy en cuenta PostgreSQL cuando los requerimientos de un proyecto exigen prestaciones de alto nivel. FUOC 71Z799014MO 8 Bases de datos en PostgreSQL La API de acceso al SGBD se encuentra disponible en C, C++, Java, Perl, PHP, Python y TCL, entre otros. Cuenta con un rico conjunto de tipos de datos, permitiendo adem\u00e1s su ex- tensi\u00f3n mediante tipos y operadores de finidos y programados por el usuario. Su administraci\u00f3n se basa en usuarios y privilegios. Sus opciones de conectividad abarcan TCP/IP, sockets Unix y sockets NT, adem\u00e1s de soportar completamente ODBC. Los mensajes de error pueden estar en espa\u00f1ol y hacer ordenaciones correc- tas con palabras acentuadas o con la letra '\u00f1'. Es altamente confiable en cuan to a estabilidad se refiere. Puede extenderse con librer\u00edas extern as para soportar encriptaci\u00f3n, b\u00fas- quedas por similitud fo n\u00e9tica (soundex), etc. Control de concurrencia multi-versi\u00f3 n, lo que mejora sensiblemente las operaciones de bloqueo y transacci ones en sistemas multi-usuario. Soporte para vistas, claves for\u00e1neas, integridad referencial, disparadores, procedimientos almacenados, subconsu ltas y casi todos los tipos y opera- dores soportados en SQL92 y SQL99. Implementaci\u00f3n de algunas extensiones de orientaci\u00f3n a objetos. En Post- greSQL es posible definir un nuevo tipo de tabla a partir de otra previamen- te definida. 1.3. Limitaciones Las limitaciones de este tipo de gestores de bases de datos suelen identificarse muy f\u00e1cilmente analizando las prestaciones qu e tienen previstas para las pr\u00f3ximas ver- siones. Encontramo s lo siguiente: Puntos de recuperaci\u00f3n dentro de transacciones. Actualmente, las transac- ciones abortan completamente si se encuentra un fallo durante su ejecu- ci\u00f3n. La definici\u00f3n de puntos de re cuperaci\u00f3n permitir \u00e1 recuperar mejor transacciones complejas. N o s o p o r t a tablespaces para definir d\u00f3nde almacenar la base de datos, el es- quema, los \u00edndices, etc. El soporte a orientaci\u00f3n a objetos es una simple extensi\u00f3n que ofrece pres- taciones como la herencia , no un soporte completo. FUOC 71Z799014MO 9 Bases de datos en PostgreSQL 2. Introducci\u00f3n a la orientaci\u00f3n a objetos Dado que PostgreSQL incluye extensio nes de orientaci\u00f3n a objetos (aunque no es, como ya hemos comentado, un SGBDOO completo), es interesante re- pasar algunos de los conceptos relacionados con este paradigma de programa-ci\u00f3n y estructuraci\u00f3n de datos. 2.1. El modelo orientado a objetos En 1967, el lenguaje de programaci\u00f3n Simula aplicaba algunas ideas para mo- delar aspectos de la rea lidad de forma mucho m\u00e1s directa que los m\u00e9todos tra- dicionales. Desde entonces, la orientac i\u00f3n a objetos (OO) ha adquirido cada vez mayor popularidad al demostrar sus ventajas, entre las cuales: Permite un modelado m\u00e1s \"natural\" de la realidad. Facilita la reutilizaci\u00f3n de componentes de software. Ofrece mecanismos de abstracci\u00f3n para mantener controla ble la construc- ci\u00f3n de sistemas complejos. En el mercado aparecen constantemente herramientas y lenguajes de progra- maci\u00f3n autodenominados orientados a objetos y los ya existentes evolucio-nan r\u00e1pidamente incluyendo nuevas ca racter\u00edsticas de OO. De la misma manera, se han desarrollado m\u00faltiples m\u00e9todos y metodolog\u00edas bajo este en- foque, cada una con aportaciones propia s que llegan, en ocasiones, a resultar contradictorias entre s\u00ed. Se ha logrado la creaci\u00f3n de un lenguaje unificado para el modelado, llama do precisamente UML ( unified modeling language ). La intenci\u00f3n de UML independiente de cualquie r metodolog\u00eda y es preci- samente esta independencia la que lo hace importante pa ra la comunicaci\u00f3n entre desarrolladores, ya que las metodolog\u00edas son muchas y est\u00e1n en constan-te evoluci\u00f3n. Lamentablemente, a pesar de los muchos esfuerzos y de importantes avances, las ciencias de la computaci\u00f3n no han creado a\u00fan una definici\u00f3n de modelo de objetos como tal. En un panorama como \u00e9ste, es indispensable, al menos, la existencia de un modelo informal de objetos que oriente la evoluci\u00f3n de la tec- nolog\u00eda y que tenga la aprobaci\u00f3n de lo s expertos en la materia. Un modelo as\u00ed permitir\u00eda su estudio consistente por parte de lo s profesionales de las tec- nolog\u00edas de la informaci\u00f3n, facilitar\u00eda la creaci\u00f3n de mejores lenguajes y he- rramientas y, lo que es m\u00e1s importante, definir\u00eda los est\u00e1ndares para una metodolog\u00eda de desarrollo consistente y aplicable. FUOC 71Z799014MO 10 Bases de datos en PostgreSQL Sin embargo, este modelo no existe, lo que provoca inconsistencias incluso en el tratamiento de los principios y concep tos b\u00e1sicos de la OO. Por eso, es fre- cuente encontrar errores graves en el desarrollo de sistem as OO y, lo que es a\u00fan peor, se implementan soluciones de dudosa validez en herramientas de desarrollo que se dicen orientadas a objetos. Aun sin haber alcanzado la madurez, la orientaci\u00f3n a objeto s es el paradigma que mejor permite solucion ar los muchos y variados problemas que existen en el desarrollo de software. En los pr\u00f3x imos apartados analizaremos los concep- tos b\u00e1sicos de este modelo para identi ficar algunos de los problemas que a\u00fan debe resolver, lo que fac ilitar\u00e1 la comprensi\u00f3n y eval uaci\u00f3n de m\u00e9todos y he- rramientas OO. 2.2. Objetos: clase frente a instancia Los objetos son abstracciones que realizamos del mundo que nos rodea y que identificamos por sus pr opiedades. Para la OO todo es un objeto. Cada objeto tiene una existencia un tanto independiente de los dem\u00e1s obje- tos; es decir, tiene identidad propia. Aunque dos objetos tengan exactamente los mismos valores, no por eso ser\u00e1n el mismo objeto, seguir\u00e1n siendo entida-des diferentes. En los modelos OO, la id entidad se representa con el identifi- cador de objeto, IDO (OID en ingl\u00e9s, de object identifier ). Te\u00f3ricamente, el IDO de un objeto es \u00fanico e irrepetible en el tiempo y el espacio. Los IDO son el mecanismo que permite hacer referencia a un objeto desde otro. De esta manera la s referencias tejen las re laciones entre objetos. Todos los objetos que comparten las mismas propiedades se dice que pertene- cen a la misma clase . En los modelos OO, las clases le roban el papel central a los objetos, ya que es a tr av\u00e9s de ellas como se defi nen las propiedades de \u00e9stos y adem\u00e1s se utilizan como pl antillas para crear objetos. Al crear un objeto utilizando la definici \u00f3n dada por una clase, obtenemos un va- lor para \u00e9l, es lo que se llama una instancia del objeto. Durante la ejecuci\u00f3n de los programas se trabaja co n instancias. Como concepto, la instancia es equiva- lente a una tupla (fila) concreta en una tabla de una base de datos. Elementos fundamentales en OOFunci\u00f3n del IDO El IDO permite que dos objetos id\u00e9nticos puedan diferenciarse, no es importante que el usua-rio conozca los IDO, lo impor-tante es que los diferencie el sistema. objeto clase FUOC 71Z799014MO 11 Bases de datos en PostgreSQL 2.3. Propiedades: atribu to frente a operaci\u00f3n Las propiedades de los objetos pueden ser de dos tipos, din\u00e1micas y est\u00e1ticas. Un atributo representa una propiedad est\u00e1ti ca de un objeto (color, coste, edad, etc.). Una operaci\u00f3n representa una propiedad din\u00e1mica; es decir, una transformaci\u00f3n sobre un atributo o una acci\u00f3n que puede realizar. El conjunto de valores de los atributos en un momento dado se conoce como estado del objeto. Los operadores act\u00faan so bre el objeto camb iando su estado. La secuencia de estados por la que pasa un objeto al ejecutar operaciones de- finen su comportamiento . La posibilidad de definir comportamiento s complejos es lo que hace diferente la OO. 2.4. Encapsulamiento: implementaci\u00f3n frente a interfaz La estructura interna de los objetos debe estar oculta al usuario de un objeto, no necesita conocerla para interactua r con \u00e9l. Los objetos se conciben como una c\u00e1psula cuyo interior est\u00e1 oculto y no puede ser alterado directamente desde el exterior. A la estructura interna de un objeto se la denomina implementaci\u00f3n y a la parte visible, la que se presenta al exterior, interfaz . La interfaz se define por sus atributos y operaciones. La implementaci\u00f3n de una operaci\u00f3n se conoce como m\u00e9todo . La implemen- taci\u00f3n de un atributo se realiza generalmente con variables de instancia .Propiedades de los objetos Encapsulamientoobjeto (instancia) clase atributos (estado) atributos operaciones (comportamiento) operaciones Los tipos de datos abstractos Los tipos de datos abstractos (TDA) obedecen al mismo principio de independencia de la implementaci\u00f3n. La dife- rencia respecto a los objetos es que \u00e9stos incluyen los datos y las operaciones en la misma c\u00e1psula. Clase implementaci\u00f3n interfaz variables atributos m\u00e9todos operaciones FUOC 71Z799014MO 12 Bases de datos en PostgreSQL El encapsulamiento comporta las siguientes ventajas: La modificaci\u00f3n interna (de la implem entaci\u00f3n) de un objeto para corre- girlo o mejorarlo no afecta a sus usuarios. La dificultad inherente a la modificaci \u00f3n de la implementaci\u00f3n de un ob- jeto sea independiente del tama\u00f1o tota l del sistema. Esto permite que los sistemas evolucionen con mayor facilidad. La simplificaci\u00f3n en el uso del objeto al ocultar los detalle s de su funciona- miento y presentarlo en t\u00e9rminos de sus propiedades. Al elevar el nivel de abstracci\u00f3n se disminuye el nivel de co mplejidad de un sistema. Es posible modelar sistemas de mayor tama\u00f1o con menor esfuerzo. Constituye un mecanismo de integridad. La dispersi\u00f3n de un fallo a trav\u00e9s de todo el sistema es menor, puesto que al presentar una divisi\u00f3n entre in- terfaz e implementaci\u00f3n, los fallos inte rnos de un objeto encuentran una barrera en el encapsulamiento antes de propagarse al resto del sistema. Permite la sustituci\u00f3n de objetos con la misma interfaz y diferente imple- mentaci\u00f3n. Esto permit e modelar sistemas de mayor tama\u00f1o con menor esfuerzo. Parad\u00f3jicamente, el encapsulamiento, a pesar de ser uno de los conceptos b\u00e1- sicos en la OO, no siempre se interpre ta y se aplica correctamente. Especial- mente en lo referente a en capsulamiento de atributos. Diferenciemos operaci\u00f3n y m\u00e9to do a trav\u00e9s de un ejemplo. Consideremos tres objetos: pol\u00edgono, c\u00edrculo y punto. A los tres se les solicita la operaci\u00f3n de imprimir. En esta situaci\u00f3n, tenemos que: La operaci\u00f3n solicitada es la misma, porqu e el significado del resultado es el mismo. Cada objeto ejecuta la operaci\u00f3n de forma di ferente; es decir, con un m\u00e9todo diferente. Cada objeto, internamente, puede tener m\u00e1s de un m\u00e9todo y selecciona el m\u00e1s apro- piado seg\u00fan las circunstancias.Estas caracter\u00edsticas de l encapsulamiento han contribuido en gran me- dida a la buena reputaci\u00f3n de la OO. Las operaciones no son exclusivas de los tipos de objeto, los m\u00e9todos s\u00ed. Una operaci\u00f3n especifica \"qu\u00e9\" hacer y un m\u00e9todo \"c\u00f3mo\" hacer-lo. Esta diferencia permite tener m\u00faltiples m\u00e9todos para una misma operaci\u00f3n. FUOC 71Z799014MO 13 Bases de datos en PostgreSQL Veamos ahora la diferencia entre atribu tos y variables de instancia, que puede parecer m\u00e1s sutil. Un atributo es la vista externa de una propiedad est\u00e1tica de un objeto. La re- presentaci\u00f3n interna puede variar, lo s atributos pueden implementarse tam- bi\u00e9n con m\u00e9todos. Tomemos como ejempl o el objeto punto con los atributos que se muestran a continuaci\u00f3n: Los atributos de un punto pueden defi nirse en coordenadas angulares o rec- tangulares; en este caso, es posible conocer ambas representaciones. En la implementaci\u00f3n de estos atributos, do s pueden ser variables de instancia y los otros dos se implementan como m\u00e9todos, que se calculan a trav\u00e9s de los primeros. Desde el exterior no debe ser posible conocer la representaci\u00f3n elegida inter- namente. Puede cambiarse la implementaci\u00f3n de los atributos sin alterar la in-terfaz. En algunos casos puede incluso pe rmitirse al sistema la elecci\u00f3n de la representaci\u00f3n interna de un atributo del mismo modo que una operaci\u00f3n elige entre varios m\u00e9todos disponibles. 2.4.1. Atributo frente a variable de instancia Un atributo especifica una cualidad de un objeto; una variable de instancia es- pecifica c\u00f3mo se almacenan lo s valores para esa cualidad. Consideremos tres objetos, nombre, foto, v\u00edde o, de los que necesitamos conocer el tama- \u00f1o y prever, as\u00ed, el espacio nece sario para almacenarlos en disco. En esta situaci\u00f3n tenemos que: El atributo es el mism o, porque su lectura tien e el mismo significado. Cada objeto implementa el atributo de ma nera diferente. Sin importar la implementa- ci\u00f3n, externamente todos los atributos entr egan el mismo tipo de valor. Por ejemplo: - El nombre puede utilizar un byte como vari able de instancia, porque el tama\u00f1o de un nombre no puede ser mayor que 255 caract eres, o se puede implementar un m\u00e9todo que calcule el tama\u00f1o en tiempo de ejecuci\u00f3n. - La foto utilizar\u00e1 dos o cuatro bytes. - El v\u00eddeo puede almacenar el valor de tama\u00f1o en m\u00faltiplos de K. Cada objeto puede tener implementaciones alternativas que se adapten a las circuns- tancias.Punto + x: \u00e1ngulo: float Los atributos Un atributo puede ser almace- nado en una variable o calcula-do por un m\u00e9todo. FUOC 71Z799014MO 14 Bases de datos en PostgreSQL Lamentablemente, los leng uajes de programaci\u00f3n co m\u00fanmente utilizados no implementan mecanismos adecuados para el encapsulamiento de los atribu- tos, llegando, incluso, a pe rmitir el acceso p\u00fablico a variables de instancia. A continuaci\u00f3n, analizaremos las grav es consecuencias de este hecho. Acceder a un atributo es, en realidad, una operaci\u00f3n que puede ser de lectura o de escritura. Por este motivo, frecuentemente se define el encapsulamiento como laocultaci\u00f3n de todas las variables permitiend o el acceso del exte rior s\u00f3lo para ope- raciones. Cuando el lenguaje de programa ci\u00f3n no ofrece independencia de la im- plementaci\u00f3n en los atributos, se deben definir una variable de instancia y dos m\u00e9todos por cada atributo: LeerAtributo y EscribirAtributo . Las bases de datos relacionales tienen perfectamente diferenciada la interfaz de la implementaci\u00f3n en sus tipos de datos: la forma de almacenarlos es com- pletamente independiente de la forma de consultarlos o guardarlos. No seconciben las operaciones co mo internas a los objetos. El encapsulamiento ha sido consider ado como un principio central de la orientaci\u00f3n a objetos y aten tar contra \u00e9l significa pa ra muchos romper con sus reglas fundamentales. Sin embargo, las bases de datos orientadas a objetos tie-nen entre sus funciones la realizaci\u00f3n de consultas, que necesita acceder a los atributos de los objetos. Dado que los objetos se implementan con variables,al accederlos se rompe el encapsulamiento. La mayor\u00eda de los lenguaje s orientados a objetos permiten romper el encapsu- lamiento de forma pa rcial, declarando variables como p\u00fablicas. El encapsula- miento, en estos casos, se proporciona como un mecanismo opcional, ya que el usuario puede declarar todas las variab les p\u00fablicas y, por lo tanto, accesibles directamente. Otros lenguajes implementan operacione s de lectura/escr itura que permiten acceder a las variables sin romper el encapsulamiento. 2.5. Herencia: jerarqu\u00eda de clases La herencia se define como el mecanismo mediante el cual se utiliza la defini- ci\u00f3n de una clase llamada \"padre\", para definir una nueva clase llamada \"hija\"que puede heredar sus atributos y operaciones. Implementaci\u00f3n del encapsulamiento Clase implementaci\u00f3n interfaz variables operaciones de lectura/escritura m\u00e9todos operaciones FUOC 71Z799014MO 15 Bases de datos en PostgreSQL A las clases \"hijo\" tamb i\u00e9n se les conoce como subclases , y a las clases \"padre\" como superclases . La relaci\u00f3n de herencia entre clases genera lo que se llama jerarqu\u00eda de clases . Hablamos de herencia de tipo cuando la subclase hereda la interfaz de una su- perclase; es decir, los atributos y las operaciones. Hablamos de herencia estruc-tural cuando la subc lase hereda la implementaci\u00f3n de la superclase; es decir, las variables de instancia y los m\u00e9todos. La herencia de tipo define relaciones es-un entre clases, donde la clase \"hijo\" tiene todas las propiedades del \"padre\", pero el \"padre\" no tiene todas las pro- piedades del \"hijo\". Consideremos una referencia mascota que es de tipo animal, en alg\u00fan lengua- je de programaci\u00f3n. mimascota: Animal; Puede hacer referencia a objetos de ti po animal, o tipos derivados de \u00e9ste, como perro, gato o canario, por ejemplo. mimascota = new Canario; Se construye un nuevo canario y se hace referencia a \u00e9l como mascota. La propiedad de sustituir objetos que descienden del mismo padre se conoce como polimorfismo, y es un mecanism o muy importante de reutilizaci\u00f3n en la OO. La referencia al tipo animal es una re ferencia polimorfa, ya que puede referirse a tipos derivados de animal. A trav\u00e9s de una referencia polimorfa se pueden solicitar operaciones sin conocer el tipo exacto. mimascota.comer(); La operaci\u00f3n comer tiene el mismo sign ificado para todos los animales. Como ya hemos comentado, cada uno utilizar\u00e1 un m\u00e9todo distinto para ejecutar la operaci\u00f3n. Para conocer el tipo exacto del objeto en cuesti\u00f3n, se utiliza el operador de in- formaci\u00f3n de tipo . De este modo puede acceders e a las propiedades espec\u00edfi- cas de un tipo de objeto qu e no est\u00e1n en los dem\u00e1s tipos. En este ejemplo llamamos al operador informaci\u00f3n de tipo, instancia-de. if (mimascota instancia-de Canario) mimascota.cantar(); Si la mascota es una instancia del tipo Canario entonces se le solicitar\u00e1 cantar, que es una propiedad que no tienen todas las mascotas.La herencia de tipo En la herencia de tipo lo que hereda la subclase son los atri-butos de la superclase, pero no necesariamente su implemen-taci\u00f3n, puesto que puede vol-ver a implementarlos. Ejemplo Un gato es-un animal. Todas las propiedades de la clase \"animal\" las tiene la clase \"ga-to\". Pero un animal no-es ne-cesariamente un gato. Todas las propiedades de gato no las tienen todos los animales. FUOC 71Z799014MO 16 Bases de datos en PostgreSQL Una clase puede heredar las propiedades de dos superclases mediante lo que se conoce como herencia m\u00faltiple . En una herencia m\u00faltiple, puede ocurrir que en amba s superclases existan pro- piedades con los mismos nombre s, situaci\u00f3n que se denomina colisi\u00f3n de nombres. A continuaci\u00f3n, se relacionan los posibles casos de colisi\u00f3n de nom- bres en la herencia de tipo: Los nombres son iguales porque se re fieren a la misma propiedad (ya he- mos visto ejemplos de ello: la operaci\u00f3 n imprimir y el atributo tama\u00f1o). En este caso no hay conflicto porque el significado est\u00e1 claro: es la misma pro- piedad, s\u00f3lo hay que definir una implementaci\u00f3n adecuada. Los nombres son iguales pero tienen significados diferentes. Esta situaci\u00f3n es posible porque el modelado es una tarea subjetiva y se soluciona cam- biando los nombres de las propiedades heredadas que tengan conflicto. La herencia m\u00faltiple no comporta prob lemas para la herenc ia de tipo, puesto que no pretende la reutiliz aci\u00f3n de c\u00f3digo, sino el control conceptual de la complejidad de los sistemas medi ante esquemas de clasificaci\u00f3n. Por lo que respecta a la he rencia estructural, que, re cordemos, consiste en que la subclase hereda las variables de inst ancia y los m\u00e9todos de la superclase -es decir, la implementaci \u00f3n-, la cosa cambia. Para entender mejor la herencia estructura l, diremos informalmente que representa una relaci\u00f3n funciona-como . Por ejemplo, se puede utilizar para definir un avi\u00f3n tomando como superclase ave, de esta manera la capacidad de volar del ave queda implementada en el avi\u00f3n. Un avi\u00f3n no es-un ave, pero podemos decir que funciona-como ave. Al aplicar la herencia de esta manera se dificulta la utilizaci\u00f3n del polimorfis- mo: aunque un objeto funcione internam ente como otro, no se garantiza que externamente pueda tomar su lugar porque funciona-como . El objetivo de la herencia estructural es la reutilizaci\u00f3n de c\u00f3digo, aunque en algunos casos, como el ejemplo anterior, pueda ha cer conceptualmente m\u00e1s complejos los sistemas. Siempre que es posible aplicar la herenc ia de tipo, puede ap licarse la herencia estructural, por lo que la mayor\u00eda de los lenguajes de programaci\u00f3n no hacen distinci\u00f3n entre los dos tipos de herencia. La herencia estructural m\u00faltiple permite heredar variab les y m\u00e9todos de va- rias superclases, pero surgen problema s que no son f\u00e1ciles de resolver, espe- cialmente con las variables de instancia.Los lenguajes de programaci\u00f3n com\u00fa nmente no hacen distinci\u00f3n entre la herencia estructural y la herencia de tipo.Ejemplo Si un canario es-un animal, entonces un canario funciona- como animal, m\u00e1s otras propie- dades especificas de canario. FUOC 71Z799014MO 17 Bases de datos en PostgreSQL Para resolver el conflicto de una variab le de instancia duplicada, se puede op- tar por las siguientes soluciones: Cambiar los nombres, lo que puede pr ovocar conflictos en los m\u00e9todos que las utilizan. Eliminar una de las variables. Pero pu ede pasar que realicen alguna funci\u00f3n independiente, en cuyo caso, ser\u00eda un error eliminar una. No permitir herencia m\u00faltiple cuando hay variables duplicadas. Como se puede observar, no es f\u00e1cil solucionar conflictos entre variables de instancia, por ello muchos lenguajes optan por diversos mecanismos inclu- yendo la prohibici\u00f3n de la herencia m\u00faltiple. 2.5.1. Tipo y clase Tenemos que advertir que la mayor\u00eda de lenguajes de programaci\u00f3n no dife- rencian los conceptos de tipo y clase y que la diferencia que establecen algu- nos autores no es demasiado clara. De to das maneras, la tend encia ser\u00eda definir dichos conceptos como sigue: Un tipo es un conjunto de objetos que comparten la misma interfaz. Una clase es un conjunto de obje tos que comparten la misma implemen- taci\u00f3n. Una soluci\u00f3n que se aplica es inclui r en el lenguaje el concepto de interfaz que define solamente las operaciones de una clase, pero no ofrece alternativas para los atributos. Sin embargo, con la diferenciaci\u00f3n entre clases e interfaces no se logra la diferenciaci\u00f3n entre los dos tipos de herencia, pues las clases se utilizan para representar relaciones es-un . 2.6. Agregaci\u00f3n: jerarqu\u00eda de objetos Los objetos son, por naturaleza, complejos; es decir, est\u00e1n compuestos de ob- jetos m\u00e1s peque\u00f1os. Un sistema de info rmaci\u00f3n debe reflejar esta propiedad de los objetos de forma natural. En una base de datos relacional, un objetocomplejo debe ser descompuesto en sus partes m\u00e1s simples para ser almacena- do. Al extraerlo, es necesario ensamblar cada una de sus partes. Por este motivo el modelo relacional compor ta problemas cuando se utiliza en aplicacio- nes como el CAD, donde los objetos que se procesan son muy complejos. Las bases de datos de objetos deben pr oporcionar la facilidad de obtener un objeto complejo en una sola consulta de forma transparente. En este caso, losEjemplo Un autom\u00f3vil est\u00e1 compuesto de carrocer\u00eda, motor, ruedas, etc. FUOC 71Z799014MO 18 Bases de datos en PostgreSQL apuntadores son un mecanismo excelent e para representar composici\u00f3n, ya que permiten acceder r\u00e1pidamente a las partes componentes de un objeto, sin importar su lugar de almacenamiento. Las bases de datos requieren independencia de la aplicaci\u00f3n, lo que provoca un conflicto conceptual cuando se trabaja con objetos compuestos: las basesde datos deben almacenar informaci\u00f3n independient e de la aplicaci\u00f3n para que nuevas aplicaciones pued an hacer diferentes interp retaciones de la infor- maci\u00f3n original; pero con los objetos co mpuestos esto no es tan sencillo, pues- to que suelen tener una so la interpretaci\u00f3n, o mejor dicho, una sola manera de ser consultado en una base de datos. 2.7. Persistencia La persistencia se define como la capacidad de un objeto para sobrevivir al tiempo de ejecuci\u00f3n de un programa. Para implem entarla, se utiliza el alma- cenamiento secundario. Se han propuesto varios mecanismos para implementar la persistencia en los lenguajes de programaci\u00f3n, entre los que podemos destacar los siguientes: Archivos planos. Se crean archivos pa ra almacenar los objetos en el forma- to deseado por el programa dor. Los objetos se cargan al abrir el programa y se guardan al finalizar. \u00c9sta es la opci\u00f3n m\u00e1s accesible para todos los len- guajes de programaci\u00f3n. Bases de datos relacionales. Los objetos son mapeados a tablas, un m\u00f3dulo del programa se encarga de hacer las transformaciones objeto-relacionales. Este enfoque consume mucho tiempo al realizar el mapeo. Existen algunas herramientas que realizan mapeos semiautom\u00e1ticos. Bases de objetos. Los objetos son almacenados de forma natural en una base de objetos, y la consulta y recupe raci\u00f3n es administrada por el gestor, de esta forma las aplicac iones no necesitan saber nada sobre los detalles de implementaci\u00f3n. Persistencia transparente. Los objetos son almacenados y recuperados por el sistema cuando \u00e9ste lo cree conveniente, sin que el usuario deba hacerninguna solicitud expl\u00edcita de consulta, actualizaci\u00f3 n o recuperaci\u00f3n de in- formaci\u00f3n a una base de objetos. No se requiere, por lo tanto, otro lenguaje para interactuar con las bases de datos. 2.8. PostgreSQL y la orientaci\u00f3n a objetos El argumento a favor de las bases de datos objeto-relacionales sostiene que per- mite realizar una migraci\u00f3n gradual de sistemas relacionales a los orientados FUOC 71Z799014MO 19 Bases de datos en PostgreSQL a objetos y, en algunas circunstancias, coexistir ambos tipos de aplicaciones durante alg\u00fan tiempo. El problema de este enfoque es que no es f\u00e1cil lograr la coex istencia de dos mo- delos de datos diferentes como son la orientaci\u00f3n a objetos y el modelo rela- cional. Es necesario equilibrar de algu na manera los conceptos de uno y otro modelo sin que entr en en conflicto. Uno de los conceptos fundamentales en la orientaci\u00f3n a objetos es el concepto de clase. Existen dos enfoques para asoc iar el concepto de clase con el modelo relacional: 1.er enfoque: las clases definen tipos de tablas 2.o enfoque: las clases definen tipos de columnas Dado que en el modelo relacional la s columnas est\u00e1n definidas por tipos de datos, lo m\u00e1s natural es hacer corresponder las co lumnas con las clases. PostgreSQL implementa los objetos como tuplas y las clases como tablas. Aun- que tambi\u00e9n es posible definir nuevos tipos de datos mediante los mecanis- mos de extensi\u00f3n. Dado que las tablas son clases, pueden definirse como herencia de otras. Las tablas derivadas son polim orfas y heredan todos los atributos (columnas) de la tabla padre (incluida su clave primaria). Si no se manejan con precauci\u00f3n, las tablas polimorfas pueden conducir a errores de inte gridad al duplicar claves primarias. PostgreSQL soporta algunas ex tensiones del lengua je SQL para crear y gestionar este tipo de tablas.1.er enfoque 2.o enfoque Los objetos son valores tuplasLas clases son dominios tablas Los mecanismos de extensi\u00f3n No es habitual que el usuario utilice los mecanismos de ex-tensi\u00f3n pues se consideran mecanismos avanzados. Veremos estos conceptos m\u00e1s en detalle en el subapartado 4.2 de esta unidad did\u00e1ctica. FUOC 71Z799014MO 20 Bases de datos en PostgreSQL 3. Acceso a un servidor PostgreSQL 3.1. La conexi\u00f3n con el servidor Antes de intentar conectarse con el servidor, debemos asegurarnos de que est\u00e1 funcionando y que admite co nexiones, locales (el SGBD se est\u00e1 ejecutando en la misma m\u00e1quina que intent a la conexi\u00f3n) o remotas. Una vez comprobado el correcto funcio namiento del servidor, debemos dis- poner de las credenciales necesarias para la conexi \u00f3n. Para simplificar, supon- dremos que disponemos de las credenciales* del administrador de la base de datos (normalmente, usuario PostgreSQL y su contrase\u00f1a). 3.2. El cliente psql Para conectarse con un servidor, se requiere, obviamente, un programa clien- te. Con la distribuci\u00f3n de PostgreSQL se incluye un cliente, psql, f\u00e1cil de uti- lizar, que permite la introducci\u00f3n inte ractiva de comandos en modo texto. El siguiente paso es conocer el nombre de una base de datos residente en el servidor. El siguiente comando permite conocer las bases de datos residentes en el servidor: Para realizar una conexi\u00f3n, se requieren los si guientes datos: Servidor. Si no se especifica, se utiliza localhost . Usuario. Si no se especifica, se utiliz a el nombre de usuario Unix que ejecu- ta psql. Base de datos. Ejemplos del uso de psql para conectarse con un servidor de bases de datos~$ psql -l List of databasesName | Owner | Encoding-----------+----------+-----------demo | postgres | SQL_ASCIItemplate0 | | SQL_ASCIItemplate1 | psql -d demo ~$ psql demo* Distintos tipos de credenciales permiten distintos niveles de acceso. En el apartado que concierne a la administraci\u00f3n de PostgreSQL se comenta detalladamente los aspectos relacionados con el sistema de usuarios, contrase\u00f1as y privilegios del SGBD. FUOC 71Z799014MO 21 Bases de datos en PostgreSQL Las dos formas anteriores ejecut an psql con la base de datos demo . A partir del fragmento anterior, el cliente psql mostrar\u00e1 algo similar a lo siguiente: El s\u00edmbolo '#', que signific a que psql est\u00e1 listo para leer la entrada del usuario. Las sentencias SQL se env\u00edan directamente al servidor para su interpretaci\u00f3n, los comandos internos tienen la forma \\comando y ofrecen opciones que no est\u00e1n incluidas en SQL y son interpretadas internamente por psql. Para terminar la sesi\u00f3n co n psql, utilizamos el comando \\q o podemos presio- nar Ctrl-D. 3.3. Introducci\u00f3n de sentencias Las sentencias SQL que escribamos en el cliente deber\u00e1n terminar con ';' o bien con '\\g': Cuando un comando ocupa m\u00e1s de una l\u00ednea, el indicador cambia de forma y va se\u00f1alando el elemento qu e a\u00fan no se ha completado. ~$ psql -d demo terminal.Type: \\copyright for distribution terms \\h for help with SQL commands \\? for help on internal slash commands\\g or terminate postgres (1 row) demo=#Notaci\u00f3n Hemos utilizado los dos co- mandos de ayuda que ofrece el lenguaje: \\h Explica la sintaxis de sentencias SQL. \\? Muestra los comandos internos disponibles. Para salir de ayuda, se presiona la tecla 'q'. FUOC 71Z799014MO 22 Bases de datos en PostgreSQL El cliente psql almacena la sentencia hast a que se le da la orden de enviarla al SGBD. Para visualizar el contenido del buffer donde ha almacenado la senten- cia, disponemos de la orden '\\p': El cliente tambi\u00e9n dispone de una or den que permite borrar completamente el buffer para empezar de nu evo con la sentencia: 3.3.1. Expresiones y variables El cliente psql dispone de multitud de prestaciones avanzadas; entre ellas (co- mo ya hemos comentado), el soporte pa ra sustituci\u00f3n de variables similar al de los shells de Unix: Esta sentencia crea la variable 'var1' y le asigna el valor 'dem ostraci\u00f3n'. Para recu- perar el valor de la variable, simplement e deberemos incluirla precedida de ':' en cualquier sentencia o bien ver su valor mediante la orden 'echo':Indicadores de PostgreSQL Indicador Significado =# Espera una nueva sentencia -# La sentencia a\u00fan no se ha terminado con \";\" o \\g \"# Una cadena en comillas dobles no se ha cerrado '# Una cadena en comillas simples no se ha cerrado (# Un par\u00e9ntesis no se ha cerrado demo=> SELECT demo-> 2 * 10 + 1 demo-> * 10 + 23 datos en PostgreSQL De la misma forma, psql define algunas variables especiales que pueden ser \u00fatiles para conocer deta lles del servidor al qu e estamos conectados: El uso de variables puede ayudar en la ejecuci\u00f3n de sentencias SQL: 3.4. Proceso por lotes y formatos de salida Adem\u00e1s de ser interactivo, psql puede procesar coma ndos por lotes almacena- dos en un archivo del sistema operat ivo mediante la si guiente sintaxis: Aunque el siguiente comando tambi\u00e9n funciona en el mismo sentido, no es recomenda- ble usarlo porque de este modo, psql no muestra informaci\u00f3n de depuraci\u00f3n importante, como los n\u00fameros de l\u00ednea donde se locali zan los errores, en caso de haberlos: El propio int\u00e9rprete psql nos proporci ona mecanismos para almacenar en fi- chero el resultado de las sentencias: Especificando el fichero destino* directamente al finalizar una sentencia:demo=# Se debe ser muy cuidadoso con el us o de las comillas y tambi\u00e9n es im- portante tener en cuenta que dentro de cadenas de caracteres no se sus- tituyen variables. $ psql user \\g /tmp/a.txt* Hemos almacenado el resultado en el fichero ' /tmp/a.txt '. FUOC 71Z799014MO 24 Bases de datos en PostgreSQL Mediante una pipe enviamos la salida a un comando Unix: Mediante la orden '\\o' se puede indica r d\u00f3nde debe ir la salida de las sen- tencias SQL que se ejecuten en adelante: Se puede solicitar la ej ecuci\u00f3n de un solo comando y terminar inmediata- mente mediante la siguiente forma: Se puede especificar el formato de salida de los resultados de una sentencia. Por defecto, psql los muestra en forma tabular mediante texto. Para cambiarlo, se debe modificar el valor de la variab le interna 'format' mediante la orden '\\pset'. Veamos, en primer lugar, la especifi caci\u00f3n del formato de salida:demo=# debe espe- cificar un ficher o o bien un co- mando que ir\u00e1 recibiendo los resultados mediante una pipe. Cuando se desee volver a la sa- lida est\u00e1ndar STDOUT, simple-mente se dar\u00e1 la orden '\\o' sin ning\u00fan par\u00e1metro. La salida del fichero Al haber especificado que se quiere la salida en html, la po-dr\u00edamos redirigir a un fichero (ya hemos visto c\u00f3mo hacerlo) y generar un archivo html que permitiese ver el resultado de la consulta mediante un na-vegador web convencional. FUOC 71Z799014MO 25 Bases de datos en PostgreSQL Hay otros formatos de salid a, como 'aligned', 'unaligne d', 'html' y 'latex'. Por defecto, psql muestra el resultado en formato 'aligned'. Tenemos tambi\u00e9n multitud de variables para ajustar los se paradores entre co- lumnas, el n\u00famero de regi stros por p\u00e1gina, el separa dor entre registros, t\u00edtulo de la p\u00e1gina html, etc. Veamos un ejemplo: Para poder realizar los ejem plos del resto del presente apartado, se debe proce- sar el contenido del fichero demo.sql tal como se transcribe a continuaci\u00f3n. Contenido del fichero demo.psql demo=# current_user,resultadopostgres,6 (1 row) demo=#La salida de este fichero Con esta configuraci\u00f3n, y diri- giendo la salida a un fichero, generar\u00edamos un fichero CSV listo para ser le\u00eddo en una hoja de c\u00e1lculo u otro programa de importaci\u00f3n de true ); create table ganancia( venta (4,2) ); insert into proveedores, values ('Patito',005,9.78); FUOC 71Z799014MO 27 Bases de datos en PostgreSQL 3.5. Usar bases de datos La siguiente orden informa sobre las bases de datos actualmente en el SGBD. La orden '\\c' permite conectarse a una base de datos: La consulta de la tabla que contiene la base de datos demo se realiza mediante la orden '\\d': insert into precios values | LATIN9 \\d | | Type | Owner--------+---------------------+----------+---------- public | ganancia | table | postgres public | precios | table | postgres public | productos | table | postgres public | productos_clave_seq | sequence | postgres public | proveedores | table | postgres(5 rows) FUOC 71Z799014MO 28 Bases de datos en PostgreSQL Consulta de las columnas de cada una de las tablas: Para crear una nueva base de datos, usaremos la sentencia create database : Para eliminar una base de da tos, usaremos la sentencia drop database :La orden \\d es \u00fatil para mostrar informac i\u00f3n sobre el SGBD: tablas, \u00edn- dices, objetos, variables, permisos, etc. Pod\u00e9is obtener todas las varian- tes de esta sentencia introduciendo \\? en el int\u00e9rprete de comandos. demo-# \\d proveedores |Type | varying(20) not null credito boolean | efectivo Bases de datos en PostgreSQL 4. Creaci\u00f3n y manipulaci\u00f3n de tablas 4.1. Creaci\u00f3n de tablas Una vez conectados a una base de datos, la sentencia SQL create table per- mite crear las tablas que necesitemos: El comando drop table permite eliminar tablas: La tabla reci\u00e9n creada aparece ahora en la lista de tablas de la base de datos en uso: Podemos consultar su descripci\u00f3n mediante el comando \\d tabla : La tabla est\u00e1 lista para insert ar en ella algunos 1 FUOC 71Z799014MO 30 Bases de datos en PostgreSQL El n\u00famero con el que responde el comando insert se refiere al OID del registro insertado. Las consultas se realizan con la sentencia SQL select. En este caso solicita- mos que nos muestre toda s las columnas de los registros en la tabla persona : Las tablas creadas en PostgreSQL incluy en, por defecto, varias columnas ocul- tas que almacenan informaci\u00f3n acerca del identificador de transacci\u00f3n en quepueden estar implicad as, la localizaci\u00f3n f\u00edsica del registro dentro de la tabla (para localizarla muy r\u00e1pida mente) y, los m\u00e1s importantes, el OID y el TABLE- OID. Estas \u00faltimas columnas est\u00e1n defini das con un tipo de datos especial lla- mado identificador de objeto (OID) que se implementa como un enteropositivo de 32 bits. Cuando se inserta un nuevo registro en una tabla se le asig-na un n\u00famero consecutivo como OID, y el TABLEOID de la tabla que le co-rresponde. Para observar las columnas ocultas, debemos hacer re ferencia a ellas espec\u00edfi- camente en el comando select : demo=# select * from persona; nombre |direccion-----------------------+------------ Alejandro Magno | Babilonia Federico Garc\u00eda Lorca | Granada 65(2 rows) demo=# En la programaci\u00f3n orientada a objetos, el concepto de OID es de vital importancia, ya que se re fiere a la identidad propia del objeto, lo que lo diferencia de los dem\u00e1s objetos. demo=# select oid, Magno | Babilonia 17243 | 17240 | Federico Garc\u00eda Lorca | Granada 65 (2 rows) demo=# Estas columnas se implementan para se rvir de identificadores en la rea- lizaci\u00f3n de enlaces desde otras tablas.Este aspecto se explicar\u00e1 en detalle m\u00e1s adelante. FUOC 71Z799014MO 31 Bases de datos en PostgreSQL Ejemplo de la utilizaci\u00f3n de OID para enlazar dos tablas Retomamos la tabla persona y construimos una nueva tabla para almacenar los tel\u00e9fonos. La tabla tel\u00e9fono incluye la columna propietario de tipo OID, que almacenar\u00e1 la referencia a los registros de la tabla persona . Agreguemos dos tel\u00e9fonos a 'Alejandro Magno', para ello utilizamos su OID que es 17242: Las dos tablas est\u00e1n vinculadas por el OID de persona. La operaci\u00f3n que nos permite unir las dos tablas es join, que en este caso une tel\u00e9fono y persona , utilizando para ello la igualdad de las columnas telefono.propietario y persona.oid : Los OID de PostgreSQL pres entan algunas deficiencias: Todos los OID de una base de datos se generan a partir de una \u00fanica se- cuencia centralizada, lo que provoca que en bases de datos con mucha ac- tividad de inserci\u00f3n y elim inaci\u00f3n de registros, el contador de 4 bytes se desborde y pueda entregar OID ya entregados. Esto sucede, por supuesto, con bases de datos muy grandes. Las tablas enlazadas mediante OID no tienen ninguna ventaja al utilizar operadores de composici\u00f3n en t\u00e9rminos de eficiencia respecto a una clave primaria convencional. Los OID no mejoran el rendimiento. Son, en realidad, una columna con un n\u00famero entero como valor.demo=# perso-na.oid); tipo |numero | propietario |nombre | direccion------------+-------------+-------------+-----------------+----------- m\u00f3vil | 12345678 | 17242 | Alejandro Magno | Babilonia casa | 987654 | 17242 | Alejandro Magno | Babilonia(2rows) FUOC 71Z799014MO 32 Bases de datos en PostgreSQL Los desarrolladores de PostgreSQL propon en la siguiente alternativa para usar OID de forma absolutamente segura: Crear una restricci\u00f3n de tabla para qu e el OID sea \u00fanico, al menos en cada tabla. El SGBD ir\u00e1 incrementando se cuencialmente el OID hasta encontrar uno sin usar. Usar la combinaci\u00f3n OID - TABLEOID si se necesita un identificador \u00fanico para un registro v\u00e1lido en toda la base de datos. Por los motivos anteriores, no es reco mendable el uso de OID hasta que nue- vas versiones de PostgreSQL los corrijan. En caso de usarlos, conviene seguir las recomendacio nes anteriores. Es posible crear tablas que no incluyan la columna OID medi ante la siguiente notaci\u00f3n: 4.2. Herencia PostgreSQL ofrece como caracter\u00edstica pa rticular la herencia entre tablas, que permite definir una tabla que herede de otra previamente definida, seg\u00fan la definici\u00f3n de herencia que hemo s visto en cap\u00edtulos anteriores. Retomemos la tabla persona definida como sigue: A partir de esta definici\u00f3n, creamos la tabla estudiante como derivada de persona :create table persona FUOC 71Z799014MO 33 Bases de datos en PostgreSQL En la tabla estudiante se definen las columnas carrera , grupo y grado , pero al so- licitar informaci\u00f3n de la estructura de la tabla observamos que tambi\u00e9n inclu- ye las columnas definidas en persona : En este caso, a la tabla persona la llamamos padre y a la tabla estudiante , hija. Cada registro de la tabla estudiante contiene 5 valores porque tiene 5 columnas: La consulta del cont enido de la tabla estudiante mostrar\u00e1, por supuesto, un solo registro. Es decir, no se heredan los datos, \u00fanicamente los campos (atri- butos) del objeto:demo=# \\d estudiante character varying(30) | direccion | character varying(30) | carrera | character varying(50) | grupo | character(1) | grado | 1 La herencia no s\u00f3lo permite que la tabla hija contenga las columnas de la tabla padre , sino que establece una relaci\u00f3n conceptual es-un Juan | Treboles 21 | Ingenieria en Computacion | A | 3 (1 row) FUOC 71Z799014MO 34 Bases de datos en PostgreSQL Adem\u00e1s, la consul ta de la tabla persona mostrar\u00e1 un nuevo registro: El \u00faltimo registro mostrado es el que fue insertado en tabla estudiante , sin em- bargo la herencia define una rela ci\u00f3n conceptual en la que un estudiante es-una persona . Por lo tanto, al consultar cu\u00e1ntas personas est\u00e1n registradas en la base de datos, se incluye en el resultado a todos los estudiantes. Para consultar s\u00f3lo a las personas que no son estudiantes, podemos utilizar el modificador ONLY: Como es l\u00f3gico, al borrar la fila del nuevo estudiante que hemos insertado, se borra de las dos tablas. Tanto si lo borramos desde la tabla persona , como si lo borramos desde la tabla estudiante. 4.3. Herencia y OID Los OID permiten que se diferencien lo s registros de todas las tablas, aunque sean heredadas: nuestro estudiante tendr\u00e1 el mismo OID en las dos tablas, yaque se trata de \u00fanica instancia de la clase estudiante:demo=# select * from persona; nombre | direccion-----------------------+------------- Federico Garca Lorca | Granada 65 Alejandro Magno | Babilonia Juan | Treboles 21 (3 rows) demo=# select * from only persona; nombre | direccion -----------------------+------------ Alejandro Magno | Babilonia Federico Garc\u00eda Lorca | Granada 65 (2 rows)demo=# No es posible borrar una tabla padre si no se borran primero las tablas hijo. demo=# drop table persona; NOTICE: table estudiante depende de table persona ERROR: no se puede eliminar table persona porque otros objetos dependen de \u00e9lHINT: Use DROP ... CASCADE para eliminar adem\u00e1s los objetos dependientes. FUOC 71Z799014MO 35 Bases de datos en PostgreSQL Dado que no se recomienda el uso de OID en bases muy grandes, y debe in- cluirse expl\u00edcitamente en las consultas pa ra examinar su valor, es conveniente utilizar una secuencia compartida para padres y todos sus descendientes si se requiere un identificador. En PostgreSQL, una alternativa para no utilizar los OID es crear una columna de tipo serial en la tabla padre , as\u00ed ser\u00e1 heredada en la hija. El tipo serial define una secuencia de valores que se ir\u00e1 incrementando de forma autom\u00e1tica, y porlo tanto constituye una buena forma de crear claves primarias, al igual que eltipo AUTO_INCREMENT en MySQL. La columna id se define como un entero y se incrementar\u00e1 utilizando la fun- ci\u00f3n nextval() tal como nos indica la informaci\u00f3n de la columna:demo=# select oid,* from persona ; oid |nombre | direccion -------+-----------------------+------------- 17242 | Alejandro Magno | Babilonia 17243 | Federico Garc\u00eda Lorca | Granada 65 17247 | Juan | Treboles 21 (3 rows)demo=# grado -------+--------+-------------+---------------------------+-------+------- 17247 | Juan | Treboles 21 | Ingenieria en Computaci\u00f3n | A | 3 (1 row) demo=# create table persona datos en PostgreSQL Al definir un tipo serial , hemos creado im pl\u00edcitamente una secuencia indepen- diente de la tabla. Podemos consultar las secuencias de nuestra base de datosmediante el comando '\\ds': Creamos nuevamente la tabla estudiante heredando de persona : El estudiante heredar\u00e1 la columna id y se incrementar\u00e1 utilizando la misma se- cuencia: Insertaremos en la tabla algunos regist ros de ejemplo, omit iendo el valor para la columna id:demo=# relations Schema |Name 71Z799014MO 37 Bases de datos en PostgreSQL La tabla estudiante contendr\u00e1 un solo registro, pero su identificador es el n\u00famero 3. Todos los registros de persona siguen una misma secuencia sin importar si son padres o hijos: La herencia es \u00fatil para definir tabl as que conceptualmente mantienen ele- mentos en com\u00fan, pero tambi\u00e9n requ ieren datos que los hacen diferentes. Uno de los elementos que conviene defi nir como comunes son los identifica- dores de registro. 4.4. Restricciones Como ya sabemos, las restricciones pe rmiten especificar condiciones que de- ber\u00e1n cumplir tablas o columnas para mant ener la integridad de sus datos. Al- gunas de las restricciones vendr\u00e1n impuestas por el modelo concreto que se est\u00e9 implementando, mientras que otras tendr\u00e1n su orig en en las reglas de ne- gocio del cliente, los valores que pueden tomar algunos campos, etc. Los valores que puede contener una co lumna est\u00e1n restringidos en primer lugar por el tipo de datos. \u00c9sta no es la \u00fanica restricci\u00f3n que se puede defi-nir para los valores en una columna, Po stgreSQL ofrece las restricciones si- guientes: null y not null . En m\u00faltiples ocasiones el va lor de una columna es desco- nocido, no es aplicable o no existe. En estos casos, los valores cero, cadena vac\u00eda o falso son inadecuado s, por lo que utilizamos null para especificardemo=# select 3 | | | Psicologia | B | 5(1 row) demo=# select * id |nombre |direccion ----+----------------------+------------ 1 | Federico Garca Lorca | Granada 65 2 | Alejandro Magno | Babilonia 3 | Elizabeth | Pino 35(3 rows) Ejemplo Una columna definida como integer no puede contener ca- denas de caracteres. FUOC 71Z799014MO 38 Bases de datos en PostgreSQL la ausencia de valor. Al definir una tabla podemos indicar qu\u00e9 columnas podr\u00e1n contener valore s nulos y cu\u00e1les no. El nombre de una persona no puede ser nulo, y es posible que la persona no tenga trabajo . Tambi\u00e9n es posible que no tenga correo , al no especificar una restricci\u00f3n not null, se asu- me que la columna puede contener valores nulos. unique . Esta restricci\u00f3n se utiliza cuando no queremos que los valores con- tenidos en una columna puedan duplicarse. c\u00f3nyuge no puede contener valores duplicados, no permitiremos que dos personas tengan simult\u00e1neamente el mismo c\u00f3nyuge. primary key . Esta restricci\u00f3n especifica la columna o columnas que elegi- mos como clave primaria. Pued e haber m\u00faltiples columnas unique , pero s\u00f3lo debe haber una clave primaria. Lo s valores que son \u00fanicos pueden ser- vir para identificar una fila de la tabl a de forma un\u00edvoca, por lo que se les denomina claves candidatas . Al definir una columna como primary key , se define impl\u00edcitamente con unique . El nss (n\u00famero de la seguridad social) no s\u00f3lo es \u00fan ico, sino que lo utilizamos para identificar a las personas. references y foreign key . En el modelo relacional , establecemos las rela- ciones entre entidades mediante la inclusi\u00f3n de claves for\u00e1neas en otras re-laciones. PostgreSQL y SQL ofrecen me canismos para expresar y mantener esta integridad refe rencial. En el siguiente ejemplo, las Mascotas tienen como due\u00f1o a una Persona :create table Persona ( nombre varchar(40) not null, varchar(20), Persona, ); FUOC 71Z799014MO 39 Bases de datos en PostgreSQL Una referencia por defecto es a una clave primaria, por lo que due\u00f1o se refiere impl\u00edcitamente al nss de Persona . Cuando se capturen los datos de una nueva mascota , PostgreSQL verificar\u00e1 que el valor de due\u00f1o haga referencia a un nss que exista en Persona , en caso contrario emitir\u00e1 un mensaje de error. En otras palabras, no se permite asignar a una mascota un due\u00f1o que no exista. Tambi\u00e9n es posible especificar a qu\u00e9 co lumna de la tabla hace referencia: o su equivalente: Podr\u00eda darse el caso de que la clave pr imaria de la tabla referenciada tuviera m\u00e1s de una columna, en ese caso, la clave for\u00e1nea tambi\u00e9n tendr\u00eda que estar formada por el mismo n\u00famero de columnas: Si no se especifica otra acci\u00f3n, por omisi\u00f3n la persona que tenga una mascota no puede ser eliminad a, porque la mascota se quedar\u00eda sin due\u00f1o. Para poder eliminar una persona, antes se deben eliminar las mascot as que tenga. Este comportamiento no parece ser el m\u00e1s adecuado para el caso. Para modificar este comportamiento di sponemos de las re glas de integridad referencial del lenguaje SQ L, que PostgreSQL tambi\u00e9n soporta. En el siguiente ejemplo se permite que al eliminar un a persona, las mascotas simplemente se queden sin due\u00f1o.create table Mascota( nombre varchar(20), Mascota delete set null , ); FUOC 71Z799014MO 40 Bases de datos en PostgreSQL En cl\u00e1usula on delete se pueden especificar las siguientes acciones: -set null . La referencia toma el valor NULL: si se elimina Persona su Mascota se quedar\u00e1 sin due\u00f1o. -set default . La referencia toma el valor por omisi\u00f3n. -cascade . La acci\u00f3n se efect\u00faa en cascada: si se elimina Persona autom\u00e1tica- mente se elimina su Mascota . -restrict . No permite el borrado del regi stro: no se puede eliminar una Per- sona que tenga Mascota . \u00c9sta es la acci\u00f3n que se toma por omisi\u00f3n. Si se modifica la clave primaria de la tabla referenciada, se dispone de las mis- mas acciones que en el caso anterior, que especificaremos con la cl\u00e1usula ON UPDATE. check . Esta restricci\u00f3n realiza la evalua ci\u00f3n previa de una expresi\u00f3n l\u00f3gica cuando se intenta realizar una asignaci\u00f3n. Si el resultado es verdadero,acepta el valor para la columna, en caso contrari o, emitir\u00e1 un mensaje de error y rechazar\u00e1 el valor. Se han restringido los valores que se acepta r\u00e1n en la columna de la manera siguiente. Edad debe estar entre 11 y 79 a\u00f1os. Ciudad no debe una cadena vac\u00eda. Correo debe tener una arroba. Cualquiera de esas restricciones puede tener nombre , de manera que se facilita la referencia a las restricciones espec\u00ed ficas para borrarlas , modificarlas, etc. pues puede hacerse por nombres. Para dar nombre a una restricci\u00f3n, utiliza- mos la sintaxis siguiente: 4.4.1. Restricciones de tabla Cuando las restricciones se indican desp u\u00e9s de las definiciones de las colum- nas, y pueden afectar a varias de ella s simult\u00e1neamente, se dice que son res- tricciones de tabla:create table Persona ( edad int check ( edad > 10 and edad < 80 ), varchar(20) check( correo expresiones regulares El operador ~ realiza compara- ciones de cadenas con expre-siones regulares. Las expresiones regulares son patrones de b\u00fasqueda muy flexibles desarrollados en el mundo Unix. FUOC 71Z799014MO 41 Bases de datos en PostgreSQL Esta notaci\u00f3n permite que la restri cci\u00f3n pueda abarcar varias columnas. Un curso se identifica por el grupo y la materia, y dos cursos no pueden estar en la misma aula el mismo d\u00eda y a la misma hora. Al igual que la restricci\u00f3n de columna, a las restricciones de tabla puede asig- n\u00e1rseles un nombre: La sentencia alter table permite a\u00f1adir ( add) o quitar ( drop ) ya Persona ( ( materia varchar(30), grupo char(4), dia int, hora time, aula int, primary key (materia, grupo), unique (dia, hora, aula) ); create table Persona ( nss nombre ); alter table constraint monogamia unique (pareja); FUOC 71Z799014MO 42 Bases de datos en PostgreSQL 4.5. Indexaci\u00f3n PostgreSQL crea \u00edndices para las llaves primarias de todas las tablas. Cuando se ne- cesite crear \u00edndices adiciona les, utilizaremos la expr esi\u00f3n del ejemplo siguiente: 4.6. Consulta de informaci\u00f3n de bases de datos y tablas Como ya sabemos, el cliente psql ofrece varias alternat ivas para obtener infor- maci\u00f3n sobre la estructura de nuestra base de datos. En la siguiente tabla semuestran algunos comand os de mucha utilidad. Para obtener la lista de tablas de la base de datos demo hacemos lo siguiente: La estructura de la tabla productos se solicita de la siguiente manera.create index persona_nombre_indice on Persona ( nombre ); Comando Descripci\u00f3n \\l Lista las bases de datos \\d Describe las tablas de la base de datos en uso \\ds Lista las secuencias \\di Lista los \u00edndices \\dv Lista las vistas \\dp \\z Lista los privilegios sobre las tablas \\da Lista las funciones de agregados \\df Lista las funciones \\g archivo Ejecuta los comandos de archivo \\H Cambia el modo de salida HTML \\! comando Ejecuta un comando del sistema operativo demo=# \\d List of relationsName |Type | Owner---------------------+----------+-------- ganancia | table | postgres precios | table | postgres productos | table | postgres productos_clave_seq | sequence | postgres proveedores productos_pkeyTriggers: RI_ConstraintTrigger_17342,RI_ConstraintTrigger_17344 FUOC 71Z799014MO 43 Bases de datos en PostgreSQL En el ejemplo anterior podemos observar que la columna clave contiene dos modificadores: El primero especifica que no pueden asignarse valores nulos. El segundo especifica el valor por om isi\u00f3n que deber\u00e1 as ignarse a la co- lumna. En este caso, el valor ser\u00e1 autom\u00e1ticamente calculado por la funci\u00f3n nextval() , que toma como argumento la secuencia* productos_clave_seq . El siguiente comando muestra las secuencias creadas en una base de datos: Las secuencias se crean autom\u00e1ticame nte cuando se declaran columnas de tipo serial. En la estructura de la tabla productos encontramos tambi\u00e9n una clave pri- maria. PostgreSQL generar\u00e1 siempre un \u00edndice para cada tabla utilizando la clave primaria. La lista de los \u00edndices de la base de datos se obtiene de la si- guiente forma: El conjunto de comandos proporcionados por psql que hemos presentado permite obtener informaci\u00f3n sobre la es tructura de nuestra base de datos de una manera directa y sencilla y, tambi\u00e9n, es \u00fatil para explorar bases de datos que no conozcamos.demo=# \\ds List of relations Name |Type | Owner---------------------+----------+--------productos_clave_seq | quiron(1 row) demo=# \\di List of relations Name | Type | Owner------------------+-------+--------productos_pkey | index | quironproveedores_pkey | index | quiron(2 rows)* Una secuencia es un nombre especial que permite la producci\u00f3n de series num\u00e9ricas. FUOC 71Z799014MO 44 Bases de datos en PostgreSQL 4.7. Tipos de datos 4.7.1. Tipos l\u00f3gicos PostgreSQL incorpora el tipo l\u00f3gico boolean , tambi\u00e9n llamado bool . Ocupa un byte de espacio de almacenamiento y puede almacenar los valores falso y verdadero. PostgreSQL soporta los oper adores l\u00f3gicos siguientes: and, or y not. Aunque los operadores de comparaci\u00f3n se aplican sobre pr\u00e1cticamente todos los tipos de datos proporcionados por PostgreSQL, dado que su resultado es unvalor l\u00f3gico, describire mos su comportamiento en la siguiente tabla: 4.7.2. Tipos num\u00e9ricos PostgreSQL dispone de los tipos enteros smallint , int y bigint que se compor- tan como lo hacen los enteros en muchos lenguajes de programaci\u00f3n. Los n\u00fameros con punto flotante real y double precisi\u00f3n almacenan cantida- des con decimales. Una caracter\u00edstica de los n\u00fameros de punto flotante es quepierden exactitud conforme crecen o decrecen los valores. Aunque esta p\u00e9rdida de exactitud no su ele tener importancia en la mayor\u00eda de las ocasiones, PostgreSQL incluye el tipo numeric , que permite almacenar cantidades muy grandes o muy peque\u00f1as sin p\u00e9rdida de informaci\u00f3n. Por su- puesto, esta ventaja tiene un coste, los valores de tipo numeric ocupan un es- pacio de almacenamiento considerab lemente grande y las operaciones se ejecutan sobre ellos muy lentamente. Po r lo tanto, no es aconsejable utilizar el tipo numeric si no se necesita una alta pr ecisi\u00f3n o se prima la velocidad de procesamiento.Valor Nombre Falso false, 'f', 'n', 'no', 0 Verdadero true, 't', 'y', 'yes', 1 Operador Descripci\u00f3n >M a y o r q u e <M e n o r q u e <= Menor o igual que>= Mayor o igual que <> !=Distinto de Nombre Tama\u00f1o Otros nombres Comentario smallint 2 bytes int2 int 4 bytes int4, integer FUOC 71Z799014MO 45 Bases de datos en PostgreSQL Serial La declaraci\u00f3n serial es un caso especial, ya que no se trata de un nuevo tipo. Cuando se utiliza como nombre de tipo de una columna, \u00e9sta tomar\u00e1 autom\u00e1ticamente valores con- secutivos en cada nuevo registro. Ejemplo de una tabla que define la columna folio como tipo serial . PostgreSQL responder\u00eda esta instrucci\u00f3n con dos mensajes: En el primero avisa que se ha creado una secuencia de nombre factura_folio_seq : En el segundo avisa de la creaci\u00f3n de un \u00edndice \u00fanico en la tabla utilizando la columna folio: Si se declaran varias columnas con serial en una tabla, se crear\u00e1 una secuencia y un \u00edndice para cada una de ellas. 4.7.3. Operadores num\u00e9ricos PostgreSQL ofrece un conjunto predefin ido de operadores num\u00e9ricos, que pre- sentamos en la siguiente tabla:Nombre Tama\u00f1o Otros nombres Comentario bigint 8 bytes int8numeric(p,e) 11 + (p/2) 'p' es la precisi\u00f3n, 'e' es la escala real 4 bytes float, float4 double precision 8 bytes float8 serialNo es un tipo, es un entero auto-incrementable create table Factura( folio serial, cliente CREATE TABLE will CREATE S\u00edmbolo Operador +A d i c i \u00f3 n - Substracci\u00f3n * Multiplicaci\u00f3n / Divisi\u00f3n %M \u00f3 d u l o ^E x p o n e n c i a c i \u00f3 n |/ Ra\u00edz Bases de datos en PostgreSQL 4.7.4. Tipos de caracteres Los valores de cadena en PostgreSQL se delimitan por comillas simples. Se puede incluir una comilla simple dentro de una cadena con \\' o ' ': Las cadenas pueden contener caracteres especiales utilizan do las llamadas se- cuencias de escape que in ician con el caracter '\\':S\u00edmbolo Operador ||/ Ra\u00edz c\u00fabica ! Factorial !! Factorial como operador fijo @V a l o r a b s o l u t o &A N D b i n a r i o |O R b i n a r i o #X O R b i n a r i o~ Negaci\u00f3n binaria << Corrimiento binario a la izquierda >> Corrimiento binario a derecha \\r retorno de carro \\t tabulador \\b retroceso \\f cambio de p\u00e1gina \\r retorno de carro \\\\ el caracter \\Recordad Las comillas dobles delimitan identificadores que contienen caracteres especiales. FUOC 71Z799014MO 47 Bases de datos en PostgreSQL Las secuencias de escape se sustituy en por el car\u00e1cter correspondiente: PostgreSQL ofrece los tipos siguientes para cadenas de caracteres: 4.7.5. Operadores En la siguiente tabla se describen los operadores para cadenas de caracteres: En la siguiente tabla se muestran algu nas funciones de uso com\u00fan sobre cade- nas de caracteres: Sobre las cadenas tambi\u00e9n podemos utilizar los oper adores de comparaci\u00f3n que ya conocemos. Ejemplo En este caso, el resultado de la comparaci\u00f3n menor que es VERDADERO:demo=# select 'Esto est\u00e1 en \\n dos renglones'; ?column? ------------------------------Esto est\u00e1 en dos renglones (1 row) Tipo Otros nombres Descripci\u00f3n char(n) character(n) Reserva n espacios para al macenar la cadena varchar(n) character var-ying(n)Utiliza los espacios nece sarios para almacenar una cadena menor o igual que n text Almacena cadenas de cualquier magnitud Operador Descripci\u00f3n\u00bfDistingue may\u00fasculas y min\u00fasculas? || Concatenaci\u00f3n - ~ Correspondencia a expresi\u00f3n regular S\u00ed ~* Correspondencia a expresi\u00f3n regular No !~ No correspondencia a expresi\u00f3n regular S\u00ed !~* No correspondencia a expresi\u00f3n regular - Funci\u00f3n Descripci\u00f3n Length(cadena) Devuelve la longitud de la cadena lower(cadena) Convierte la cadena a min\u00fasculas ltrim(cadena,caracteres) Elimina de la izquierda los caracteres especificados substring(cadena from patr\u00f3n) Extrae la subcadena que cumple el patr\u00f3n especificado demo=# select 'HOLA' < 'hola'; ?column?---------- t (1 row)Bibliograf\u00eda Es recomendable consultar el manual para obtener la referencia completade funciones. FUOC 71Z799014MO 48 Bases de datos en PostgreSQL 4.7.6. Fechas y horas En la siguiente tabla se muestran los tipos de datos referentes al tiempo que ofrece PostgreSQL: Existe un tipo de dato timez que incluye los datos del tipo time y, adem\u00e1s, la zona ho- raria. Su sintaxis es la siguiente: hh:mm[:ss[.mmm]][am|pm][zzz] El tipo de datos date almacena el d\u00eda, mes y a\u00f1o de una fecha dada y se mues- tra por omisi\u00f3n con el form ato siguiente: YYYY-MM-DD: Para cambiar el formato de presentaci\u00f3n , debemos modificar la variable de en- torno datestyle : 4.7.7. Arrays El tipo de datos array es una de las caracter\u00edstica s especiales de PostgreSQL, permite el almacenamiento de m\u00e1s de un valor del mismo tipo en la misma columna.Tipo de dato Unidades Tama\u00f1o Descripci\u00f3n Precisi\u00f3n date d\u00eda-mes-a\u00f1o 4 bytes Fecha D\u00eda time hrs:min:seg:micro 4 bytes Hora Microsegundo timestampd\u00eda-mes-a\u00f1o hrs:min:seg:micro8 bytes Fecha m\u00e1s hora Microsegundo intervalsecond, persona; 22.05.2004 (1 row)* no cumplen la pri- mera forma normal de Cood, por lo que muchos los conside-ran inaceptables en el modelo relacional. FUOC 71Z799014MO 49 Bases de datos en PostgreSQL La columna parciales acepta tres calificaci ones de los estudiantes. Tambi\u00e9n es posible asig nar un solo valor del array : Los arrays , al igual que cualquier columna cuan do no se especifica lo contra- rio, aceptan valores nulos: Los valores del array se escriben siempre entre llaves. Para seleccionar un valor de un array en una consulta se especifica entre cor- chetes la celda que se va nombre | parciales ------------+------------ John Lennon |Juan | {90,95,97} Pedro | {90,95,97}(2 demo=# select nombre, parciales[3] from Estudiante; nombre | parciales--------------+----------- John Lennon | Juan | 97 Pedro | (3 rows)S\u00f3lo Juan tiene calificaci\u00f3n en el tercer parcial. FUOC 71Z799014MO 50 Bases de datos en PostgreSQL En muchos lenguajes de programaci\u00f3n, los array se implementan con longitud fija, PostgreSQL permite aument ar su tama\u00f1o din\u00e1micamente: Mediante la funci\u00f3n array_dims() po demos conocer las dimensiones de un array : 4.7.8. BLOB El tipo de datos BLOB (Binary Large OBject) permite almacenar en una colum- na un objeto de gran tama\u00f1o. PostgreSQL no conoce nada sobre el tipo de in- formaci\u00f3n que se almacena en una co lumna BLOB, simpleme nte lo considera como una secuencia de bytes. Por este motivo, no se tienen operaciones sobre los tipos BLOB, con la excepci\u00f3n del op erador de concatenaci\u00f3n, que simple- mente une el contenido de dos BLOB en uno. Veamos c\u00f3mo almacenar una fotograf\u00eda en una tabla de personas mediante ti- pos BLOB. Una primera manera de ha cerlo es importando el contenido del archivo que contiene la imagen mediante la funci\u00f3n lo_import() :La columna parciales del registro Pablo incluye cuatro celdas y s\u00f3lo la \u00faltima tiene valor. demo=# insert | parciales--------------+------------ John Lennon | Juan | {90,95,97} Pedro | {90} | {70}(4 array_dims(parciales) from nombre John Lennon | Juan | [1:3]Pedro 71Z799014MO 51 Bases de datos en PostgreSQL Esta funci\u00f3n devuelve como resultado el OID del ob jeto insertado.\u00bfD\u00f3nde se ha almacenado la fotograf\u00eda si no hemos utilizado el comando insert ? Post- greSQL mantiene una tabla de nombre pg_largeobject con el objetivo de al- macenar BLOB. Podemos utilizar el OID para hacer referenciar al objeto en una tabla: Los registros insertados en esta tabla llevan un n\u00famero entero como OID que, en el siguiente caso, se ha obte nido solicit\u00e1ndolo a la funci\u00f3n lo_import() an- terior. La inserci\u00f3n anterior pudo habe rse realizado en un solo paso: Para extraer el contenido de la columna, se utiliza la funci\u00f3n lo_export() La funci\u00f3n lo_unlink() permite borrar un BLOB almacenado Bases de datos en PostgreSQL Veamos el formato qu e utiliza PostgreSQL pa ra visualizar BLOB. La fotograf\u00eda se ha dividido en tres registros, que son las p\u00e1ginas 0, 1 y 2 del BLOB. Los tres registros tienen el mismo loid, lo que significa que son el mismo objeto. Obs\u00e9rvese tambi\u00e9n, que los byte s son desplegados como caracteres de la forma ' \\ddd ', donde ddd son tres d\u00edgitos octales. Para almacenar un BLOB en una tabla de forma directa; es decir, sin utilizar la tabla del sistema pg_largeobject utilizamos el tipo de dato bytea : La columna fotograf\u00eda es de tipo bytea , lo que permite almacenar objetos de gran tama\u00f1o, cerca de 1GB. Para insertar valores en estas columnas, hacemos lo siguiente: La consulta se visualiza como sigue:Se ha recortado la salida para hacer m\u00e1s comprensible la tabla. loid | pageno | data ------+--------+------------------------------------------------------------------ 17425 | 0 | \\377\\330\\377\\340\\000\\020JFIF\\000\\001\\001\\001\\000H\\000H\\000\\000\\37 17425 | 1 se est\u00e1 insertando un BLOB de un solo byte, el car\u00e1cter ASCII cero. En el segundo caso se est\u00e1n insertando 4 bytes, los tres primeros est\u00e1n representados directamente por los caracteres imprimibles ASCII y el tercero, el caracter ASCII 30 octal, como no es imprimible, se escribe en notaci\u00f3n direccion | fotografia--------+-----------+------------ Jorge | Cerezo 55 | \\000 Luis | Encino 67 | abc\\030(2 rows) FUOC 71Z799014MO 53 Bases de datos en PostgreSQL Los caracteres en notaci\u00f3n octal se muestran con un a barra invertida y con dos tal como se escribieron. Es to es debido a que, en re alidad, s\u00f3lo llevan una barra invertida, pero por cuestiones de dise \u00f1o PostgreSQL, las literales BLOB deben escribirse con doble barra invertida. 4.8. Modificaci\u00f3n de la estructura de una tabla Para modificar la estructura de una tabla una vez construida, disponemos de la sentencia SQL alter table . Mediante esta sentencia, podemos lleva r a cabo las operaciones siguientes: Agregar una columna. Eliminar una columna. Fijar el valor por omisi\u00f3n de una columna. Eliminar el valor por omisi\u00f3n de una columna. Renombrar una columna. Renombrar una tabla.demo=# alter table persona add edad int ; ALTER demo=# ALTER TABLE products DROP COLUMN description; demo=# alter table alter edad set default 15; ALTER demo=# alter table persona alter edad drop personal; ALTER FUOC 71Z799014MO 54 Bases de datos en PostgreSQL 5. Manipulaci\u00f3n de datos 5.1. Consultas Las consultas a la base de datos se realizan con el comando select , que se im- plementa en PostgreSQL cumpliendo en gran parte con el est\u00e1ndar SQL: Al igual que MySQL, Postgr eSQL admite la sentencia explain delante de select para examinar qu\u00e9 est\u00e1 ocu rriendo durante una consulta: demo=# select parte, tipo demo-# from productos demo-# parte offset | tipo 1024x876 Monitor | 1024x876 Procesador | 2.4 GHzProcesador | 1.7 GHz Procesador | 3 GHz (5 rows)Notaci\u00f3n Omitiremos las referencias comunes a SQL y s\u00f3lo se mostrar\u00e1n algunas de las po-sibilidades de consulta con PostgreSQL. Por lo que res-pecta a las funciones auxilia-res, se han visto algunas en el apartado de tipos dedatos y, en todo caso, se recomienda la consulta de la documentaci\u00f3n del pro-ducto para las operaciones m\u00e1s avanzadas. Al igual que en el m\u00f3dulo de MySQL, vemos que no aprovecha los \u00edndices (b\u00e1sicamente porque no tenemos ningun o definido). demo=# from productos natural join precios natural join proveedores; QUERY PLAN --------------------------------------------------------------------------------Hash 71Z799014MO 55 Bases de datos en PostgreSQL Veamos como mejorar el rendimiento de este select : 5.2. Actualizaciones e inserciones PostgreSQL cumple con el est\u00e1ndar SQL en todos los sentidos para las senten- cias de actualizaci\u00f3n, in serci\u00f3n y borrado. No define modificadores ni otros mecanismos para estas sentencias. En determinadas cl\u00e1usulas, y para tablas heredadas, es posible limitar el borra- do o la actualizaci\u00f3n a la tabla padre (sin que se propague a los registros de las tablas hijas) con la cl\u00e1usula only :demo=# create index empresa_idx on precios from productos natural join precios natural join proveedores; QUERY PLAN -------------------------------------------------------------------------------- Hash 2 demo=# select * from persona; nombre | direccion---------------------------+------------- Sr. Alejandro Magno | Babilonia Sr. Federico Garc\u00eda Lorca | Granada 65 Juan | Treboles 21 (3 rows) demo=# FUOC 71Z799014MO 56 Bases de datos en PostgreSQL 5.3. Transacciones Definimos transacci\u00f3n como un conjunto de operaciones que tienen significa- do solamente al actuar juntas. PostgreSQL ofrece soporte a transaccio nes, garantizando que ambas operacio- nes se realicen o que no se realice ningun a. Para iniciar una transacci\u00f3n, se uti- liza el comando begin y para finalizarla, commit . Insertamos un registro con el precio de l proveedor Patito pa ra el producto con clave 13. Al cerrar la transacci\u00f3n, los registros inse rtados ya son visibles para todos los usuarios. Si por alguna raz\u00f3n, por ejemplo una ca\u00edda del sistema, no se ejecuta el commit , la transacci\u00f3n se cancela. La forma expl\u00edcita de cancelar una tran- sacci\u00f3n es con el comando | tipo | especificaci\u00f3n | psugerido | clave -----------+----------+----------------+-----------+------- Procesador | 2 Ghz | 32 bits | | 1 Procesador | 2.4 GHz | 32 bits | 35 | 2 Procesador | 1.7 GHz | 64 bits | 205 | 3Procesador | 3 GHz | 64 bits | 560 | 4 RAM | 128MB | 333 MHz | 10 | 5 RAM | 256MB | 400 Mhz | 35 | 6Disco Duro | 80 GB | 7200 rpm | 60 | 7 Disco Duro | 120 GB | 7200 rpm | 78 | 8 Disco Duro | 200 GB | 7200 rpm | 110 | 9Disco Duro | 40 GB | 4200 rpm | | 10 Monitor | 1024x876 | 75 Hz | 80 | 11 Monitor | 1024x876 | 60 Hz | 67 | 12RAM | 512MB | 333 MHz | 60 | 13 (13 rows) insert into precios values ('Patito',13,67);INSERT 17460 1 demo=# commit;Ejemplo Una compra puede ser una transacci\u00f3n que conste dedos operaciones: Insertar un registro del pago del producto Insertar el producto en el inventario. No se debe insertar un produc- to que no se haya pagado, ni pagar un producto que no est\u00e9 en el inventario, por lo tanto, las dos operaciones forman una transacci\u00f3n. El nuevo registro tiene como clave el 13 y, de momento, hasta que finalice la transacci\u00f3n, s\u00f3lo puede verlo el usuario que lo ha insertado. Las transacciones de PostgreSQL No hay ninguna caracter\u00edstica en las transacciones de Post-greSQL que lo diferencien de lo que especifica el est\u00e1n-dar. Ya hemos visto en aparta-dos anteriores que las filas implicadas en una transacci\u00f3n mantienen unas columnas ocultas con informaci\u00f3n acerca de la propia transacci\u00f3n. FUOC 71Z799014MO 57 Bases de datos en PostgreSQL 6. Funciones y disparadores Como algunos de los gestores de bases de datos relacional es, comerciales l\u00edde- res en el mercado, Postgr eSQL puede incorporar m\u00faltiples lenguajes de progra- maci\u00f3n a una base de datos en partic ular. Este hecho permite, por ejemplo: Almacenar procedimientos en la base de datos ( stored procedure ), que po- dr\u00e1n lanzarse cuando convenga. Definir operadores propios. PostgreSQL ofrece por defe cto soporte para su propio lenguaje procedural, el PL/pgSQL. Para instalarlo, basta con invocar el comando createlang des- de el sistema operativo, no desde la l\u00ednea de psql. PostgreSQL tambi\u00e9n soporta otros lenguajes directamente, como PL/Tcl, PL/ Perl y PL/Python. 6.1. Primer programa Veamos el programa HolaMundo en PL/pgSQL: La funci\u00f3n tiene tres partes: El encabezado que define el nombre de la funci\u00f3n y el tipo de retorno. El cuerpo de la funci\u00f3n, que es una cadena de texto (por lo tanto, siempre va entre comillas dobles). La especificaci\u00f3n del lenguaje utilizado. La funci\u00f3n recien creada tiene las mism as caracter\u00edsticas del SQL que permite la creaci\u00f3n de procedimientos y funciones al estilo de los len-guajes tradicionales de progra-maci\u00f3n. Mediante este comando, se ha instalado el lenguaje PL/pgSQL en la base de datos demo . FUOC 71Z799014MO 58 Bases de datos en PostgreSQL Puede solicitarse mediante el comando select : Puede eliminarse mediante el comando drop function . 6.2. Variables Las funciones pueden recibir par\u00e1metros, s\u00f3lo es necesario especificar los tipos de datos. PostgreSQL asig na los nombres a los par\u00e1 metros utilizando la se- cuencia $1, $2, $3... En este ejemplo veremos todas las posibles ma neras de declarar variables en una funci\u00f3n. 6.3. Sentencias La estructura b\u00e1sica de una funci\u00f3n es el bloque , que incluye dos partes, la de- claraci\u00f3n de variables y la secci\u00f3n de sentencias: declare secci\u00f0n de variables begin secci\u00f0n de sentencias create function mi_funcion( int,char) returns int as ' declare -- declaraci\u00f3n de variables locales x int; -- x es de tipo entero y int := 10; -- y tiene valor inicial de 10 z int not null; -- z no puede tomar valores nulos a constant int := 20; -- a es constante b alias for $1; -- El primer par\u00e1metro tiene dos nombres. rename $1 to c; -- Cambia de nombre el segundo par\u00e1metro beginx := y + 30; end; ' language 'plpgsql'; Sentencia Descripci\u00f3n declare begin end Bloque := Asignaci\u00f3nselect into Asignaci\u00f3n desde un select Sentencias sql Cualquier sentencia sqlLa sentencia alias crea un nuevo nombre para una variable. La sentencia rena me cambia el nombre de una variable. FUOC 71Z799014MO 59 Bases de datos en PostgreSQL La sentencia de asignaci\u00f3n utiliza el operador ' :=' para almacenar los resulta- dos de expresiones en variables. Post greSQL proporciona otra sentencia para hacer asignaciones, select. Esta sentenci a debe obtener como resultado un solo valor para que pueda ser al macenado en la variable: La ejecuci\u00f3n de comandos sql como create , drop , insert o update pueden ha- cerse sin ninguna sintaxis especi al. La excepci\u00f3n es el comando select , que re- quiere ejecutarse con el comando perform a fin de que el resultado de la consulta sea descartado. La sentencia execute tambi\u00e9n ejecuta un comando sql pero a partir de una ca- dena de texto. Esta sentencia comporta el problema de que su sintaxis no se verifica hasta la ejecuci\u00f3n. Se puede ut ilizar, por ejemplo, para procesar par\u00e1- metros como comandos sql: El comando exit termina la ejecuci\u00f3n de un bloque. Se utiliza principalmente para romper ciclos. La bifurcaci\u00f3n, o ejecuci\u00f3 n condicional, se realiz a mediante la sentencia if:Sentencia Descripci\u00f3n perform Realiza una llamada a comando sqlexecute Interpreta una cadena como comando sql exit Termina la ejecuci\u00f3n de un bloque return Termina la ejecuci\u00f3n de una funci\u00f3nif Ejecuta sentencias condicionalmente loop Repite la ejecuci\u00f3n de un conjunto de sentencias while Repite un conjunto de sentencias mientrasfor Repite un conjunto de sentencias utilizando una variable de control raise Despliega un mensaje de error a advertencia select into x psugerido from productos where else resultado := 'Negativo';end if; FUOC 71Z799014MO 60 Bases de datos en PostgreSQL Tambi\u00e9n puede utilizarse if con m\u00e1s de dos ramas: Con referencia a los bucles, PL /pgSQL ofrece tres opciones: E l b u c l e loop es infinito, por lo que tiene una estructura muy simple. Por lo general se utiliza con alguna sentencia if para terminarlo: cont := 0; acci\u00f3n cont := cont + 1; end loop; E l b u c l e while incluye la condici\u00f3n al inicio del mismo, por lo que el con- trol de su terminaci\u00f3n es m\u00e1s claro: cont := while cont := cont + 1; end loop; E l b u c l e for permite realizar un n\u00famero de iteraciones controladas por la variable del ciclo: for cont in 1 .. 10 loop -- alguna acci\u00f3n end loop; La sentencia raise permite enviar mensajes de tres niveles de severidad: debug . El mensaje se escribe en la bit\u00e1cora del sistema (logs). notice . El mensaje se escribe en la bit\u00e1cora y en el cliente psql. exception . El mensaje se escribe en la bit\u00e1cora y aborta la transacci\u00f3n.if ( $1 < 0 := 'Cero'; end if; FUOC 71Z799014MO 61 Bases de datos en PostgreSQL El mensaje puede incluir valores de va riables mediante el car\u00e1cter ' %': raise debug 'funcion(): ejecutada con \u00e9xito; tomo por omisi\u00f3n', variable; raise excepci\u00f3n 'El valor % est\u00e1 fuera del rango permitido', variable; 6.4. Disparadores Las funciones deben llamarse expl\u00edcitamente para su ejecuci\u00f3n o para incluir- las en consultas. Sin embargo, se pued e definir que algunas funciones se eje- cuten autom\u00e1ticamente cuando cierto even to tenga lugar en cierta tabla. Estas funciones se conocen como disparadores o triggers y se ejecutan mediante los comandos insert , delete y uptade . Agregamos la tabla historial que almacena los productos de scontinuados cuando se eli- minan de la tabla productos . Para poder utilizar una funci\u00f3n como di sparador, no debe recibir argumentos y debe retornar el tipo especial trigger : La funci\u00f3n est\u00e1 lista para ser utilizada como disparad or, s\u00f3lo es necesario de- finirlo y asociarlo a la tabla y al evento deseado:create table historial( fecha date, parte float(6) procedure respaldar_borrados();La variable old est\u00e1 predefinida por PostgreSQL y se refiere al registro con sus antiguos valores. Para referirse a los nuevos valores, se dispone de la variable new. FUOC 71Z799014MO 62 Bases de datos en PostgreSQL Acabamos de crear un disparador de nombre archivar que se activar\u00e1 cuando se ejecute el comando delete en la tabla productos . El usuario no necesita saber que se debe hacer una copia de seguridad de los registros borrados, se hace au- tom\u00e1ticamente. Al crear el disparador, hemos especifica do \"before delete\" al indicar la opera- ci\u00f3n. PostgreSQL nos permite lanzar el disparador antes o despu\u00e9s ( before, after ) que se efect\u00faen las operaciones. Este mati z es importante, ya que, si este mismo disparador lo ejecutamos despu\u00e9s de la operaci\u00f3n, no veremos ninguna fila en la tabla. Es posible defi nir el mismo disparador para varias operaciones: create trigger archivar beofre delete execute procedure respaldar_borrados(); FUOC 71Z799014MO 63 Bases de datos en PostgreSQL 7. Administraci\u00f3n de PostgreSQL En las tareas administrativas como la inst alaci\u00f3n, la gesti\u00f3n de usuarios, las co- pias de seguridad, restauraciones y el uso de prestaciones internas avanzadas, es donde realmente se aprecian las diferencias entre gestores de bases de datos.PostgreSQL tiene fama de ser m\u00e1s comp lejo de administrar que sus competi- dores de c\u00f3digo abierto, lo que se debe, sobre todo, a que ofrece m\u00e1s prestacio- nes (o m\u00e1s complejas). El contenido de los siguientes aparta dos contempla las opciones de uso co- m\u00fan para la administraci\u00f3n de un serv idor PostgreSQL. Existen tantas al- ternativas que no es posible incluirlas todas en este m\u00f3dulo, por lo que s\u00f3lo se presentar\u00e1n algunos temas de import ancia para el administrador, desde una perspectiva general, que permita obtener una visi\u00f3n global de las po-sibilidades pr\u00e1cticas de las herramientas administrativas. 7.1. Instalaci\u00f3n PostgreSQL est\u00e1 disponible para la mayor\u00eda de distribuciones de GNU/Linux. Su instalaci\u00f3n es tan sencilla como ejec utar el instalador de paquetes corres- pondiente. En Debian, el siguiente proc edimiento instala el servid or y el cliente respecti- vamente: En distribuciones basadas en RPM, los nombres de los paquetes son un poco diferentes: Una vez instalado, se escribir\u00e1 un script de inicio que permite lanzar y apagar el servicio PostgreSQL; de este modo, para iniciar el servicio, deberemos ejecu- tar el siguiente comando: # apt-get install postgresql # apt-get install postgresql-client # rpm -Uvh postgresql-server# rpm -Uvh postgresql # /etc/init.d/postgresql startBibliograf\u00eda El manual de PostgreSQL es la referencia principal que se debe tener siempre a mano para encontrar posibilidades y resolver dudas. En especial se recomienda leer los siguientes cap\u00edtulos: Cap\u00edtulo III. Server Administration. Cap\u00edtulo V. Server Programming. Cap\u00edtulo VII. Internals. De la misma manera, tambi\u00e9n son muy \u00fatiles las listas de correo que se describen en el sitio oficial www.postgresql.org. Notaci\u00f3n Adem\u00e1s del start tambi\u00e9n po- dremos utilizar los par\u00e1metros restart, stop, reload que per- miten reiniciar, detener y re-cargar el servidor (releyendo su configuraci\u00f3n), respectiva-mente. FUOC 71Z799014MO 64 Bases de datos en PostgreSQL Si se desea realizar una instalaci\u00f3n a partir del c\u00f3digo fuente, puede obtenerse del sitio oficial www.postgresql.o rg. A continuaci\u00f3n, se describe el proceso de insta- laci\u00f3n de forma muy simplificada. En la pr\u00e1ctica podr\u00e1n encontrarse algunas di-ferencias; lo m\u00e1s recomendable es l eer cuidadosamente la documentaci\u00f3n incluida en los archivos INSTALL y READ ME. Cualquier duda no resuelta por la documentaci\u00f3n, puede consultarse en la lista de distribuci\u00f3n. Con este proceso se instala la versi\u00f3n 7.4. 6. El archivo se descomprime utilizando tar. Dentro del directorio reci\u00e9n creado se ejecuta configure , que realiza una comprobaci\u00f3n de las dependencias de la aplicaci\u00f3n. Antes de ejecutar configure, debemos instalar todos los paquetes que vamos a necesitar. La compilaci\u00f3n se realiza con make y, finalmente, los binarios producidos se copian en el sistema en los lugares convenientes con make install. Despu\u00e9s de instalados los binari os, se debe cr ear el usuario postgres (responsa- ble de ejecutar el proceso postmaster ) y el directorio donde se almacenar\u00e1n los archivos de las bases de datos. Una vez creado el usuario postgres , \u00e9ste debe inicializar la base de datos: El postmaster ya est\u00e1 listo para ejecutarse manualmente: 7.1.1. Internacionalizaci\u00f3n Por omisi\u00f3n, PostgreSQL no est\u00e1 compila do para soportar mensajes en espa- \u00f1ol, por lo que es necesario compilarlo a partir de las fuentes incluyendo las# tar xzvf postgresql-7.4.6.tar.gz # cd postgresql-7.4.6 # ./configure# make # make install # adduser postgres # cd /usr/local/pgsql# mkdir data # chown postgres data # su - postgres # /usr/local/pgsql/initbd -D /usr/local/pgsql/data # /usr/local/pgsql/postmaster -D /usr/local/pgsql/datainitdb El ejecutable initdb realiza el procedimiento necesario para inicializar la base de datos de postgres, en este caso, en el directorio /usr/local/pgsql/data. Bibliograf\u00eda El proceso de compilaci\u00f3n tiene m\u00faltiples opcionesque se explican en la documentaci\u00f3n incluida con las fuentes. FUOC 71Z799014MO 65 Bases de datos en PostgreSQL siguientes opciones de configuraci\u00f3n, pa ra que tanto el servidor como el clien- te psql adopten la configuraci\u00f3n es tablecida por el programa setlocales y las variables de entorno respectivas: 7.2. Arquitectura de PostgreSQL El siguiente gr\u00e1fico muestra de forma esquem\u00e1tica las entidades involucradas en el funcionamiento normal del gestor de bases de datos: PostgreSQL est\u00e1 basado en una arquitec tura cliente-servidor . El programa ser- vidor se llama postgres y entre los muchos programas cliente tenemos, por ejemplo, pgaccess (un cliente gr\u00e1fico) y psql (un cliente en modo texto). Un proceso servidor postgres puede atender exclusivamente a un solo cliente; es decir, hacen falta tantos procesos servidor postgres como clientes haya. El proceso postmaster es el encargado de ejecutar un nuevo servidor para cada cliente que solicite una conexi\u00f3n. Se llama sitio al equipo anfitri\u00f3n ( host) que almacena un conjunto de bases de datos PostgreSQL. En un sitio se ejecuta solamente un proceso postmaster y m\u00faltiples procesos postgres . Los clientes pueden ejecut arse en el mismo sitio o en equipos remotos conectados por TCP/IP. Es posible restringir el acceso a usuarios o a direcciones IP modificando las opcio- nes del archivo pg_hba.conf, que se en cuentra en /etc/postgresql/pg_hba.conf. Este archivo, junto con /etc/postgresq l/postgresql.conf son particularmente importantes, porque algunos de sus pa de configuraci\u00f3n por defecto# configure --enable-nls -enable-locale FUOC 71Z799014MO 66 Bases de datos en PostgreSQL provocan multitud de problemas al cone ctar inicialmente y porque en ellos se especifican los mecanismos de autenticaci\u00f3n que usar\u00e1 PostgreSQL para veri- ficar las credenciales de los usuarios. Para habilitar la conexi\u00f3n a PostgreSQL desde clientes remotos, debemos verificar el par\u00e1metro tcpip_socket = true en el fichero /etc/postgresql/postgresql.conf . A continuaci\u00f3n, para examinar los m\u00e9to dos de autenticaci\u00f3n y las posibilida- des de conexi\u00f3n de clientes ex ternos, debemos mirar el fichero /etc/postgresql/ pg_hba.conf , donde se explicita la acci\u00f3n qu e hay que emprender para cada co- nexi\u00f3n proveniente de cada host externo, o grupo de hosts . 7.3. El administrador de postgres Al terminar la instalaci\u00f3n, en el sist ema operativo se habr\u00e1 creado el usuario postgres , y en PostgreSQL se habr\u00e1 creado un usuario con el mismo nombre. \u00c9l es el \u00fanico usuario existente en la base de datos y ser\u00e1 el \u00fanico que podr\u00e1 crear nuevas bases de datos y nuevos usuarios. Normalmente, al usuario postgres del sistema operativo no se le permitir\u00e1 el ac- ceso desde un shell ni tendr\u00e1 contrase\u00f1a asigna da, por lo que deberemos con- vertirnos en el usuario root, para despu\u00e9s convertirnos en el usuario postgres y realizar tareas en su nombre: El usuario postgres puede crear nuevas bases de datos utilizando el comando createdb . En este caso, le indicamos que el usuario propietario de la misma ser\u00e1 el usuario postgres: El usuario postgres puede crear nuevos usuarios utilizando el comando createuser : yo@localhost:~$ su Password: demo --owner=postgres create database Se ha creado el usuario yo con permisos para crear bases de datos y sin permisos para crear usuarios. postgres@localhost:~$ createuser yo Shall the new user be allowed to databases? (y/n) y Shall the new users? (y/n) nCREATE USER FUOC 71Z799014MO 67 Bases de datos en PostgreSQL Los siguientes comandos eliminan bases de datos y usuarios, respectivamente: Es recomendable que se agreguen los usua rios necesarios para operar la insta- laci\u00f3n de PostgreSQL, y recurrir, as \u00ed, lo menos posible al ingreso con postgres. Tambi\u00e9n disponemos de sentencias SQL para la creaci\u00f3n de usuarios, grupos y privilegios: Los grupos permiten asignar privilegios a varios usuarios y su gesti\u00f3n es sencilla: Para a\u00f1adir o quitar usuarios de un grupo, debemos usar: 7.3.1. Privilegios Cuando se crea un objeto en PostgreSQL, se le asigna un due\u00f1o. Por defecto, ser\u00e1 el mismo usuario que lo ha creado . Para cambiar el due\u00f1o de una tabla, \u00edndice, secuencia, etc., debemos usar el comando alter table . El due\u00f1o del ob- jeto es el \u00fanico que puede hacer camb ios sobre \u00e9l, si queremos cambiar este comportamiento, deberemos asignar privilegios a otros usuarios. Los privilegios se asignan y eliminan mediante las sentencias grant y revoke . PostgreSQL define los siguientes tipos de operaciones sobre las que podemos dar privilegios: select, demo=# alter user marc password 'marc22'; ALTER USERdemo=# drop user marc; DROP USER create group migrupo; alter group migrupo add user marc, ... ; alter group migrupo drop user marc, ... ; FUOC 71Z799014MO 68 Bases de datos en PostgreSQL Presentamos algunas sentencias de trabajo con pr ivilegios, que siguen al pie de la letra el est\u00e1ndar SQL: 7.4. Creaci\u00f3n de tipos de datos Entre las m\u00faltiples opciones para exte nder PostgreSQL, no s queda a\u00fan por ver la creaci\u00f3n de tipos o dominios (seg\u00fan la nomenclatura del est\u00e1ndar SQL).PostgreSQL prev\u00e9 dos tipos de datos definidos por el administrador: Un tipo de datos compuesto, para utilizar como tipo de retorno en las fun- ciones definidas por el usuario. Un tipo de datos simple, para utilizar en las definicion es de columnas de las tablas. A modo de ejemplo, veamos un tipo compuesto y la funci\u00f3n que lo devuelve: Para el tipo de datos simple, la definici \u00f3n es m\u00e1s compleja, pues se debe indi- car a PostgreSQL funciones que tratan co n este tipo que le permitir\u00e1n usarlo en operaciones, asignaciones, etc. A modo de ejemplo, vamos a crear el tipo \"numero complejo\", tal como lo hace la documentaci\u00f3n de PostgreSQL. En primer luga r, debemos definir la es- tructura donde alma cenaremos el tipo: Despu\u00e9s, las funciones que lo recibir\u00e1n o devolver\u00e1n:grant all privileges on proveedores to marc; grant select on precios to manuel; grant update on precios to group migrupo; revoke all privileges on precios to manuel; grant select on ganacias from from clientes' language sql ; typedef struct Complex { double x; double y; } Complex;Tratar con el tipo de datos simple Habitualmente, las funciones que tratar\u00e1n co n este tipo de datos se escribir\u00e1n en C. FUOC 71Z799014MO 69 Bases de datos en PostgreSQL Ahora estamos en condiciones de de finir las funciones, y el tipo: PG_FUNCTION_INFO_V1(complex_in); Datum complex_in(PG_FUNCTION_ARGS) } = double ); FUOC 71Z799014MO 70 Bases de datos en PostgreSQL El proceso es un poco farragoso, pero compensa por la gran flexibilidad que aporta al SGBD. A continuaci\u00f3n, podr\u00edamos crear algunos operadores para tra- bajar con este tipo (suma, resta, etc. ), mediante los pasos que ya conocemos. La creaci\u00f3n de un dominio en PostgreSQL consiste en un tipo (definido por el usuario o incluido en el SGBD), m\u00e1s un conjunto de restricciones. La sintaxis es la siguiente: Evidentemente, deber\u00edamos ha ber definido el operador complejo_mayor que re- cibiera dos n\u00fameros complejos e indicara si el primero es mayor que el segundo. 7.5. Plantilla de creaci\u00f3n de bases de datos PostgreSQL tiene definidas dos bases de datos de sistema, template0 y template1 (que habremos visto en los ejemplos al listar las bases de datos del gestor), con un conjunto de objetos tales como los tipos de datos que soporta o los lengua- jes de procedimie nto instalados. La base de datos template0 se crea al instalar el servidor, con los objetos por defecto del mismo, y la base de datos template1 se crea a continuaci\u00f3n de la anterior con algunos objetos m\u00e1s particulares del entorno o sistema operativo donde se ha instalado Post greSQL. Esto hace que se a muy recomendable here- dar siempre de template1 (que es el comportamiento por defecto). Estas bases de datos se utilizan como \"padres\" del resto de bases de datos que se crean, de modo que, al crear una nu eva base de datos, se copian todos los objetos de template1 . Ventajas de esta situaci\u00f3n Si queremos a\u00f1adir al g\u00fan objeto (una tabla, un tipo de datos, etc.) a todas las bases de datos, s\u00f3lo tenemos que a\u00f1adirlo a template1 , y el resto de bases de datos que se hayan creado a partir de \u00e9sta lo tendr\u00e1n disponible. Si se instala un lenguaje sobre la base de datos template1, autom\u00e1ticamente todas las bases de datos tambi\u00e9n usar\u00e1n el lenguaje. En las distribuciones de Linux es frecuente que se haya realizado de este modo, por lo que no hay necesidad de instalarlo. Por supuesto, podemos escoge r otra plantilla para crea r bases de datos, especi- fic\u00e1ndola en la sentencia:create domain country_code char(2) not template plantillabdSe ha creado un dominio basado en un tipo definido por el sistema donde la \u00fanica restricci\u00f3n es su longitud. FUOC 71Z799014MO 71 Bases de datos en PostgreSQL 7.6. Copias de seguridad Hacer peri\u00f3dicamente copias de seguridad de la base de datos es una de las ta- reas principales del administrador de cualquier base de datos. En PostgreSQL, estas copias de seguridad se pueden hacer de dos maneras distintas: Volcando a fichero las sentencias SQL necesarias para recrear las bases de datos. Haciendo copia a nivel de fichero de la base de datos. En el primer caso, disponemos de la ut ilidad pg_dump, que realiza un volcado de la base de datos solicit ada de la siguiente manera: pg_dump es un programa cliente de la base de datos (como psql), lo que sig- nifica que podemos utilizar lo para hacer copias de bases de datos remotas, siempre que tengamos privilegios para ac ceder a todas sus tablas. En la pr\u00e1cti- ca, esto significa que debemos ser el usuario administrador de la base de datospara hacerlo. Si nuestra base de datos usa los OID para referencias entre tablas, debemos indi- c\u00e1rselo a pg_dump para que los vuelque tambi\u00e9n ( pg_dump -o ) en lugar de vol- ver a crearlos cuando inserte los datos en el proceso de recuperaci\u00f3n. Asimismo, si tenemos BLOB en alguna de nuestras tablas, tambi\u00e9n debemos indic\u00e1rselo con el par\u00e1metro correspondiente ( pg_dump -b ) para que los incluya en el volcado. Para restaurar un volcado realizado con pg_dump , podemos utilizar directa- mente el cliente psql: Una vez recuperada una base de datos de este modo, se recomienda ejecutar la sentencia analyze para que el optimizador interno de consultas de PostgreS- QL vuelva a calcular los \u00edndices, la densidad de las claves, etc. Las facilidades del sistema operativo Unix , permiten copiar una base de datos a otra en otro servidor de la siguiente manera: Para hacer la copia de seguridad a nivel de fichero, simplemente copiamos los ficheros binarios donde PostgreSQL almacena la base de datos (especificado en$ pg_dump demo > fichero_salida.sql $ psql informaci\u00f3n Hay otras opciones interesan- tes que podemos consultar mediante el par\u00e1metro -h. pg_dump pg_dump realiza la copia a partir de la base de datos de sistema template0 , por lo que tambi\u00e9n se volcar\u00e1n los ti-pos definidos, funciones, etc. de la base de datos. Cuando recuperemos esta base de da-tos, debemos crearla a partir de template0 si hemos perso- nalizado template1 (y no de template1 como lo har\u00eda por defecto la sentencia create database ) para evitar duplicidades. FUOC 71Z799014MO 72 Bases de datos en PostgreSQL tiempo de compilaci\u00f3n, o en paquetes binarios, suele ser /var/lib/postgres/data ), o bien hacemos un archivo comprimido con ellos: El servicio PostgreSQL debe estar parado antes de realizar la copia. A menudo, en bases de datos grandes, es te tipo de volcados origina ficheros que pueden exceder los l\u00edmites del sist ema operativo. En estos casos tendre- mos que utilizar t\u00e9cnicas de creaci\u00f3n de vol\u00famenes de tama\u00f1o fijo en los co- mandos tar u otros con los que estemos familiarizados. 7.7. Mantenimiento rutinario de la base de datos Hay una serie de actividades que el admi nistrador de un sistema gestor de ba- ses de datos debe tener presentes consta ntemente, y que deber\u00e1 realizar peri\u00f3- dicamente. En el caso de PostgreSQL, \u00e9stas se limitan a un mantenimiento y limpieza de los identificadores internos y de las estad\u00edsticas de planificaci\u00f3n de las consultas, a una reindexaci\u00f3n peri\u00f3dic a de las tablas, y al tratamiento de los ficheros de registro. 7.7.1. vacuum El proceso que realiza la limpieza de la base de datos en PostgreSQL se llama vacuum . La necesidad de llevar a cabo procesos de vacuum peri\u00f3dicamente se justifica por los siguientes motivos: Recuperar el espacio de disco perdido en borrados y actualizaciones de datos. Actualizar las estad\u00edsticas de datos utilizados por el planificador de con- sultas SQL. Protegerse ante la p\u00e9rd ida de datos por reutilizac i\u00f3n de identificadores de transacci\u00f3n. Para llevar a cabo un vacuum , ejecutar peri\u00f3dicamente las senten- cias vacuum y analyze . En caso de que haya alg\u00fan problema o acci\u00f3n adicio- nal a realizar, el sistema nos lo indicar\u00e1: -cvzf copia_bd.tar.gz Better vacuum them within may have a wraparound failure. FUOC 71Z799014MO 73 Bases de datos en PostgreSQL 7.7.2. Reindexaci\u00f3n La reindexaci\u00f3n completa de la base de datos no es una tarea muy habitual, pero puede mejorar sustancialmente la velocidad de las consultas complejasen tablas con mucha actividad. 7.7.3. Ficheros de registro Es una buena pr\u00e1ctica mantener archivos de registro de la actividad del servi- dor. Por lo menos, de lo s errores que origina. Dura nte el desarrollo de aplica- ciones puede ser muy \u00fatil disponer tamb i\u00e9n de un registro de las consultas efectuadas, aunque en bases de datos de mucha actividad, disminuye el rendi- miento del gestor y no es de mucha utilidad. En cualquier caso, es conveniente disponer de mecanismos de rotaci\u00f3n de los fi- cheros de registro; es decir, que cada ci erto tiempo (12 horas, un d\u00eda, una sema- na...), se haga una copia de estos ficheros y se empiecen unos nuevos, lo que nos permitir\u00e1 mantener un hist\u00f3rico de \u00e9stos (tantos como ficheros podamos almace-nar seg\u00fan el tama\u00f1o que tengan y nuestr as limitaciones de espacio en disco). PostgreSQL no proporciona directamente utilidades para re alizar esta rota- ci\u00f3n, pero en la mayor\u00eda de sistemas Unix vienen incluidas utilidades como logrotate que realizan esta tarea a partir de una planificaci\u00f3n temporal.VACUUM demo=# se encontraron 0 versiones de filas eliminables y 2 no eliminables en 1 p\u00e1ginas DETAIL: 0 versiones muertas de filas no pueden ser eliminadas a\u00fan. Hubo 0 punteros de \u00edtem sin uso. 0 p\u00e1ginas est\u00e1n completamente vac\u00edas.CPU 0.00 sec. 1 p\u00e1ginas, totalVACUUM demo=# reindex database demo; FUOC 71Z799014MO en PostgreSQL 8. Cliente gr\u00e1fico: pgAdmin3 El m\u00e1ximo exponente de cliente gr\u00e1fico de PostgreSQL es el software pgAdmin3 que tiene licencia \"Artis t License\", aprobada por la FSF. En pgAdmin3 podemos ver y trabajar con casi todos los objetos de la base de datos, examinar sus propiedades y realizar tareas administrativas. A g r e g a d o s C a s t s C o l u m n a sC o n s t r a i n t s Conversiones Bases de datos Dominios F u n c i o n e s G r u p o s\u00cd n d i c e s Lenguajes (PLpgsql, PLpython, PLperl, etc.) Clases de operadores Operadores Servidores PostgreSQL R e g l a sE s q u e m a sS e c u e n c i a s T a b l a s Triggers Tipos de datos U s u a r i o s V i s t a spgAdmin3 est\u00e1 disponible en http://www.pgadmin.org. FUOC 71Z799014MO 75 Bases de datos en PostgreSQL Una caracter\u00edstica interesante de pgAdmin3 es que, cada vez que realizamos al- guna modificaci\u00f3n en un objeto, escrib e la/s sentencia/s SQL correspondiente/s, lo que hace que, adem\u00e1s de una herramienta muy \u00fatil, sea a la vez did\u00e1ctica. pgAdmin3 tambi\u00e9n incorpora funcionalidad es para realizar consultas, exami- nar su ejecuci\u00f3n (como el comando explain ) y trabajar con los datos. Todas estas caracter\u00edsticas hacen de pg Admin3 la \u00fanica herramienta gr\u00e1fica que necesitaremos para trabajar con Post greSQL, tanto desde el punto de vista del usuario como del administrador. Ev identemente, las acciones que pode- mos realizar en cada momento vienen condicionadas por los permisos del usuario con el que nos conectemos a la base de datos. FUOC 71Z799014MO 76 Bases de datos en PostgreSQL Resumen PostgreSQL implementa las caracter\u00edsticas ne cesarias para competir con cual- quier otra base de datos co mercial, con la ventaja de tener una licencia de libre distribuci\u00f3n BSD. La migraci\u00f3n de bases de datos alojadas en productos comerciales a PostgreSQL se facilita gracias a que soporta ampliament e el est\u00e1ndar SQL. PostgreSQL cuenta con una serie de caracter\u00edsticas atractivas como son la herencia de tablas (cla- ses), un rico conjunto de tipos de da tos que incluyen arreglos, BLOB, tipos geom\u00e9tricos y de direcci\u00f3nes de red. PostgreSQL incluye tambi\u00e9n el procesa- miento de transacciones, integridad re ferencial y procedimientos almacenados. En concreto, hay procedimientos docume ntados para migrar los procedimien- tos almacenados desarrollados en lenguajes propietarios de bases de datos co-merciales (PL/SQL) a PL/PGSQL. La API se distribuye para varios lengua jes de programaci\u00f3n como C/C++, Perl, PHP, Python, TCL/Tk y ODBC. Por si esto fuera poco PostgreSQL es ex tensible. Es posible agregar nuevos tipos de datos y funciones al servidor que se comporten como los ya incorporados. Tambi\u00e9n es posible insertar nuevos le nguajes de programaci\u00f3n del lado del servidor para la creaci\u00f3n de procedim ientos almacenados. Todas estas ventajas hacen que muchos programadores lo elijan para el desarrollo de aplicaciones en todos los niveles. Entre sus deficiencias principales po demos mencionar los OID. PostgreSQL est\u00e1 a\u00fan en evoluci\u00f3n, se espera que en futuras versiones se incluyan nuevas caracter\u00edsticas y mejoras al dise\u00f1o interno del SGBD. FUOC 71Z799014MO 77 Bases de datos en PostgreSQL Bibliograf\u00eda Documentaci\u00f3n de PostgreSQL de la dist ribuci\u00f3n: http://www. postgresql.org/docs/ Silberschatz, A.; ed.). Madrid: McGraw Hill. Worsley, John C.; Drake, Joshua D. (2002). Practical PostgreSQL . O'Reilly.Desarrollo de aplicaciones en conexi\u00f3n con bases de datos Marc Gibert Ginest\u00e0 FUOC 71Z799014MO Desarrollo de aplicaciones en conexi\u00f3n con bases de datos \u00cdndice Introducci\u00f3n .............................................................................................. 5 Objetivos ..................................................................................................... 6 1. Conexi\u00f3n y uso de bases de datos en lenguaje PHP .................... 7 1.1. API nativa frente a API con abstracci\u00f3n ........................................... 7 1.2. API nativa en MySQL ........................................................................ 8 1.3. API nativa en PostgreSQL ................................................................. 121.4. Capa de abstracci\u00f3n PEAR::DB ......................................................... 17 1.4.1. Capa de abstracci\u00f3n del motor de la base de datos .............. 191.4.2. Transacciones ........................................................................ 241.4.3. Secuencias ............................................................................. 24 2. Conexi\u00f3n y uso de bases de datos en lenguaje Java .................... 27 2.1. Acceder al SGBD con JDBC ............................................................... 282.2. Sentencias preparadas ....................................................................... 312.3. 34 Bibliograf\u00eda ................................................................................................ 35 FUOC 71Z799014MO 5 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos Introducci\u00f3n Un curso de bases de datos quedar\u00eda incompleto si \u00fanicamente vi\u00e9ramos el funcionamiento y administraci\u00f3n de lo s dos gestores anteriormente comenta- dos. Uno de los principales objetivos de un SGBD es proporcionar un sistemade almacenamiento y consulta de datos al que se puedan conectar las aplica-ciones que desarrollemos. As\u00ed pues, en este cap\u00edtulo vamos a ab ordar este tema, desde una perspectiva totalmente pr\u00e1ctica, intentando expone r las bases para usar los SGBD vistos anteriormente desde algunos de los lenguajes de programaci\u00f3n y conectoresm\u00e1s usados. Los ejemplos proporcionados ser\u00e1n lo m\u00e1s simples posible paracentrarnos en el tema que nos ocupa y no en las particularidades del lenguaje de programaci\u00f3n en s\u00ed. En primer lugar, veremos las herramienta s que ofrece PHP para conectarse con bases de datos, y proporci onaremos algunos ejemplos. A continuaci\u00f3n, pasaremos a examinar la conexi\u00f3n JDBC a SGBD en general y a MySQL y PostgreSQL en particular , proporcionando tambi\u00e9n los ejemplos necesarios. Tambi\u00e9n comentaremos alg\u00fan aspecto avanzado como el de la per- sistencia de la conexi\u00f3n al SGBD. FUOC 71Z799014MO 6 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos Objetivos El objetivo principal de esta unidad es conocer las diferentes t\u00e9cnicas de co- nexi\u00f3n a bases de datos que ofrecen PHP y Java. M\u00e1s concretamente, los objetivos que deber\u00edais alcanzar al acabar el trabajo con la presente unidad son los siguientes: Conocer las posibilidades que PHP y Ja va ofrecen para la conexi\u00f3n y uso de bases de datos en general, y de MySQL y PostgreSQL en particular. Saber adaptar los programas desarrolla dos en estos lenguajes para que uti- licen SGBD. FUOC 71Z799014MO 7 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos 1. Conexi\u00f3n y uso de bases de datos en lenguaje PHP El lenguaje de script PHP se ha popularizado ex traordinariamente durante los \u00faltimos a\u00f1os, gracias a su sencillez y su sintaxis heredada de otros lenguajes como C, Perl o Visual Basic, que casi todos los desarrolladores ya conoc\u00edan en mayor o menor grado. Su f\u00e1cil integraci\u00f3n con los servidores web m\u00e1s populares (Apache, IIS, etc.), sin necesidad de recompila ciones o configuraciones complejas, ha contribui- do tambi\u00e9n a que casi todos los proveedores de espacio web, desarrolladores de aplicaciones de software libre basada s en web, y proveedores de aplicacio- nes empresariales, lo us en para sus productos. A lo largo de su corta hist oria ha progresado signific ativamente, y la versi\u00f3n 5.0 supone un paso adelante en la orientaci\u00f3n a objetos, el tratamiento de excepcio- nes y el trabajo con XML, lo que le hace parecerse en prestaciones a los lenguajes m\u00e1s maduros en el \u00e1mbito empresarial. La versi\u00f3n 5.0 era la m\u00e1s actualizada en el momento de confecci\u00f3n del presente material (finales del 2004). En este cap\u00edtulo, no obst ante, trabajaremos con la versi\u00f3n 4, ya que la versi\u00f3n 5.0 es muy reciente y los cambios que incorpora en cuanto a configuraci\u00f3n, mo- delo de programaci\u00f3n, etc. no les ser\u00e1n fami liares a la mayor\u00eda de los estudiantes con co- nocimientos de PHP. 1.1. API nativa frente a API con abstracci\u00f3n Desde la versi\u00f3n 2.0, PHP ha incorpor ado de forma nativa funciones para la conexi\u00f3n y uso de bases de datos. Al ser la rapidez una de las m\u00e1ximas de estelenguaje, y ante la ventaja de que pr oporciona mecanismos para la carga de librer\u00edas externas, se crearon unas librer\u00edas para cada motor de base de datos, que conten\u00edan las funciones nece sarias para trabajar con \u00e9l. Estas API nativas son diferentes para ca da SGBD, tanto en los nombres de las funciones que se utilizan para crear una conexi\u00f3n a la base de datos, lanzar una consulta, etc., como en el tratamiento de errores, resultados, etc. Aunque se puede argumentar que al usar la API del SGBD concreto que utili- cemos, dispondremos de operadores o funcionalidades espec\u00edficas de ese mo- tor que una librer\u00eda est\u00e1nd ar no puede proporcionar, con el paso del tiempo se ha visto que la utilizaci\u00f3n de estas AP I s\u00f3lo est\u00e1 indicada (y aun as\u00ed, no es recomendable) para aplicac iones que sepamos seguro que no van a cambiar elComo actualmente hay aplicaciones web desarrolladas en PHP que usan la API concreta del SGBD para el que fueron pensadas, las revisaremos eneste apartado. FUOC 71Z799014MO 8 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos SGBD con el que trabajan, ya que la re visi\u00f3n del c\u00f3digo PHP, cuando hay un cambio de SGBD, es muy co stosa y proclive a errores. 1.2. API nativa en MySQL Para trabajar con la API nativa de MySQL en PHP, deberemos haber compilado el int\u00e9rprete con soporte para este SG BD, o bien disponer ya del binario de PHP precompilado con el soporte incorporado. En el caso de tenerlo que compilar, \u00fanicamente deberemos indicar como op- ci\u00f3n --with-mysql . Posteriormente, o en el caso de que ya dispongamos del binario, podemos validar que el soport e para MySQL est\u00e1 incluido correcta- mente en el int\u00e9rprete con la ejecuci\u00f3n del siguiente comando: A partir de aqu\u00ed, PHP proporciona unos par\u00e1metros de configuraci\u00f3n que nos permitir\u00e1n controlar algu nos aspectos del funciona miento de las conexiones con el SGBD, y las propias funciones de trabajo con la base de datos. En cuanto a los par\u00e1metros, deber\u00e1n situarse en el fichero php.ini , o bien configurarse para nuestra aplicaci\u00f3n en concreto desd e el servidor web. Desta- can los siguientes: mysql.allow_persistent : indica si vamos a permit ir conexiones persisten- tes a MySQL. Los valores posibles son true o false . mysql.max_persistent : n\u00famero m\u00e1ximo de conexiones persistentes per- mitidas por proceso. mysql.max_links : n\u00famero m\u00e1ximo de conexion es permitidas por proceso, incluyendo las persistentes. mysql.connect_timeout : tiempo que ha de transcurrir, en segundos, antes de que PHP abandone el intento de conexi\u00f3n al servidor. Las conexiones persistentes son conexiones a la base de datos que se mantienen abiertas para evitar el tiempo de latencia que se pier de en conectar y desconectar. El int\u00e9rprete, al ejecutar la sentencia de co nexi\u00f3n a la base de datos, examina si hay alguna otra co- nexi\u00f3n abierta sin usar, y devuelve \u00e9sta en lugar de abrir una nueva. Lo mismo sucede al desconectar, el int\u00e9rprete pued e realizar la desconexi\u00f3n si hay suficientes conexiones a\u00fan abiertas, o bien mantener la conexi\u00f3n abierta para futuras consultas.$ php -i | grep MySQL Support => enabled$ FUOC 71Z799014MO 9 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos Por lo que respecta a la utilizaci\u00f3n de la API para la conexi\u00f3n y consulta de bases de datos, empezaremos con un ejemplo: En las cinco primeras l\u00edneas se establece la conexi\u00f3n y se selecciona la base de datos con que se va a trabajar. El c\u00f3digo es bastante expl\u00edcito y la mayor\u00eda de erro- res al respecto suelen deberse a una mala configuraci\u00f3n de los permisos del usua-rio sobre la base de datos con la que debe trabajar. Conviene estar muy atento, sobre todo a las direcciones de origen de la co- nexi\u00f3n, ya que, aunque podemos usar localhost como nombre de equipo, si el int\u00e9rprete y el SGBD est\u00e1n en el mismo servidor, suele ocurrir que PHPresuelve localhost al nombre real del equipo e intenta conectarse con esta identificaci\u00f3n. As\u00ed pues, debemos exam inar cuidadosamente los archivos de registro de MySQL y los usuarios y priv ilegios del mismo si falla la conexi\u00f3n.1 <?php 2 // Conectando y eligiendo la base de datos con que vamos a trabajar3 $link = 5 mysql_select_db('mi_database',$link) or die('No he podido acceder a la base de datos');6 7 // Realizando una consulta SQL8 $query Desarrollo de aplicaciones en conexi\u00f3n con bases de datos Para establecer una conexi\u00f3n persis tente, debemos ut ilizar la funci\u00f3n mysql_pconnect() con los mismos par\u00e1metros. A continuaci\u00f3n, se utiliza la funci\u00f3n mysql_query() para lanzar la consulta a la base de datos. La funci\u00f3n mysql_error() es universal, y devuelve el \u00faltimo error ocurrido en el SGBD con nuestra co nexi\u00f3n, o con la conexi\u00f3n $link que le indique- mos como par\u00e1metro. La funci\u00f3n mysql_query() puede devolver los si guientes resultados: FALSE si ha habido un error. Una referencia a una estructura si la sentencia es de consulta y ha tenido \u00e9xito. TRUE si la sentencia es de actualiz aci\u00f3n, borrado o inserci\u00f3n y ha tenido \u00e9xito. La funci\u00f3n mysql_affected_rows() nos permite conocer el n\u00famero de filas que se han visto afectadas por sentencias de actualizaci\u00f3n, borrado o inserci\u00f3n. La funci\u00f3n mysql_num_rows() nos permite conocer el n\u00famero de filas de- vuelto por sentencias de consulta. Una vez obtenido el recurso a partir de los resultados de la consulta, PHP pro- porciona multitud de formas de iterar sobre sus resultados o de acceder a uno de ellos directamente. Comentamos las m\u00e1s destacadas: $fila = mysql_fetch_array($recurso, <tipo_de_array>) Esta funci\u00f3n va iterando so bre el recurso, devolviendo una fila cada vez, hasta que no quedan m\u00e1s filas, y devuelve FALSE. La forma del array devuelto de- pender\u00e1 del par\u00e1metro <tipo_de_array> que puede tomar estos valores: - MYSQL_NUM: devuelve un array con \u00edndices num\u00e9ricos para los campos. Es decir, en $fila[0] tendremos el primer campo del SELECT, en $fi- la[1] , el segundo, etc. - MYSQL_ASSOC: devuelve un array asociativo en el que los \u00edndices son los nombres de campo o alias que hayamos indicado en la sentencia SQL. - MYSQL_BOTH: devuelve un array con los dos m\u00e9todos de acceso.Utilidad de la sentencia de conexi\u00f3n Hemos proporcionado la sentencia SQL a la funci\u00f3n y el enlace nos ha devuelto la sentencia de conexi\u00f3n. Esta funcionalidad es absolutamen-te necesaria si se trabaja con varias conexiones simult\u00e1nea-mente, si \u00fanicamente hay una conexi\u00f3n establecida en el script , este par\u00e1metro es opcional. FUOC 71Z799014MO 11 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos Recuperando el ejemplo inicia l, entre las l\u00edneas 7 y 21: $objeto = mysql_fetch_object($recurso) Esta funci\u00f3n va iterando sobre los resultados, de volviendo un objeto cada vez, de manera que el acceso a los datos de cada campo se realiza a trav\u00e9s de las propiedades del obje to. Al igual que en el array asociativo, hay que vigilar con los nombres de los campos en consulta, evitando que devuelva campos con el mismo nombre fruto de combinaciones de varias tablas, ya que s\u00f3lo podremos acceder al \u00faltimo de ellos: Volvemos sobre el ejemplo inicial $valor = mysql_result($recurso,$numero_de_fila,$numero_de_campo) Esta funci\u00f3n consulta dire ctamente un valor de un campo de una fila espe- cificada. Puede ser \u00fatil si queremos conocer un resultado sin necesidad de realizar bucles innecesarios. Eviden temente, hemos de saber exactamente d\u00f3nde se encuentra. $exito = mysql_data_seek($recurso,$fila) Esta funci\u00f3n permite mover el puntero de ntro de la hoja de resultados re- presentada por $recurso , hasta la fila que dese emos. Puede ser \u00fatil para7 // Realizando una consulta SQL 8 $query = 'SELECT FROM mi_tabla'; Mostramos resultados 13 while ($line = mysql_fetch_array($result, MYSQL_BOTH)) {14 echo \"\\t<tr>\\n\"; } 18 echo \"<td>Nombre: $line['nombre']</td>\"; 19 echo \"\\t</tr>\\n\";20 } 21 echo \"</table>\\n\"; 7 // Realizando una consulta SQL 8 $query // los HTML12 echo \"<table>\\n\"; 13 while ($object = mysql_fetch_array($result, echo \"</table>\\n\"; FUOC 71Z799014MO 12 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos avanzar o para retroceder y volver a recorrer la hoja de resultados sin tener que ejecutar la sentencia SQL de nuevo. Si la fila solicitada no existe en la hoja de resultados, el resultado ser\u00e1 FA LSE, al igual que si la hoja no con- tiene ning\u00fan resultado. Es decir, el valor de $fila debe estar entre 0 (la pri- mera fila) y mysql_num_rows()-1 , excepto cuando no hay ning\u00fan resultado, en cuyo caso devolver\u00e1 FALSE. Finalmente, comentaremos las funcione s de liberaci\u00f3n y desconexi\u00f3n. En el primer caso, PHP realiza un excelente trabajo liberando recursos de memoria cuando la ejecuci\u00f3n en curso ya no los va a utilizar m\u00e1s. Aun as\u00ed, si la consulta devuelve una hoja de datos muy grande, puede ser conveniente liberar el re- curso cuando no lo necesitemos. Por lo que respecta al cierre de la conexi\u00f3n, tampoco suele ser necesario, ya que PHP cierra todas las conexiones al fi nalizar la ejecuci\u00f3n y, adem\u00e1s, el cie- rre siempre est\u00e1 condiciona do a la configuraci\u00f3n de las conexiones persisten- tes. Tal como ya hemos comentado, si activamos las conexiones persistentes (o bien hemos conectado con mysql_pconnect ), esta funci\u00f3n no tiene nin- g\u00fan efecto y, en todo caso, ser\u00e1 PHP quien decida cu\u00e1ndo se va a cerrar cada conexi\u00f3n. Ya hemos comentado que las API espec\u00ed ficas para cada motor incluyen un conjunto de funciones que pod\u00eda ayudar a trabajar con sus aspectos particula- res, a continuaci\u00f3n, : estas funciones recibe n como par\u00e1metro un $ re- curso y un \u00edndice de campo dentro de la consulta ejecutada y devuelven informaci\u00f3n sobre el campo; en conc reto, sus restriccion es, nombre, tabla a la que corresponden y tipo de campo. Pueden ser muy \u00fatiles para trabajar con consultas gen\u00e9ricas so bre bases de datos y/o campos que no conoce- mos al realizar el script . mysql_insert_id : esta funci\u00f3n devuelve el \u00faltimo identificador obteni- do de una inserci\u00f3n en un campo autoincremental. mysql_list_dbs , mysql_list_tables , mysql_list_fields : con dis- estas funciones permiten consultar datos de administra- ci\u00f3n del motor de la base de datos. 1.3. API nativa en PostgreSQL Para trabajar con la API nativa de Po stgreSQL en PHP, deberemos haber com- pilado el int\u00e9rprete con so porte para este SGBD, o bien disponer ya del binario de PHP precompilado con el soporte incorporado. Bibliograf\u00eda Hay otras funciones m\u00e1s espec\u00edficas para obtener informaci\u00f3n sobre el cliente que origina la conexi\u00f3n, o sobre el propio servidor donde se est\u00e1 ejecutando. Conviene consultar la documentaci\u00f3n para obtener informaci\u00f3n sobre usos m\u00e1s avanzados de esta API. FUOC 71Z799014MO 13 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos En el caso de tenerlo que compilar, \u00fanicamente debemos indicar como opci\u00f3n --with-pgsql . Posteriormente, o en el caso de que ya dispongamos del bina- rio, podemos validar que el soporte para PostgreSQL est\u00e1 incluido correcta- mente en el int\u00e9rprete con la ejecuci\u00f3n del siguiente comando: A partir de aqu\u00ed, PHP proporciona unos par\u00e1metros de configuraci\u00f3n que nos permitir\u00e1n controlar algu nos aspectos del funciona miento de las conexiones con el SGBD, y las propias funciones de trabajo con la base de datos. En cuanto a los par\u00e1metros, deber\u00e1n situarse en el fichero php.ini o bien configurarse para nuestra aplicaci\u00f3n en concreto desd e el servidor web. Desta- can los siguientes: pgsql.allow_persistent : indica si vamos a permitir el uso de conexio- nes persistentes. Los valores son true o false . pgsql.max_persistent : n\u00famero m\u00e1ximo de conexiones persistentes permitidas por proceso. pgsql.max_links : n\u00famero m\u00e1ximo de conexiones permitidas por proce- so, incluyendo las persistentes. pgsql.auto_reset_persistent : detecta autom\u00e1ticamente conexiones persistentes cerra das y las elimina. Por lo que respecta a la utilizaci\u00f3n de la API para la conexi\u00f3n y consulta de bases de datos, reproduciremos el anterior ejemplo: $ php -i | grep PostgreSQLPostgreSQLPostgreSQL Support => enabledPostgreSQL(libpq) Version => 7.4.6$ Este par\u00e1metro disminuye ligeramente el rendimiento del sistema. 1 <?php 2 // Conectando y eligiendo la base de datos con que vamos a trabajar3 $link = echo 'Conexi\u00f3n establecida'; FUOC 71Z799014MO 14 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos En las diez primeras l\u00edneas, establec emos la conexi\u00f3n y comprobamos que se ha realizado correctamente. A diferencia de MySQL, la selecci\u00f3n de la base de datos se hace en el momento de la conexi\u00f3n. En cambio , la comprobaci\u00f3n de la conexi\u00f3n es un poco m\u00e1s complicada. Para establecer una conexi\u00f3n persis tente, debemos ut ilizar la funci\u00f3n pg_pconnect() con los mismos par\u00e1metros. A continuaci\u00f3n, se utiliza la funci\u00f3n pg_query() para lanzar la consulta a la base de datos. Para comprobar errores, la API de PostgreSQL distingue entre un error de co- nexi\u00f3n, y errores sobre los recursos devu eltos. En el primer caso, deberemos usar pg_connection_status() , mientras que en el segundo podemos optar por pg_last_error() o bien pg_result_error($recurso) para obtener el mensaje de error que pueda haber devuelto un recurso en concreto.7 } else { 8 die 'No puedo conectarme';9}1011 // Realizando una consulta SQL12 ?> Recordad La mayor\u00eda de los errores en este aspecto se originan por una mala configuraci\u00f3n de los permisos de los usuarios en el SGBD. Una forma de probarlo que suele ofrecer m\u00e1s informa-ci\u00f3n es intentar la conexi\u00f3n con el cliente de la base de datos desde la l\u00ednea de comandos, es-pecificando el mismo usuario, base de datos y contrase\u00f1a que estamos utilizando en el script. Utilidad de la sentencia de conexi\u00f3n Aqu\u00ed se aplican los mismos consejos que d\u00e1bamos en el apartado anterior, y las mismas consideraciones en cuanto al par\u00e1metro $link y su opcio- nalidad si \u00fanicamente tenemos una conexi\u00f3n establecida con el mismo usuario y contrase\u00f1a. FUOC 71Z799014MO 15 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos La funci\u00f3n pg_query() puede devolver los si guientes resultados: FALSE si ha habido un error. Una referencia a una estructura si la sentencia ha tenido \u00e9xito. La funci\u00f3n pg_affected_rows($recurso) nos permite conocer el n\u00famero de filas que se han visto afectadas por sentencias de actua lizaci\u00f3n, borrado o inserci\u00f3n. Esta funci\u00f3n deber\u00e1 recibir como par\u00e1metro el recurso devuelto por la funci\u00f3n pg_query() . La funci\u00f3n pg_num_rows($recurso) nos permite conocer el n\u00famero de filas devuelto por sentencias de consulta. Una vez obtenido el recurso a partir de los resultados de la consulta, PHP pro- porciona multitud de formas de iterar sobre sus resultados o de acceder a uno de ellos directamente. Comentamos las m\u00e1s destacadas: $fila = pg_fetch_array($recurso, <tipo_de_array>) Esta funci\u00f3n va iterando sobre el re curso, devolviendo una fila cada vez, hasta que no quedan m\u00e1s filas y devuelve FALSE. La forma del array de- vuelto, depender\u00e1 del par\u00e1metro <tipo_de_array> que puede tomar estos valores: PG_NUM: devuelve un array con \u00edndices num\u00e9ricos para los campos. Es de- cir, en $fila[0] tendremos el primer campo del SELECT, en $fila[1] , el segundo, etc. PG_ASSOC: devuelve un array asociativo donde los \u00edndices son los nom- bres de campo o alias que hayamo s indicado en la sentencia SQL. PG_BOTH: devuelve un array con los dos m\u00e9todos de acceso. Recuperando el ejemplo inicial, entre las l\u00edneas 11 y 24: 11 // Realizando una consulta SQL 12 $query = * . los 15 echo \"<table>\\n\";16 while ($line = pg_fetch_array($result, PGSQL_BOTH)) { 17 echo \"\\t<tr>\\n\"; 20 } 21 echo \"\\t</tr>\\n\"; 23 } 24 echo \"</table>\\n\"; FUOC 71Z799014MO 16 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos $objeto = pg_fetch_object($recurso) Esta funci\u00f3n va iterando sobre los resultados, de volviendo un objeto cada vez, de forma que el acceso a los datos de cada campo se realiza por mediode las propiedades del obje to. Al igual que en el array asociativo, hay que vigilar con los nombres de los campos en consulta, evitando que devuelva campos con el mismo nombre fruto de combinaciones de varias tablas, yaque s\u00f3lo podremos acceder al \u00faltimo de ellos. Volvemos sobre el ejemplo inicial Podemos pasar a la funci\u00f3n pg_fetch_object() un segundo par\u00e1metro para indicar la fila conc reta que queremos obtener: $resultado = pg_fetch_all($recurso)Esta funci\u00f3n devuelve toda la hoja de datos correspondiente a $recurso ; es decir, una array con todas las filas y column as que forman el resultado de la consulta. $exito = pg_result_seek($recurso,$fila) Esta funci\u00f3n permite mover el puntero de ntro de la hoja de resultados re- presentada por $recurso hasta la fila que dese emos. Deben tomarse las mismas consideracione s que en la funci\u00f3n mysql_data_seek() . En cuanto a la liberaci\u00f3n de recursos y la desconexi\u00f3n de la base de datos, es totalmente aplicable lo ex plicado para MySQL, incluy endo los aspectos rela- cionados con las conexiones persistentes. Al igual que en MySQL, PHP tambi\u00e9n proporciona funciones espec\u00edficas para trabajar con algunos aspectos particulares de PostgreSQL. Al tener \u00e9ste m\u00e1s funcionalidad que se aleja de lo est\u00e1ndar debido a su soporte a objetos, estas11 // Realizando una consulta SQL 12 $query pg_last_error()); // Mostramos los resultados 15 \"<table>\\n\";16 while ($object = pg_fetch_array($result, echo \"</table>\\n\"; FUOC 71Z799014MO 17 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos funciones cobrar\u00e1n m\u00e1s importancia. A continuaci\u00f3n comentamos las m\u00e1s destacadas: pg_field_name , pg_field_num funciones proporcionan informac i\u00f3n sobre los campos que integran una consulta. Sus nombres son suficiente mente expl\u00edcitos acerca de su co- metido. pg_last_oid : esta funci\u00f3n nos devuelve el OID obtenido por la inserci\u00f3n de una tupla si el recurso que recibe como par\u00e1metro es el correspondiente a una sentencia INSERT. En caso contrario (entre otras) facilitan el tra- bajo con objetos grandes (LOB) en PostgreSQL. Las funciones pg_lo_import y pg_lo_export pueden tomar ficheros como par\u00e1metros, facilitando la inserci\u00f3n de objetos binarios en la base de datos. 1.4. Capa de abstracci\u00f3n PEAR::DB El PEAR (PHP extension and application repository ) se define como un marco de trabajo y un sistema de distribuci\u00f3n de librer\u00edas reutilizables para PHP. Es si- milar en concepto al CPAN ( comprehensive perl archive network ) del lenguaje Perl o al PyPI ( Python package index ) de Python. El PEAR pretende proporcionar una libre r\u00eda estructurada de c\u00f3digo y librer\u00edas reutilizables, mantener un sistema para proporcionar a la comunidad herra- mientas para compartir sus desarrollos y fo mentar un estilo de codificaci\u00f3n es- t\u00e1ndar en PHP. PEAR, debe ser el primer recurso para solventar cualquier carencia detectada en las funciones nativas de PHP. Como buena pr\u00e1ctica general en el mundo del software libre, siempre es mejor usar, aprender o me jorar a partir de lo Nota Hay otras funciones que tienen el mismo cometido que combinaciones de algunas de las funciones comentadas anteriormente (por ejemplo, pg_select o pg_insert , pg_copy_from ), pero que no se comentan en este material por su extensi\u00f3n y por su poco uso. PEAR Si nuestra instalaci\u00f3n de PHP es reciente, ya dispondremos de PEAR instalado (a no ser que lo hayamos compilado con la opci\u00f3n --without-pear . FUOC 71Z799014MO 18 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos han hecho otros, que proponernos reinve ntar la rueda. Adem\u00e1s, si hacemos mejoras a las librer\u00edas que usemos de PEAR, siempre podemos contribuir a esos cambios mediante las herramientas que nos proporciona. En cierta forma, PEAR se comporta como un gestor de paquetes m\u00e1s de los que pueden incorporar las distribuciones GNU/Linux m\u00e1s recientes (como apt, yum o YOU). Este gestor de paquetes se compone del ejecutable 'pear' al que podemos proporcionar un conjunto de par\u00e1metros seg\u00fan las acciones que de- seemos realizar: PEAR (y PHP) ya viene con un conjunto de paquetes instalados, lo que se de- nomina el PFC (PHP foundation classes ). Estos paquetes proporcionan a PHP la m\u00ednima funcionalidad necesaria para que PEAR fu ncione y para que dispon- gamos de las librer\u00edas b\u00e1sicas de PHP. A continuaci\u00f3n presentamos las opciones m\u00e1s habituales de PEAR:$ pear 1.1.1 stable Comando Resultado pear list Lista de los paquetes instalados. pear list-all Lista de todos los paquet es disponibles en PEAR. pear list-upgradesLista de los paquetes instalados con actualizaci\u00f3n disponible. pear info <paquete> Proporciona informaci\u00f3n sobre el paquete. pear install <paquete> Descarga e instala el paquete. pear search <texto> Busca paquetes en el repositorio PEAR. pear upgrade <paquete> Actualiza el paquete si es necesario. pear upgrade-allActualiza todos los paquetes instalados con actualizaci\u00f3n disponible. pear uninstall <paquete> Desinstala el paquete. FUOC 71Z799014MO 19 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos 1.4.1. Capa de abstracci\u00f3n del motor de la base de datos Parece evidente que, para la inmensa mayor\u00eda de aplicaciones basadas en PHP, el uso de su librer\u00eda nativa de acceso a bases de datos va a condicionar el SGBDa usar con la aplicaci\u00f3n. En aplicaciones comerciales, o que no pueden ni de- sean estar cerradas a un \u00fanico motor, no ser\u00e1 imprescindible disponer de unas funciones que encapsulen la comunicaci \u00f3n con el SGBD y que sean indepen- dientes de \u00e9ste en las interfaces que o frecen, mientras que internamente lla- mar\u00e1n a las funciones nativas del SGBD concreto con que se est\u00e9 trabajando en cada momento. As\u00ed pues, y buscando en PEAR, encontra mos el m\u00f3dulo 'DB', una capa de abs- tracci\u00f3n y encapsulamiento de la comunicaci\u00f3n con el SGBD. Al tener que in- corporar todas las funcionalidades de lo s motores que soporta, el resultado ser\u00e1 siempre el m\u00ednimo conjunto de presta ciones comunes a todos los SGBD. Las prestaciones m\u00e1s destacadas que ofrece la versi\u00f3n actual 1.6.8 son las siguientes: Interfaz orientada a objetos. Una sintaxis com\u00fan para identifi car SGBD y cadenas de conexi\u00f3n. Emulaci\u00f3n de \"sentencias preparadas\" en los motores que no las soportan. C\u00f3digos de errores comunes. Emulaci\u00f3n de secuencias o autoincrem entos en SGBD que no los soportan. S o p o r t e p a r a t r a n s a c c i o n e s . Interfaz para obtener informaci\u00f3n del metadato (informaci\u00f3n sobre la ta- bla o la base de datos). Compatible con PHP4 y PHP5. Motores soportados: mysqli, odbc, pgsql, sqlite y sybase. Versiones La versi\u00f3n 1.6.8. era la m\u00e1s actualizada en el momento de elaboraci\u00f3n de este material (finales de 2004). 1 <?php 2 // Incluimos la librer\u00eda una vez instalada mediante PEAR 3 require_once 'DB.php'; 45 // Creamos la conexi\u00f3n a la base de datos, en este caso PostgreSQL 6 $db =& DB::connect('pgsql://usuario:password@servidor/basededatos'); 78 // Comprobamos error en la if (DB::isError($db)) { 10 die($db->getMessage());11} 12 FUOC 71Z799014MO 20 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos La estructura del c\u00f3digo y hasta la sint axis de las sentencias es similar a los ejemplos nativos vistos anteriormente, exceptuando las partes de las senten- cias que hac\u00edan referencia al moto r de base de datos en particular. A continuaci\u00f3n, vamos a avanzar por el c\u00f3digo ampliando la informaci\u00f3n so- bre cada paso. La conexi\u00f3n se especifica mediante una sintaxis de tipo DSN ( data source na- me). Los DSN admiten multitud de vari antes, dependiendo del motor al que nos conectemos, pero en casi todos los casos, tienen la forma siguiente: C o n e x i \u00f3 n a M y S Q L mysql://usuario:password@servidor/basededatos Conexi\u00f3n a MySQL a trav\u00e9s de un socket UNIX: mysql://usuario:password@unix(/camino/al/socket)/basededatos Conexi\u00f3n a PostgreSQL pgsql://usuario:password@servidor/basededatos Conexi\u00f3n a PostgreSQL en un puerto espec\u00edfico: pgsql://usuario:password@tcp(servidor:1234)/basededatos En cualquier llamada a un m\u00e9todo de l paquete DB, \u00e9ste puede devolver el objeto que le corresponde (una hoja de resultados, un objeto representando la conexi\u00f3n, etc.) o bien un objeto qu e represente el error que ha tenido la llamada. De \u00e9sta manera, para compro bar los errores que puede originar cada sentencia o intento de conexi\u00f3n, bastar\u00e1 con comprobar el tipo del objeto devuelto:13// Realizamos la consulta: 14$res =& $db->query('SELECT * FROM clients'); realizado correctamente la hoja de base de datos 30$db->disconnect(); 31?> motorphp://usuario:contrase\u00f1a@servidor/basededatos?opcion=valor FUOC 71Z799014MO 21 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos La clase DB_Error ofrece varios m\u00e9todos. A pe sar de que el m\u00e1s utilizado es getMessage() , getDebugInfo() o getCode() pueden ampliar la informa- ci\u00f3n sobre el error. Para realizar consultas, disponem os de dos mecanismos diferentes: Enviar la consulta directamente al SGBD. Indicar al gestor que prepare la ejec uci\u00f3n de una sentencia SQL y posterior- mente indicarle que la ejecute una o m\u00e1s veces. En la mayor\u00eda de los casos, optaremo s por el primer mecanismo y podremos proceder como sigue: En ocasiones nos podemos encontrar ejecutando la misma consulta varias ve- ces, con cambios en los datos o en el va lor de las condicione s. En estos casos, es m\u00e1s indicado utilizar el segundo mecanismo. Supongamos que tenemos que insertar un conjunto de clientes en nuestra base de datos. Las sentencias que ejecutar\u00eda mos ser\u00edan parecidas a las siguientes: En lugar de esto, podemos indicarle al motor de la base de datos que prepare la sentencia, del modo siguiente: Utilizaremos la variable $sth que nos ha devuelto la sentencia prepare cada vez que ejecutemos el query :8 // Comprobamos error en la conexi\u00f3n 9 if (DB::isError($db)) 13 // =& $db->query('SELECT * FROM clients'); Ejemplo Pensemos en un conjunto de actualizaciones o inserciones seguidas o en un conjunto de consultas donde vamos cam-biando un intervalo de fechas o el identificador del clientesobre el que se realizan. INSERT INTO Clientes (nombre, nif) VALUES ('Jos\u00e9 Antonio Desarrollo de aplicaciones en conexi\u00f3n con bases de datos Tambi\u00e9n podemos pasar una array con todos los valores: Y tenemos la opci\u00f3n de pasar una array de dos dimensiones con todas las sen- tencias a ejecutar, mediante el m\u00e9todo executeMultiple() : A continuaci\u00f3n, examinarem os los m\u00e9todos de iterar sobre los resultados. En el ejemplo inicial hemo s utilizado la funci\u00f3n fetchRow() de la manera si- guiente: Pero tambi\u00e9n disponem os de la funci\u00f3n fetchInto(), que recibe como pa- r\u00e1metro el array donde queremos que se almacene el resultado: Tanto fetchRow() como fetchInto() aceptan otro par\u00e1metro para indicar el tipo de estructura de datos que va a almacenar en $row : DB_FETCHMODE_ORDERED: es la opci\u00f3n por defecto. Almacena el resul- tado en una array con \u00edndice num\u00e9rico. DB_FETCHMODE_ASSOC: almacena el resultado en una array asociativa en el que las claves son el nombre del campo. DB_FETCHMODE_OBJECT: almacena el resultado en un objeto donde dis- pondremos de atributos con el nombre de cada campo para obtener el valor en cada iteraci\u00f3n.$datos = } FUOC 71Z799014MO 23 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos o bien: La funci\u00f3n fetchInto() acepta un tercer par\u00e1metro para indicar el n\u00famero de fila que queremos obtener, en caso de que no deseemos iterar sobre la pro- pia funci\u00f3n: Hay otros m\u00e9todos para obtener diferent es vistas del resultado como los si- guientes: getAll() : obtiene una array de dos dimensiones con toda la hoja de resul- tados. Tendr\u00eda una forma como la siguiente:21 // Iteramos sobre los resultados en modo asociativo 22 while ($res->fetchInto (($row,DB_FETCHMODE_ASSOC)) { 23 echo $row['nombre'] 25 } 21 // Iteramos sobre los resultados en modo objeto 22 while ($res->fetchInto (($row,DB_FETCHMODE_OBJECT)) { 23 echo $row->nombre . \"\\n\";25 } la tercera fila consulta22 $res->fetchInto ($row,DB_FETCHMODE_ASSOC,3); aplicaciones en conexi\u00f3n con bases de datos getRow() : devuelve s\u00f3lo la primera fila de la hoja de resultados. getCol() : devuelve s\u00f3lo la columna indica da de la hoja de resultados. De la misma manera que en las librer \u00edas nativas, hay m\u00e9todos que proporcio- nan informaci\u00f3n sobre la consulta en s\u00ed: numRows() : n\u00famero de filas de la hoja de resultados. numCols() : n\u00famero de columnas de la hoja de resultados. affectedRows() : n\u00famero de filas de la tabl a afectadas por la sentencia de actualizaci\u00f3n, inserci\u00f3n o borrado. 1.4.2. Transacciones PEAR::DB proporciona mecanismos para tratar las transacciones independien- temente del SGBD con que trabajemos. Como ya hemos comentado, la operativ a con las transaccion es est\u00e1 relaciona- da con las sentencias begin , commit y rollback de SQL. PEAR::DB envuelve estas sentencias en llamadas a m\u00e9todos suyos, del modo siguiente: 1.4.3. Secuencias PEAR::DB incorpora un mecanismo propio de secuencias (AUTO_INCREMENT en MySQL), que es independiente de la base de datos utilizada y que puede ser de gran utilidad en identifica dores, claves primarias, etc. El \u00fanico requisito es que se usen sus m\u00e9todos de trabajo con secuencias, siempre que se est\u00e9 trabajando con esa base de datos; es decir, no se debe crear la secuencia en el SGBD y, despu\u00e9s, tr abajar con ella con los m\u00e9todos que ofre- ce PEAR::DB. Si la secuencia la creamos mediante la base de datos, entoncesdeberemos trabajar con ella con las fu nciones extendidas de SQL que nos pro- porcione ese SGBD (en PostgreSQL la funci\u00f3n nextval() o en MySQL la in- serci\u00f3n del valor 0 en un campo AUTO_INCREMENT).// Desactivamos el comportamiento de COMMIT autom\u00e1tico. $db->autocommit(false);.. { $db->commit(); } else { $db->rollback(); }Atenci\u00f3n En MySQL s\u00f3lo funcionar\u00e1 el soporte de transacciones si la base de datos est\u00e1 almace-nada con el mecanismo InnoDB. En PostgreSQL no hay restric- ci\u00f3n alguna. En ning\u00fan sitio... ... se hace un begin . Al desac- tivar el autocommit (que est\u00e1 activado por defecto) todas las sentencias pasar\u00e1n a formar parte de una transacci\u00f3n, que se registrar\u00e1 como definitivaen la base de datos al llamar al m\u00e9todo commit() o bien se desechar\u00e1 al llamar al m\u00e9todo rollback() , volviendo la base de datos al estado en el que estaba despu\u00e9s del \u00faltimo commit() . FUOC 71Z799014MO 25 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos Disponemos de las siguientes funcio nes para trabajar con secuencias: createSequence($nombre_de_secuencia) : crea la secuencia o devuel- ve un objeto DB_Error en caso contrario. nextId($nombre_de_secuencia) : devuelve el siguiente identificador de la secuencia. dropSequence($nombre_de_secuencia) : borra la secuencia. Finalmente, en el aspecto relacionad o con los metadatos de las tablas, PEAR::DB ofrece la funci\u00f3n tableInfo(), que proporciona informaci\u00f3n de- tallada sobre una tabla o sobre las column as de una hoja de resultados obteni- da de una consulta. O bien: El resultado ser\u00e1 similar al siguiente: // Creamos $tmp = $db->createSequence('miSecuencia');if = $db->nextId('mySequence');if (DB::isError($id)) { die($id->getMessage()); } // Usamos en 26 aplicaciones en conexi\u00f3n con bases de datos [type] null )Funcionalidades Hay funcionalidades m\u00e1s avan- zadas de esta librer\u00eda que au-mentan continuamente. De todas formas, con las pre-sentadas basta para identificar las ventajas de trabajar con una capa de abstracci\u00f3n del motor de base de datos donde se al-macenan los datos de nuestra aplicaci\u00f3n. FUOC 71Z799014MO 27 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos 2. Conexi\u00f3n y uso de bases de datos en lenguaje Java El acceso a bases de datos desde Java se realiza mediante el est\u00e1ndar JDBC ( Java data base conectivity ), que permite un acceso unif orme a las bases de datos in- dependientemente del SGBD. De esta ma nera, las aplicacione s escritas en Java no necesitan conocer las es pecificaciones de un SGBD en particular, basta con comprender el funcionamien to de JDBC. Cada SGBD que quiera utilizarse con JDBC debe contar con un adaptador o controlador. La estructura de JDBC se puede expresar gr\u00e1ficamente como sigue: Hay drivers para la mayor\u00eda de SGBD, tanto de software libre como de c\u00f3digo abierto. Adem\u00e1s, hay drivers para trabajar con otros tipos de datos (hojas de c\u00e1lculo, ficheros de texto, etc.) como si fueran SGBD sobre los que podemosrealizar consultas SQL. Para usar la API JDBC con un SGBD en particular, necesitaremos el driver con- creto del motor de base de datos, que me dia entre la tecnolog\u00eda JDBC y la base de datos. Dependiendo de m\u00faltiples factores, el driver puede estar escrito com- pletamente en Java, o bien haber usado m\u00e9todos JNI ( Java native interface ) para interactuar con otros lenguajes o sistemas. La \u00faltima versi\u00f3n de desarrollo de la API JDBC proporciona tambi\u00e9n un puen- te para conectarse a SGBD que dispongan de drivers ODBC ( open database FUOC 71Z799014MO 28 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos connectivity ). Este est\u00e1ndar es muy com\u00fan sobre todo en entornos Microsoft y s\u00f3lo deber\u00eda usarse si no disponemos del driver nativo para nuestro SGBD. En el caso concreto de MySQL y Post greSQL, no tendremos ning\u00fan problema en encontrar los drivers JDBC: MySQL Connector/J: es el driver oficial para MySQL y se distribuye bajo li- cencia GPL. Es un driver nativo escrito completamente en Java. JDBC para PostgreSQL: es el driver oficial para PostgreSQL y se distribuye bajo licencia BSD. Es un driver nativo escrito completamente en Java. Tanto uno como otro, en su distribuci\u00f3n en formato binario, consisten en un fichero .jar ( Java archive ) que debemos situar en el CLASSPATH de nuestro pro- grama para poder incluir sus clases. Java incluye la posibilidad de cargar cl ases de forma din\u00e1mi ca. \u00c9ste es el caso de los controladores de bases de datos: antes de realizar cu alquier interacci\u00f3n con las clases de JDBC, es preciso registra r el controlador. Es ta tarea se realiza con el siguiente c\u00f3digo: o bien: A partir de este momento, JDBC est\u00e1 capacitado para in teractuar con MySQL o PostgreSQL. 2.1. Acceder al SGBD con JDBC La interfaz JDBC est\u00e1 definida en la lib rer\u00eda java.sql. Vamos a importar a nues- tra aplicaci\u00f3n Java todas las clases definidas en ella. Puesto que JDBC puede realizar cone xiones con m\u00faltiples SGDB, la clase DriverManager configura los detalles de la interacci\u00f3n con cada uno en particular. Esta clase es la responsable de realizar la conexi\u00f3n, entregando un objeto de la clase Connection .String controlador = \"com.mysql.jdbc.Driver\" Class.forName(controlador).newInstance(); Class.forName(\"org.postgresql.Driver\"); import java.sql.*; FUOC 71Z799014MO 29 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos El destino de la conexi\u00f3n se especifica mediante un URL de JDBC con la sin- taxis siguiente: La parte protocolo_sgdb de la URL especifica el tipo de SGBD con el que se realizar\u00e1 la conexi\u00f3n, la clase DriverManager cargar\u00e1 el m\u00f3dulo correspon- diente a tal efecto. El subnombre tiene una sintaxis espec\u00edfica para cada SGDB que tanto para MySQL como para PostgreSQL es //servidor/base_de_datos . Las sentencias en JDBC tambi\u00e9n son objetos que deberemos crear a partir de una conexi\u00f3n: Al ejecutar una sentencia, el SGBD en trega unos resultados que JDBC tambi\u00e9n representa en forma de objeto , en este caso de la clase ResultSet : Para acceder a los datos de cada columna de la hoja de resultados, la clase Resul- tSet dispone de varios m\u00e9todos seg\u00fan el tipo de la informaci\u00f3n de la columna: String La variable res contiene el resultado de la ejecuci\u00f3n de la sentencia, y proporciona un cursor que permite leer las filas una a una. ResultSet res = de aplicaciones en conexi\u00f3n con bases de datos En el ejemplo anterior no se ha previs to nada para tratar con los errores que puedan producirse, porque en Java el tratamiento de errores se realiza a trav\u00e9s de Exceptions . En JDBC se han previsto ex cepciones para los errores que pueden producirse a lo largo de todo el uso de la API: conexi\u00f3n, ejecuci\u00f3n dela sentencia, etc. Revisemos el ejemplo, utilizando ex cepciones para tratar los errores. import java.sql.*; // Atenci\u00f3n, no debe importarse com.mysql.jdbc ya que se din\u00e1micamente!! public static void main(String[] args) { // Cargamos MySQL String controlador = \"com.mysql.jdbc.Driver\" Class.forName(controlador).newInstance(); // Conectamos con la BD Connection conexion // Ejecutamos la sentencia.executeQuery(\"SELECT * FROM tabla\"); // Iteramos sobre la hoja de resultados while (res.next()) { // Obtenemos el campo 'nombre' en forma de String System.out.println(res.getString(\"nombre\") ); } // Finalmente, se liberan los recursos utilizados. res.close();sentencia.close(); conexion.close(); } import java.sql.*; // Atenci\u00f3n, no debe importarse com.mysql.jdbc ya que se carga // din\u00e1micamente!! public static void args) { try { // Cargamos el driver JDBC para MySQL String controlador = \"com.mysql.jdbc.Driver\" Class.forName(controlador).newInstance(); } catch (Exception e) { System.err.println(\"No puedo cargar el controlador de MySQL ...\"); e.printStackTrace(); } try { // Conectamos con la BD conexion = DriverManager.getConnection (url,usuario,contrasenia); FUOC 71Z799014MO 31 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos Mientras que la operaci\u00f3n executeQuery() de la clase Statement devuelve un objeto ResultSet , la operaci\u00f3n executeUpdate () s\u00f3lo devuelve su \u00e9xito o fracaso. Las sentencias SQL que se utilizan con executeUpdate () son insert , update , o delete , porque no devuelven ning\u00fan resultado. 2.2. Sentencias preparadas Las sentencias preparadas de JDBC pe rmiten la \"precompilaci\u00f3n\" del c\u00f3digo SQL antes de ser ejecutado, permitiend o consultas o actualizaciones m\u00e1s efi- cientes. En el momento de compilar la se ntencia SQL, se analiza cu\u00e1l es la es- trategia adecuada seg\u00fan la s tablas, las columnas, los \u00edndices y las condiciones de b\u00fasqueda implicados. Este proceso, obviamente, consume tiempo de pro- cesador, pero al realizar la compilaci\u00f3n una sola vez, se lo gra mejorar el rendi- miento en siguientes consultas iguales con valores diferentes. Otra ventaja de las sentencias preparad as es que permiten la parametrizaci\u00f3n: la sentencia SQL se escribe una vez, in dicando las posiciones de los datos que van a cambiar y, cada vez que se utilic e, le proporcionar emos los argumentos necesarios que ser\u00e1n sustituidos en lo s lugares correspondientes. Los par\u00e1me- tros se especifican con el car\u00e1cter '?'.// Creamos una sentencia SQL Statement sentenciaSQL = conexion.createStatement(); // * FROM tabla\"); // Iteramos sobre la hoja de resultados while (res.next()) { // Obtenemos el campo 'nombre' en forma de String System.out.println(res.getString(\"nombre\") ); } // Finalmente, se liberan los recursos utilizados. res.close(); sentencia.close(); conexion.close(); } catch (SQLException e) e.getSQLState()); System.out.println(\"Error del Proveedor: } nombre, telefono){ Statement sentencia = conexion.CreateStatement();sentencia.executeUpdate( \"insert into + \",\" + domicilio + \",\"+ telefono + \")\" ); } Errores Todos los errores de JDBC se informan a trav\u00e9s de SQLExeption . SQLWarning presenta las advertencias de acceso alas bases de datos. FUOC 71Z799014MO 32 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos Al utilizar esta clase, obviamente, de beremos llamar primer o al m\u00e9todo que prepara la inserci\u00f3n, y posteriormente llamar tantas veces como sea necesario al m\u00e9todo insertarPersona . Se definen tres par\u00e1metros en la senten cia SQL, a los cuales se hace referencia mediante n\u00fameros enteros consecutivos: La clase PreparedStatement incluye un conjunto de operaciones de la for- ma setXXXX() , donde XXXX es el tipo de dato para los campos de la tabla. Una de esas operaciones es precisamente setString() que inserta la variable en un campo de tipo cadena. 2.3. Transacciones La API JDBC incluye soporte para tran sacciones, de forma que se pueda desha- cer un conjunto de operaciones relacionadas en caso necesario. Este compor- tamiento es responsa bilidad de la clase Connection . Por omisi\u00f3n, cada sentencia se ejecuta en el momento en que se solicita y no se puede deshacer. Podemos cambiar este comportamiento con la operaci\u00f3n siguiente: Despu\u00e9s de esta operaci\u00f3 n, es necesario llamar a commit() para que todas las sentencias SQL pendientes se hagan definitivas:public class Actualizacion{ private PreparedStatement sentencia; public void prepararInsercion(){ String sql = \"insert into personas values ( ?, ? ,? )\"; sentencia = conexion.prepareStatement(sql); } personas values ( ?, ? ,? )\"; conexion.setAutoCommit(false);Ejemplo El segundo de los tres par\u00e1me- tros se especifica con senten- cia.setString(2, direccion); FUOC 71Z799014MO 33 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos En caso contrario, desharemos todas las actualizaciones despu\u00e9s del \u00faltimo commit() :sentencia.executeUpdate(...); ...sentencia.executeUpdate(...);...conexion.commit(); // Se hacen permanentes las dos actualizaciones anteriores sentencia.executeUpdate(...);...sentencia.executeUpdate(...);...sentencia.executeUpdate(...);...conexion.rollback(); // Cancela las tres \u00faltimas actualizaciones FUOC 71Z799014MO 34 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos Resumen Hemos presentado algunas de las formas m\u00e1s habituales de conectarse a los SGBD que hemos visto en m\u00f3dulo s anteriores desde PHP y Java. Hemos podido comprobar que no existe n demasiadas variaciones ni restric- ciones entre MySQL y PostgreSQL en cuanto a su acceso desde lenguajes deprogramaci\u00f3n, sino al contrario, los esfuerzos se encaminan en homogeneizar el desarrollo e independizarlo de l SGBD con el que trabajamos. En PHP, hemos repasado los m\u00e9todos nativos y visto sus particularidades. He- mos comprobado que, a no ser que nece sitemos caracter\u00edsticas propias y muy avanzadas de un SGBD, no es aconsejable usar esos m\u00e9todos por los problemasque nos puede ocasionar un cambio de gestor de base de datos en el futuro. Aun as\u00ed, es interesante revisarlos po rque encontraremos muchas aplicaciones de software libre desarrolladas en PH P que los utilizan. PEAR::DB es un ejemplo de librer\u00eda de abstracci\u00f3n (no es la \u00fanica) bien hecha y con el soporte de la fundaci\u00f3n que ma ntiene PHP. Tiene todo lo que pode- mos desear y actualmente es completame nte estable y usable en entornos em- presariales. En Java, hemos visto JDBC. Aunque la API da mucho m\u00e1s de s\u00ed, creemos que hemos cumplido los objetivos de este cap\u00edtulo, sin entrar en conceptos ques\u00f3lo programadores expertos en Java podr\u00edan apreciar. As\u00ed pues, se han proporcionado los elementos de referencia y los ejemplos ne- cesarios para trabajar con bases de datos en nues tras aplicaciones. FUOC 71Z799014MO 35 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos Bibliograf\u00eda Documentaci\u00f3n de PHP: http://www.php.net/docs.php PEAR de estudio \u00cdndice Introducci\u00f3n .............................................................................................. 5 Objetivos ..................................................................................................... 6 1. Presentaci\u00f3n del caso de estudio ..................................................... 7 2. El modelo relacional y el \u00e1lgebra relacional ............................... 8 2.1. Determinar las relaciones ................................................................. 82.2. Definici\u00f3n de claves ......................................................................... 92.3. Reglas de integridad .......................................................................... 112.4. \u00c1lgebra relacional ............................................................................. 12 3. El lenguaje SQL .................................................................................... 13 3.1. Sentencias de definici\u00f3n ................................................................... 13 3.2. Sentencias de manipulaci\u00f3n ............................................................. 15 4. Introducci\u00f3n al dise\u00f1o de bases de datos ..................................... 17 4.1. Dise\u00f1o conceptual: el modelo ER ..................................................... 174.2. Dise\u00f1o l\u00f3gico: la transformaci\u00f3n del modelo ER al modelo relacional ......................................................................... 19 5. Bases de datos en MySQL ................................................................... 22 6. Bases de datos en PostgreSQL ........................................................... 24 7. Desarrollo de aplicaciones en conexi\u00f3n con bases de datos .................................................................................................. 25 Resumen ...................................................................................................... 30 FUOC 71Z799014MO 5 Caso de estudio Introducci\u00f3n Este m\u00f3dulo forma parte del curso \"Bases de datos\" del itinerario \"Administra- dor web y comercio electr\u00f3n ico\" dentro del M\u00e1ster Internacional de Software Libre de la Universitat Oberta de Catalunya. El m\u00f3dulo est\u00e1 estructurado en apartados que corresponden al resto de los m\u00f3- dulos de la asignatura, de modo que el estudiante puede ir siguiendo este caso de estudio a medida que va progresando en el curso. Aunque algunos de los m\u00f3dulos ya disponen de ejercicios de autoevaluaci\u00f3n, el caso de estudio presenta una visi\u00f3n completa de un proyecto de bases de datos y proporciona una visi\u00f3n pr\u00e1ctica de cada uno de ellos. FUOC 71Z799014MO 6 Caso de estudio Objetivos Los objetivos que deber\u00edais alcanzar al finalizar el trabajo con la presente uni- dad son los siguientes: Comprender desde un punto de vista pr\u00e1ctico los conceptos explicados en las unidades did\u00e1cticas te\u00f3ricas. Disponer de un modelo de referencia para emprender proyectos de bases de datos. Adquirir el criterio suficiente para identificar las actividades clave y tomar decisiones en un proyecto que im plique el uso de bases de datos. FUOC 71Z799014MO 7 Caso de estudio 1. Presentaci\u00f3n del caso de estudio Acabamos de entrar a trabajar en una peque\u00f1a empresa -SuOrdenadorAMedi- da, S.L.- dedicada a la venta de ordenadores a particulares y otras empresas.Cuando nos hicieron la entrevista de trabajo, comentamos nuestra pasi\u00f3n por el software libre y en concreto hicimo s hincapi\u00e9 en nuestro conocimiento de los motores de bases de datos libres y las ventajas que pod\u00edan aportar respectode los gestores propietarios. No sabemo s si eso fue lo que convenci\u00f3 a la per- sona de recursos humanos o no, pero, en todo caso, y visto el resultado de la reuni\u00f3n que hemos tenido en nuestro pr imer d\u00eda de trabajo, vamos a tener que aplicar nuestros conocimientos a fondo. Nos han contado que, hasta ahora, la gesti\u00f3n de la empresa se llevaba a cabo con programas propietarios de gesti\u00f3n y contabilidad, pero que debido a pro- blemas con la empresa que desarrollaba estos programas, se est\u00e1 considerando la migraci\u00f3n de la gesti\u00f3n administrativa y de operaciones a entornos abiertos. Para acabar de decidirse, nos proponen que empecemos por renovar el sistema de gesti\u00f3n de peticiones e incidencias por parte de los clientes, de modo que est\u00e9 basada en software libre. Actualmente, las peticiones e incidencia s se reciben telef\u00f3 nicamente, por co- rreo electr\u00f3nico o en persona en alguno de los locales que tiene la empresa. La persona que atiende al tel\u00e9fono o lee lo s correos electr\u00f3nicos de plantea una serie de preguntas al cliente y escribe en una plantilla de documento las res- puestas. A continuaci\u00f3n, se imprime el documento y se deja en una bandeja que recogen los t\u00e9cn icos cada ma\u00f1ana. A medida que los t\u00e9cnicos van avanzando en la soluci\u00f3n de la incidencia (o han llamado al cliente para pedir m\u00e1s datos) , van apuntando las acciones y el estado del problema en la hoja que recogieron, hasta que la incidencia queda resuelta. En ese momento, la dejan en una bandeja que recoge cada ma\u00f1ana el personalde administraci\u00f3n, que se pone en contac to con el cliente y factura el importe correspondiente a las horas de tr abajo y componentes sustituidos. Es obvio que este sistema presenta numerosas deficiencias, y que el rendimien- to tanto de los t\u00e9cnicos, como del pers onal administrativo y de atenci\u00f3n al cliente podr\u00eda aumentar enormemente si muchos de estos procesos fueran au- tom\u00e1ticos, centralizados y, a poder ser, conectados con el resto del sistema deinformaci\u00f3n de la empresa. \u00c9ste es, a grandes rasgos, el problema que se nos plante a, y que utilizaremos como caso de estudio para aplicar los conocimientos adquiridos durante el de- sarrollo del curso. FUOC 71Z799014MO 8 Caso de estudio 2. El modelo relacional y el \u00e1lgebra relacional Visto el proyecto planteado, decidimo s hacer las cosas bien hechas para, de paso, impresionar a nuestro jefe con nu estros conocimientos en bases de da- tos. El primer paso ser\u00e1 presentarl e un documento que describa el modelo relacional que vamos a utilizar, en el que incluiremos algunas consultas demuestra para que pueda comprobar qu\u00e9 ser\u00e1 capaz de hacer con nuestro pro- yecto cuando est\u00e9 acabado. 2.1. Determinar las relaciones En primer lugar determinaremos las re laciones, sus atributos y los dominios de cada uno de ellos: En la relaci\u00f3n PETICION , hemos decidido que convendr\u00eda tener una referen- cia interna de la petici\u00f3n, que nos ayudar \u00e1 al hablar de ella con el cliente (si tuviese varias abiertas) y evitar\u00e1 confusiones al trabajar. El resto de atributos son bastante expl\u00edcitos. Como una petici\u00f3n puede evolucionar co n el tiempo, a medida que se piden m\u00e1s datos al cliente, la in cidencia va evolucionando, etc., hemos creado las re- laciones NOTA_PETICION y MATERIAL_PETICION para reflejarlo. Tambi\u00e9n hemos tenido que definir las relaciones CLIENTE y EMPLEADO para poder relacionarlas con las peticiones y las notas qu e se vayan generando du- rante su resoluci\u00f3n. A continuaci\u00f3n vamos a definir los dominios de los atributos: PETICION(referencia, cliente, resumen, estado, nif) PETICION:dominio(referencia)=n\u00famerosdominio(cliente)=NIF FUOC 71Z799014MO 9 Caso de estudio Al definir los dominios de cada atributo, ya nos hemos avanzado en la toma de algunas decisiones: al decidir, por ejemplo, que el dominio del atributo em- pleado en la relaci\u00f3n NOTA_PETICION es NIF, estamos impl\u00edcitamente deter- minando que la clave primaria de la relaci\u00f3n EMPLEADO ser\u00e1 del dominio NIF y que usaremos un atributo de este dominio para referirnos a \u00e9l. 2.2. Definici\u00f3n de claves Aunque algunas claves ya se intuyen a pa rtir de los atributo s de las relaciones, vamos a determinarlas para completar indicando directamente su resultado, normalmen- te es fruto de una revisi\u00f3n de las entidades a medida que se van defi- niendo y analizando las necesidades de \u00e9stas. Nota La regla de integridad del mode- lo correspondiente a la clave pri-maria obligar\u00e1 a que no existan dos notas sobre la misma peti-ci\u00f3n hechas en la misma fecha y hora por parte del mismo em-pleado, lo cual es perfectamente l\u00edcito y coherente. FUOC 71Z799014MO 10 Caso de estudio Ahora podemos reescrib ir las relaciones: Las claves for\u00e1neas ya se intuyen a part ir de las relaciones, aunque vamos a co- mentarlas para completar el caso: NOTA_PETICION: Tiene de clave for\u00e1nea el atributo {peticion}, que establece la relaci\u00f3n (y pertenece al mismo dominio) con el atributo {referencia} de la relaci\u00f3n PETICION . Tambi\u00e9n tiene la clave for\u00e1nea {empleado}, que establece la relaci\u00f3n con EMPLEADO a partir de su clave primaria {nif}. MATERIAL_PETICION: Tiene de clave for\u00e1nea el atributo {peticion}, que establece la relaci\u00f3n (y pertenece al mismo dominio) con el atributo {referencia} de la relaci\u00f3n los casos s\u00f3lo tenemos una clave candidata y, por lo tanto, no caben dudas a la hora de escoger la clave primaria. Esto no tiene por que ser as\u00ed: en la relaci\u00f3n EMPLEADO , podr\u00edamos haber incluido m\u00e1s atributos (n\u00famero de la seguridad social, un n\u00famero de empleado interno, etc.) que ser\u00edan claves candidatas susceptibles de ser clave primaria. PETICION(referencia , cliente, resumen, ) FUOC 71Z799014MO 11 Caso de estudio 2.3. Reglas de integridad En este punto, no es nece sario preocuparse por las regl as de integridad del mo- delo que tratan sobre la clave primar ia, ya que nos vend r\u00e1n impuestas en el momento de crear las tablas en el SGBD. Es conveniente, no obstante, fijar las de cisiones sobre la integridad referencial; en concreto, qu\u00e9 vamos a hacer en caso de restricci\u00f3n. As\u00ed pu es, para cada re- laci\u00f3n que tiene una clave primaria refe renciada desde otra, deberemos decidir qu\u00e9 pol\u00edtica cabe aplicar en ca so de modificaci\u00f3n o borrado: PETICION Modificaci\u00f3n del atributo {referencia} referenciado desde NOTA_PETICION y MATERIAL_PETICION : aqu\u00ed podemos optar por la res- tricci\u00f3n o por la actualizaci\u00f3n en cascada (m\u00e1s c\u00f3moda, aunque no todos los SGBD la implementan, como veremos m\u00e1s adelante). Borrado del atributo {referencia}. Aqu\u00ed optaremos por una pol\u00edtica de restricci\u00f3n. Si la petici\u00f3n tiene nota s asociadas o materiales, significa que ha habido alguna actividad y, por lo tant o, no deber\u00edamos poder borrarla. Si se desea anularla, ya estableceremos un estado de la misma que lo indique. CLIENTE Modificaci\u00f3n del atributo {nif} referenciado desde PETICION . Es proba- ble que si un cliente cambia de NIF (p or un cambio del tipo de sociedad, etc.) deseemos mantener sus peticiones . Aqu\u00ed la pol\u00edtica debe ser de actua- lizaci\u00f3n en cascada. Borrado del atributo {nif} . Es posible que si queremos borrar un cliente, es porque hemos terminado toda relaci\u00f3n con \u00e9l y, por lo tanto, es cohe- rente utilizar aqu\u00ed la pol\u00edtica de anulaci\u00f3n. EMPLEADO Modificaci\u00f3n del atributo {nif} referenciado desde NOTA_PETICION. No es probable que un empleado cambie su NIF, salvo caso de error. Aun as\u00ed, en caso de que se produzca, es pref erible la actualizaci\u00f3n en cascada. Borrado del atributo {nif}. Aunque eliminemos un empleado si termina su relaci\u00f3n con la empresa, no deber\u00ed amos eliminar sus notas. La mejor op- ci\u00f3n es la restricci\u00f3n. FUOC 71Z799014MO 12 Caso de estudio 2.4. \u00c1lgebra relacional Para probar el modelo, una buena opci\u00f3n es intentar realizar algunas consul- tas sobre \u00e9l y ver si obtenemos los resu ltados deseados. En nuestro caso, vamos a realizar las sigu ientes consultas: Obtenci\u00f3n de una petici\u00f3n ju nto con los dato s del cliente: Obtenci\u00f3n de una petici\u00f3n con todas sus notas: Obtenci\u00f3n de los datos de todos lo s empleados que han participado en la petici\u00f3n 5: Ejercicio Os sugerimos que intent\u00e9is m\u00e1s operaciones so bre el modelo para PETICION [cliente=nif] FUOC 71Z799014MO 13 Caso de estudio 3. El lenguaje SQL Una vez terminado el mode lo relacional, decidimos completar la documenta- ci\u00f3n que ven\u00edamos realizando con las sentencias SQL correspondientes. As\u00ed, veremos en qu\u00e9 se concretar\u00e1 el modelo relacional. Como a\u00fan no sabemos en qu\u00e9 sistema gest or de base de datos vamos a implan- tar la soluci\u00f3n, decidimos simplemente an otar las sentencias seg\u00fan el est\u00e1ndar SQL92, y, posteriormente, ya examinar emos las particularidades del sistema gestor escogido para adaptarlas. 3.1. Sentencias de definici\u00f3n Creaci\u00f3n de la base de datos Definici\u00f3n de dominios Creaci\u00f3n de las tablas CREATE SCHEMA GESTION_PETICIONES; Atenci\u00f3n En algunos casos es conveniente la definici\u00f3n de dominios para facilitar el trabajo posterior de mantenimiento de la coherencia de la base de datos. No es acon-sejable definir dominios para cada dominio relacional, pero s\u00ed en los casos en que una colum-na puede tomar una serie de va-lores determinados. CHARACTER VARYING (2048), estado fechafin) ); Atenci\u00f3n Aqu\u00ed deberemos tener en cuenta las reglas de integridad, ya que habr\u00e1 que explicitarla pol\u00edtica escogida como restricci\u00f3n. FUOC 71Z799014MO 14 Caso de estudio Creaci\u00f3n de vistas - Peticiones pendientes:CREATE TABLE NOTA_PETICION ( NULL, empleado CHARACTER (9), FOREIGN KEY (peticion) REFERENCES PETICION(referencia) ON DELETE NO ACTION ON UPDATE CASCADE, FOREIGN KEY (empleado) REFERENCES EMPLEADO(nif) ON DELETE INTEGER, FOREIGN KEY REFERENCES PETICION(referencia) CASCADE ); CREATE TABLE CLIENTE ( nombre CHARACTER VARYING (100) NOT NULL, nif CHARACTER (9) NOT NULL, telefono CHARACTER (15), email CHARACTER (50), PRIMARY KEY (nif) ); CREATE TABLE EMPLEADO (nombre CHARACTER VARYING (100) NOT NULL, nif CHARACTER (9) NOT NULL, PRIMARY KEY (nif) ); Funci\u00f3n de vistas Las vistas agilizar\u00e1n las consul- tas que prevemos que van a ser mas frecuentes. CREATE VIEW peticiones_pendientes (referencia, ON P.cliente = C.nif WHERE estado NOT IN ('Resuelta','Cerrada') ORDER BY fecharecepcion ) FUOC 71Z799014MO 15 Caso de estudio - Tiempo y precio de los materiales em pleados para las peticiones termina- das en el mes en curso: 3.2. Sentencias de manipulaci\u00f3n A continuaci\u00f3n, decidimos indicar algu nas sentencias de manipulaci\u00f3n co- rrientes para completar la documentaci\u00f3n. De esta manera, cuando empece-mos el desarrollo, tendremos mucho m\u00e1s cl aras estas operaciones sobre la base de datos: Nuevo cliente: INSERT el ordenador', 'Nueva',CURRENT_TIMESTAMP,NULL,NULL,NULL); Cambio de estado de la petici\u00f3n, a\u00f1adimos una nota y un material: UPDATE PETICION SET estado='Aceptada' WHERE referencia=5; INSERT INTO INSERT INTO MATERIAL_PETICION VALUES SELECT nombrematerial, cantidad, precio FROM MATERIAL_PETICION WHERE peticion=5 N\u00famero peticiones abiertas del cliente '42389338A': SELECT COUNT(*) FROM PETICION WHERE M.peticion=P.referencia AND estado='Resuelta' GROUP BY P.referencia) FUOC 71Z799014MO 16 Caso de estudio La creaci\u00f3n de vistas del apartado anterior nos ha mostrado tambi\u00e9n algunas consultas complejas que repetimos ON P.cliente = C.nif WHERE estado NOT IN('Resuelta','Cerrada') ORDER BY fecharecepcion; Tiempo y precio de los materiales em pleados para las peticiones termina- das en P.cliente=C.nif AND M.peticion=P.referencia ANDestado='Resuelta' GROUP BY P.referencia; Finalmente, vamos a practicar con las co nsultas que realizamos en \u00e1lgebra re- lacional en el apartado anterior: Obtenci\u00f3n de una petici\u00f3n ju nto con los dato s del cliente: R:= PETICION [cliente=nif] CLIENTE SELECT * FROM PETICION JOIN CLIENTE ON PETICION.cliente=CLIENTE.nif; Obtenci\u00f3n de una petici\u00f3n con sus notas: NP(peticionnota,nota,fechanota,empleado):=NOTA_PETICION R:=PETICION[referencia=peticionnota]NPSELECT PETICION.*, FROM PETICION JOIN NOTA_PETICION ON referencia=peticionnota; Obtenci\u00f3n de los datos de todos lo s empleados que han participado en la petici\u00f3n 5: NP:=NOTA_PETICION[peticion=5] RA:=EMPLEADO[nif=empleado]NP R:=RA[nombre,nif] AND NOTA_PETICION.peticion=5; FUOC 71Z799014MO 17 Caso de estudio 4. Introducci\u00f3n al dise\u00f1o de bases de datos Aunque las sentencias SQL de creaci\u00f3n de tablas son bastante claras para un usuario t\u00e9cnico, de cara a la reuni\u00f3 n previa a la toma de decisi\u00f3n sobre el SGBD concreto en el que vamos a implantar la soluci\u00f3n, necesitaremos algo m\u00e1s. Teniendo en cuenta que entre los asis tentes a la reuni\u00f3n no hay m\u00e1s t\u00e9cni- cos especializados en bases de datos que nosotros, hemos pensado que dis- poner un modelo entidad-relaci\u00f3n del sistema nos ayudar\u00e1 a comunicar mejor la estructura que estamos planteando y, de paso, a demostrar (o, sies necesario, corregir) que el modelo relacional que planteamos al inicio es el correcto. 4.1. Dise\u00f1o conceptual: el modelo ER Vamos a plantear en primer lugar el mo delo obtenido y, despu\u00e9s, comentare- mos los aspectos m\u00e1s interesantes: El modelo, expresado de este modo, es mucho m\u00e1s comprensible por parte de personal no t\u00e9cnico o no especializado en tecnolog\u00edas de bases de datos. FUOC 71Z799014MO 18 Caso de estudio A partir de la expresi\u00f3n gr\u00e1fica del modelo, identificamo s limitaciones o pun- tos de mejora, que anotamos a continuaci\u00f3n: Probablemente, debemos incluir inform aci\u00f3n de facturaci\u00f3n a clientes por las peticiones realizadas. Probablemente, habr\u00e1 peticiones que puedan agruparse en una entidad su- perior (un proyecto o trabajo), o bien peticiones relacionadas entre ellas (peticiones que deban reso lverse antes que otras). Una vez identificadas estas limitaciones, vamos a ampliar el modelo para co- rregirlas e impresionar a nuestros superiores de cara a la reuni\u00f3n. Informaci\u00f3n de fact uraci\u00f3n a clientes: Lo \u00fanico que hemos introducido ha sido la entidad FACTURA , que se relaciona con N peticiones y con un \u00fanico cliente. Un CLIENTE puede tener varias fac- turas asociadas, pero una petici\u00f3n s\u00f3lo puede pertenecer a una \u00fanica factura. Grupos de peticiones y relaciones entre ellas. FUOC 71Z799014MO 19 Caso de estudio La pertenencia a un proyecto ser\u00e1 opcion al, y as\u00ed lo indicamos en el diagrama. Por lo que respecta a las relaciones de pe ticiones entre ellas, se trata de una in- terrelaci\u00f3n recursiva. Si queremos contemplar casos como los siguientes, de-bemos expresar la relaci\u00f3n como M:N re cursiva y opcional. En la interrelaci\u00f3n RELACIONA, debemos contemplar alg\u00fan atributo que indique de qu\u00e9 tipo de relaci\u00f3n se trata en cada caso: Una petici\u00f3n depende de una o m\u00e1s peticiones. Una petici\u00f3n bloquea a una o m\u00e1s peticiones. Una petici\u00f3n es la duplicada de una o m\u00e1s peticiones. Una petici\u00f3n est\u00e1 relacionada con una o m\u00e1s peticiones. 4.2. Dise\u00f1o l\u00f3gico: la transforma ci\u00f3n del modelo ER al modelo relacional En el apartado anterior sugerimos unas ampliaciones sobre el modelo ER que proporcionaban m\u00e1s prestaciones al proyecto. A continuaci\u00f3n, vamos a reali-zar la transformaci\u00f3n al modelo relacional de estas ampliaciones: Informaci\u00f3n de fact uraci\u00f3n a clientes. Seg\u00fan las transformaciones vistas en el m\u00f3dulo \"El lenguaje SQL\", la entidad FACTURA se transforma en la relaci\u00f3n FACTURA , con los siguientes atributos: Donde cliente es una clave for\u00e1nea que co rresponde a la interrelaci\u00f3n TIE- NE entre CLIENTE y FACTURA . Un cliente puede tener N facturas, pero una fac- tura pertenece s\u00f3lo a un \u00fanico cliente.FACTURA(numfactura , fecha, cliente) FUOC 71Z799014MO 20 Caso de estudio La interrelaci\u00f3n entre FACTURA y PETICION del tipo 1:N se transforma tam- bi\u00e9n en una nueva clave for\u00e1nea, que aparece siempre en el lado N de la inte- rrelaci\u00f3n; o sea, en la relaci\u00f3n PETICION . Si existen peticiones que no deban facturarse (porque se han cerrado sin resolverse, o eran duplicadas de otras,etc.), su clave for\u00e1nea tomar\u00eda el valor NULO . Grupos de peticiones y relaciones entre ellas. Por una parte, la entidad proyecto debe transformarse en la relaci\u00f3n PROYECTO , con atributos como los siguientes: La relaci\u00f3n 1:N entre PROYECTO y PETICI\u00d3N se transformar\u00e1 en la inserci\u00f3n de una nueva clave for\u00e1nea en la relaci\u00f3n PETICION , que podr\u00e1 tener valor NULO si la petici\u00f3n no pertenece a ning\u00fan proyecto; es decir, si se trata de una petici\u00f3n aislada. La relaci\u00f3n PETICION quedar\u00eda as\u00ed: Por lo que respecta a las re laciones entre peticiones, se trata de una interrela- ci\u00f3n recursiva N:M, y por lo tanto se transformar\u00e1 PETICION_RELACION :PROYECTO(codigo 21 Caso de estudio En este caso, y seg\u00fan el valo r que pueda tomar el atributo {tiporelacion} , tendr\u00e1 importancia o no qu \u00e9 referencia de petici\u00f3n aparece en cada atributo de la relaci\u00f3n. En cambio, si el atributo {tiporelacion} indica un bloqueo o una depen- dencia entre relaciones (porque una debe resolverse antes que otra, por ejem- plo), entonces s\u00ed tiene sentido qu\u00e9 referencia de petici\u00f3n se almacena en elatributo 1 y cu\u00e1l en el 2. En todo ca so, esta tarea corresp onder\u00e1 a la soluci\u00f3n que se adapte y trabaje con la base de datos en \u00faltimo t\u00e9rmino, no al propio modelo.Ejemplo Si la relaci\u00f3n debe indicar sim- plemente que dos peticiones est\u00e1n relacionadas, entonces no importa qu\u00e9 referencia sea, la 1 o la 2. FUOC 71Z799014MO 22 Caso de estudio 5. Bases de datos en MySQL Una vez hemos terminado el proceso de dise\u00f1o de nuestra soluci\u00f3n, en cuanto a su sistema de informaci\u00f3n, es hora de implantarlo sobre un sistema gestorde bases de datos. Ya que disponemos de dos alternativas (MySQL y PostgreSQL), y no nos co- rresponde tomar la decisi\u00f3n final (s\u00f3l o hacer la recomend aci\u00f3n), vamos a ela- borar una lista con los aspectos clave en la toma de decisiones y a puntuar, o comentar, cada SGBD seg\u00fa n los \u00edtems siguientes: Modelo de licencia, precio. Soporte por parte del fabricante. Conexi\u00f3n desde PHP. Prestaciones en creaci\u00f3n de las estructuras (tablas, \u00edndices, etc.). Prestaciones en tipos de datos. Prestaciones en consultas simples. Prestaciones en consultas complejas. Prestaciones en manipulaci\u00f3n de datos. Facilidad en la administraci\u00f3n de usuarios. Facilidad en la gesti\u00f3n de copias de seguridad. Concepto Valoraci\u00f3n Comentarios Modelo de licencia, precio2 Aunque no nos planteamos vender nuestra soluci\u00f3n, ni comercializarla con una licencia propietaria, la licencia dual de MySQL siempre ser\u00e1 un aspecto que tendremos que tener en cuenta si alguien se interesa por nuestra aplicaci\u00f3n. Soporte por parte del fabricante3 Tenemos tanto la opci\u00f3n de contratar soporte en varias modalidades, como la de optar por consultar a la ampl\u00edsima gama de usuarios del producto. En todo caso, en ambas situaciones obtendremos un excelente soporte. Conexi\u00f3n desde PHP 3 PHP siempre ha incluido soporte para este SGBD bien con funciones especiales de dicadas que aprovechan al m\u00e1ximo sus caracter\u00edsticas, o bien con librer\u00edas PEAR como DB que nos abstraen del SGBD y que soportan MySQL a la perfecci\u00f3n. Au nque recientemente ha habido alg\u00fan problema con la licencia y parec\u00eda que PHP no incluir\u00eda soporte para MySQL en sus \u00faltimas versiones, MySQL ha hech o una excepci\u00f3n con PHP (que sin duda ha contribuido mucho a la popularizaci\u00f3n de MySQL) por el bien de la comunidad y de sus usuarios. Prestaciones en creaci\u00f3n de las estructuras (tablas, \u00edndices, etc.)2 MySQL es francamente f\u00e1cil de manejar en este aspecto, y aunque no ofre ce todas las prestaciones contempladas en el est\u00e1ndar, es \"satisfactorio\" para la aplicaci\u00f3n que estamos planeando. Prestaciones en tipos de datos2 Los tipos de datos soportados por MySQL as\u00ed como los operadores incluidos en el SGBD sonm\u00e1s que suficientes para nuestra aplicaci\u00f3n. Prestaciones en consultas simples3 \u00c9sa es precisamente la ca racter\u00edstica que hace que MySQL sea uno de los SGBD mejor posicionados.Nota Mostraremos esta lista en forma de tabla, y al final elabo-raremos unas conclusiones. Aunque no realicemos una ponderaci\u00f3n de cada aspecto de la lista anterior, la simple comparaci\u00f3n nos servir\u00e1 para llegar a una conclusi\u00f3n r\u00e1pida. Clave de valoraci\u00f3n 1: no satisfactorio 2: satisfactorio 3: muy satisfactorio FUOC 71Z799014MO 23 Caso de estudio Concepto Valoraci\u00f3n Comentarios Prestaciones en consultas complejas2 Hasta hace poco, MySQL no soportaba subconsultas y esto implicaba un mayor es fuerzo por parte de los programadores. Ahora ya las soporta y a un nivel igual al de sus competidores. Prestaciones en manipulaci\u00f3n de datos3 MySQL incluye multitud de opciones no est\u00e1ndares para cargar datos externos, insertar o actualizar sobre la base de consultas complejas y la utilizaci\u00f3n de operadores como condiciones para la manipulaci\u00f3n. Facilidad en la administraci\u00f3n de usuarios3 Soporta muy bien el est\u00e1ndar en cuanto a la creaci\u00f3n de usuarios y la gesti\u00f3n de sus privilegios con GRANT y REVOKE. Adem\u00e1s, todos estos datos est\u00e1n accesibles en tablas de sistema, lo que hace muy sencilla la verificaci\u00f3n de permisos. Facilidad en la gesti\u00f3n de copias de seguridad3 Disponemos tanto de herram ientas de volcado, como la posibilidad de copia binaria de la base de datos. Adem\u00e1s, dada su popularida d varios fabricantes de soluciones de copias de seguridad proporcionan conectores para realizar backups de la base de datos en caliente. Conclusi\u00f3n 2,6 Estamos ante un \"m\u00e1s que satisfactorio\" SGBD para la soluci\u00f3n que nos planteamos. No hay ninguna carencia insalvable. FUOC 71Z799014MO 24 Caso de estudio 6. Bases de datos en PostgreSQL Concepto Valoraci\u00f3n Comentarios Modelo de licencia, precio3 La licencia BSD no nos li mita en ning\u00fan aspecto. Simplemente tendremos que in cluir la nota sobre la misma en nuestro software, tanto si lo queremos comercializar como si no. Soporte por parte del fabricante2 PostgreSQL no ofrece soporte directamente, aunque s\u00ed que proporciona los mecanismos para que la comunidad lo ofrezca (listas de correo, IRC, enlaces, etc.). Tambi\u00e9n tiene una lista (corta) de empresas que ofrecen soporte profesional de PostgreSQL. En Espa\u00f1a s\u00f3lo hay una, y no es una empresa de desarrollo de software. Conexi\u00f3n desde PHP 3 PHP siempre ha incluido soporte para este SGBD, bien con funciones especiales dedicadas que aprovechan al m\u00e1ximo sus caracter\u00edsticas o bien con librer\u00edas PEAR como DB, que nos abstraen del SGBD y que soportan PostgreSQL a la perfecci\u00f3n. Prestaciones en creaci\u00f3n de las estructuras (tablas, \u00edndices, etc.)3 PostgreSQL es muy potente en este aspecto, ofrece pr\u00e1cticamente todas las prestaciones contempladas en el est\u00e1ndar, y tiene un fant\u00e1stico sistema de extensi\u00f3n. Prestaciones en tipos de datos3 Los tipos de datos soport ados por PostgreSQL, as\u00ed como los operadores incluidos en el SGBD son m\u00e1s que suficientes para nues tra aplicaci\u00f3n. Adem\u00e1s, su sistema de extensiones y definici\u00f3n de tipos y dominios incluye casi todo lo que podamos necesitar. Prestaciones en consultas simples3 Por supuesto, PostgreSQL no decepciona en este punto. Prestaciones en consultas complejas3 PostgreSQL ha soportado su bconsultas, vistas y todo lo que podamos necesitar en nuestra aplicaci\u00f3n desde hace varios a\u00f1os. Su implementaci\u00f3n de \u00e9stas es ya muy estable. Prestaciones en manipulaci\u00f3n de datos3 PostgreSQL incluye multitud de opciones no est\u00e1ndares para cargar datos externos, insertar o actualizar sobre la base de consultas complejas y la utilizaci\u00f3n de oper adores como condiciones para la manipulaci\u00f3n. Facilidad en la administraci\u00f3n de usuarios2 Soporta bastante bien el est\u00e1ndar en cuanto a la creaci\u00f3n de usuarios y la gesti\u00f3n de sus privilegios con GRANT y REVOKE. Su sistema m\u00faltiple de autenticaci\u00f3n lo hace demasiado complejo en este aspecto. Facilidad en la gesti\u00f3n de copias de seguridad3 Disponemos tanto de herram ientas de volcado, como de la posibilidad de copia bi naria de la base de datos. Conclusi\u00f3n 2,8 Estamos ante el SGBD casi ideal. S\u00f3lo le falta facilitar la gesti\u00f3n de usuarios y mejorar su soporte.Clave de valoraci\u00f3n 1: no satisfactorio 2: satisfactorio 3: muy satisfactorio FUOC 71Z799014MO 25 Caso de estudio 7. Desarrollo de aplicaciones en conexi\u00f3n con bases de datos En la reuni\u00f3n mantenida con la direcc i\u00f3n se examinaron muy cuidadosamen- te los an\u00e1lisis de lo s SGBD seleccionados. Al ser la diferencia de valoraci\u00f3n tan leve, no fue f\u00e1cil tomar una decisi\u00f3n, pe ro al final se decidi\u00f3 la implementa- ci\u00f3n de la soluci\u00f3n sobre el SGBD PostgreSQL. Se decidi\u00f3, tambi\u00e9n, hacer la implem entaci\u00f3n en PHP, abstray\u00e9ndonos del SGBD con el que trabaj\u00e1ramos. As\u00ed, en caso de que la mayor dificultad en laadministraci\u00f3n de PostgreSQL nos hiciera rectificar la decisi\u00f3n en el futuro, el tiempo de puesta en marcha del cambio ser\u00eda m\u00ednimo. Antes de iniciar la implantaci\u00f3n, vamo s a realizar unas pruebas conceptuales de la propia implementaci\u00f3n que, desp u\u00e9s, pasaremos a un equipo de desarro- llo interno para que haga el resto. En concreto, tomaremos algunas de las con- sultas vistas en el cap\u00edtulo 3 y programaremos los scripts PHP de las p\u00e1ginas correspondientes, document\u00e1ndolas al m\u00e1ximo para facilit ar el trabajo al equipo de desarrollo. En primer lugar, crearemos un fichero .p hp con la conexi\u00f3n a la base de datos, para incluirlo en todos los PHP que lo va yan a necesitar, y evitar, as\u00ed, tener que repetir c\u00f3digo cada vez. Esta acci\u00f3n tambi\u00e9n ayudar\u00e1 a mantener centralizadoslos datos de la conexi\u00f3n y, en caso de que debi\u00e9ramos cambiar el usuario o la contrase\u00f1a o cualquier otro dato de la conexi\u00f3n, s\u00f3lo tend r\u00edamos que actuali- zar dicho fichero. datosconexion.php <?php // librer\u00eda una vez instalada mediante PEAR require_once 'DB.php'; // Creamos la conexi\u00f3n a la base de datos, en este caso PostgreSQL $db =& DB::connect('pgsql://usuario:password@servidor/basededatos '); // Comprobamos die($db->getMessage()); } ?> FUOC 71Z799014MO 26 Caso de estudio a. Nuevo cliente. P\u00e1gina de resultado de la inserci\u00f3n de un nuevo cliente c. Cambio de estado de la petici\u00f3n: <?php // Incluimos el fichero con los datos de la conexi\u00f3n. include_one 'datosconexion.php'; // Utilizamos el m\u00e9todo quoteSmart() para evitar que determinados caracteres // (intencionados o no) puedan romper la sintaxis de la sentencia SQL. // El m\u00e9todo insertar\u00e1 autom\u00e1ticamente comillas alrededor de las cadenas // de texto, o tratar\u00e1 los valores NULL correctamente seg\u00fan el SGBD, etc.$db->query(\"INSERT INTO <?php include_once 'datosconexion.php'; // Vamos a trabajar con todas las operaciones de esta p\u00e1gina en forma de // transacci\u00f3n, ya que, si se produce un error al insertar una nota o un// material, la petici\u00f3n puede quedar en un estado err\u00f3neo. $db->autoCommit(false); // Le decimos a PHP que almacene en un buffer la salida, para poder as\u00ed // rectificar en caso de producirse un error. ob_start(); // Suponemos que los estados nos llegan directamente con los valores // soportados por el dominio, por ejemplo, a partir de los valores // fijos de un desplegable. // Suponemos que la fecha de inicio y fecha de fin nos llegan en formato // espa\u00f1ol dd/mm/yyyy y los convertimos a YYYY-mm-dd seg\u00fan ISO 8601. // Suponemos que el tiempo empleado nos llega en dos campos, horas y minutos, de // forma que concaten\u00e1ndolos e insertando un \":\" en medio, obtenemos una// hora en formato ISO 8601. FUOC 71Z799014MO 27 estudio el cliente</h2>\";ob_flush();die($db->getMessage()); } else { echo \"<h2>Petici\u00f3n actualizada correctamente</h2>\"; } // Comprobamos si han a\u00f1adido alguna nota if (isset($_REQUEST['texto_nota']) && !empty($_REQUEST['texto_nota'])) { // Tenemos el identificador la nota. Datos de la petici\u00f3n no actualizados</h2>\";ob_flush();$db->rollback();die($db->getMessage()); } else { echo \"<h3>Nota actualizada correctamente</h2>\"; } } FUOC 71Z799014MO 28 Caso de estudio f. y g. Peticiones abiertas de un clie nte y resumen de los materiales usados en cada una // Comprobamos si han a\u00f1adido alg\u00fan material+ if (isset($_REQUEST['nombrematerial']) && !empty($_REQUEST['nombrematerial'])) { // Tenemos el identificador \"<h2>Error al insertar el material. Datos de la petici\u00f3n no actualizados</h2>\"; ob_flush(); $db->rollback(); die($db->getMessage()); } else P.referencia, P.resumen, P.estado, P.fecharecepcion FROM PETICION P JOIN ON P.cliente=C.nif WHERE ESTADO NOT IN ('Resuelta', 'Cerrada') ORDER BY fecharecepcion\"); if (DB::isError($db)) { die($db->getMessage()); } // Antes de empezar la iteraci\u00f3n por las peticiones, vamos a preparar la consulta // correspondiente a los materiales empleados en cada una. $queryMaterial=$db->prepare(\"SELECT SUM(M.precio) as precioMateriales, die($db->getMessage()); } FUOC 71Z799014MO 29 Caso de estudio Mediante estos tres ejemplos, disponemos ya de una base tanto de c\u00f3digo, como de estilo y mecanismos de comp robaci\u00f3n de error, para desarrollar el resto de la aplicaci\u00f3n, sin tener en cuenta su dise\u00f1o. Hemos intentado escoger consultas y op eraciones representativas del funcio- namiento de la aplicaci\u00f3n y, a la vez, que se correspondieran con las vistas en apartados anteriores. Adem\u00e1s, hemos introducido algunas funciones PHP quesuelen utilizarse en combinaci\u00f3n con el trabajo en bases de datos para tipos concretos, y para el tratamiento de errore s, para evitar que el usuario reciba in- formaci\u00f3n confusa en la p\u00e1gina de resultados.echo \"<table>\"; 30 Caso de estudio Resumen En esta unidad hemos visto las actividade s m\u00e1s destacadas de las fases iniciales de un proyecto de desarrollo con conexi\u00f3n a bases de datos. M\u00e1s que resolver el propio caso, se trat aba de identificar los aspectos clave de los casos reales y enlazarlos con el co ntenido del resto de unidades del curso. Habr\u00e9is podido identificar qu\u00e9 actividade s son m\u00e1s relevantes para el resulta- do final del proyecto, en cu\u00e1les conviene invertir m\u00e1s tiempo y cu\u00e1les no son tan cr\u00edticas para los objetivos de \u00e9ste u otro caso similar. Si hab\u00e9is seguido la planif icaci\u00f3n sugerida y repasado cada unidad a la que que se hac\u00eda referencia, habr\u00e9is podido comp render la aplicaci\u00f3n pr\u00e1ctica del ma- terial y se habr\u00e1n alcanzado los objetivos que nos propon\u00edamos al redactar esta unidad did\u00e1ctica. Tambi\u00e9n es posible leer este caso de es tudio como un cap\u00edtulo final del curso, donde se desarrolla un ejemplo completo. Se ha intentado redactarlo con este doble cometido.Ap\u00e9ndice:GNU Free DocumentationLicense Ap\u00e9ndice:GNU FreeDocumentationLicense FUOC 71Z799014MO 3 Ap\u00e9ndice: GNU Free Documentation License GNU Free Documentation License Version 1.2, November 2002 Copyright (C) 2000,2001,2002 Fr ee Software Foundation, Inc. 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. 0. PREAMBLE The purpose of this License is to make a manual, textbook, or other functional and useful document \"free\" in the sense of freedom: assure the effective freedom to copy noncommercially. Secondarily, this License preserves for the au thor and publisher a way to get credit for their work, while not being considered responsible for modifications made byothers. This License is a kind of \"copyleft\", wh ich means that derivative works of the document must themselves be free in the same sense. It complements the GNU General Public License, which is a copyleft license designed for free software. We have designed this Licens e in order to use it for manuals for free software, because free software needs free documentation: a free program should come with manuals providing the same freedoms that thesoftware does. But this License is not limited to software manuals; it can beused for any textual work, regardless of subject matter or whether it ispublished as a printed book. We re commend this License principally for works purpose is reference. 1. APPLICABILITY AND DEFINITIONS This License applies to any manual or other work, in any medium, that contains a notice placed by the copyrigh t holder saying it can be distributed under the terms of this License. Such a notice grants a world-wide, royalty- free license, unlimited in duration, to use that work under the conditionsGNU Free Documentation License FUOC 71Z799014MO 4 Ap\u00e9ndice: \"Document\", below, refers to any such manual or work. Any member of the public is a licens ee, and is addressed as \"you\". You accept the license if you copy, modify or distribute the work in a way requiring permission under copyright law. A \"Modified Version\" of the Document means any work containing the Document or a portion of either co pied verbatim, or named appendix or Document that exclus ively with the relationsh ip of the publishers or authors of the Document to the Document's overal l subject (or to related matters) and contains nothin g that could fall directly within that overall subject. (Thus, if the Document is in part a textbook of mathematics, a Secondary Section may not explain any ma thematics.) The relationship could be a matter of historical connection with the subject or with related matters, or of legal, commercial, philosophical, ethical or political position regarding them. The certain Secondary Invariant Sections, in the notice that says that the Document is released under this License. If a section does not fit theabove definition of Secondary then it is not allowed to be designated as Invariant. The Document may contai n zero Invariant Sec tions. If the Document does not identify any riant then there Texts\" certain short pa ssages listed, as Front-Cover Texts or Back-C over Texts, in the notice that says that the Document is released under this Lice nse. A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at most 25 words. A \"Transparent\" of the Docume in a format whose specification is available to the general public, that is suitable for revising the document straightforwardly with generic text (for composed of programs or (for drawings) some wide ly available drawing editor, and that is suitable for input to text formatters or for automatic translation to a variety of formats suitable for input to text fo rmatters. A copy made in an otherwise Transparent file format whose mark up, or absence 5 Ap\u00e9ndice: GNU Free Documentation License An image format is not Transparent if used for any substantial amount of text. A that not \"Tra suitable markup, Texinfo input format input format, SGML or XML using a publicly available DTD, an d standard-conforming simple HTML, PostScript or PDF designed for human modification. Examples of transparent image XCF and JPG. Opaque formats include proprietary formats that can be read and edited only by proprietary word processors, SGML or XML for which the DTD and/or processing tools are not generally available, and th e machine-generate d HTML, PostScript or PDF produced by some word essors for \"Title the title page itself, plus such following pages as are needed to hold , legibly, the material this License requires to appear in the title page. For works in formats which do not have any title page as such, \"Title Page\" means the text near the of the work's title, preceding the beginn ing of the body of text. A section \"Entitled XYZ\" means a section when you modify that it remains a section \"Entitled XYZ\" according to this definition. The Document may include Warranty Disclaimers next to the notice which states that this License applies to the Document. These Warranty Disclaimers are considered to be includ ed by reference in this License, but only as regards disclaiming warranties: any other implication that these Warranty Disclaimers may have is void and has no effect on the meaning of this License. 2. VERBATIM COPYING You may copy and distribute either commercially noncommerc ially, provided that this License, the copyright notices, and the license notice saying this License applies to the Document are reproduced in all copies, and that you add no other conditions FUOC 71Z799014MO 6 Ap\u00e9ndice: GNU Free Documentation License whatsoever to those of this License. You may not use technical measures to obstruct or control the reading or further copying of the copies you make ordistribute. However, you may accept compensation in exchange for copies.If you distribute a large enough number of copies you must also 3. under sa conditions may publicly display IN QUANTITY If you publish printed copies (or co pies in media that commonly have printed covers) of the Document, numbering more than 100, and the Document's license notice requires Cover Texts, yo u must enclose the copies in covers that carry, clearly and legi bly, all these Cover Texts: Front-Cover Texts on the front cover, and Back-Cov er Texts on the back cover. Both covers must also clearly and legibly id entify you as the publisher of these copies. The front cover mu st present the full title wi th all words of the title equally prominent and visible. You may add other material on the covers in addition. Copying with changes limite d to the covers, as long as they preserve the title of the Document and satisfy these co nditions, can be treated as verbatim other respects. the required for cover are too voluminous to fit legibly, you should put the first ones listed (as many as fit reasonably) on the actualcover, and continue the rest onto adjacent pages. If you publish or distribute Opaque copies of the Document numbering more along each Opaque a computer-network locati on from which the general network-using public has access to download using public-standard network protocols a complete Transparent copy of the Document, free of added material. If you use the latter option, you must take reasonably prudent steps, when you distribution of Opaque one last time you di stribute an Opaque copy (directly or through your agents or retailers) of that edition to the public. FUOC 71Z799014MO 7 Ap\u00e9ndice: GNU Free Documentation License It is requested, but not required, th at you contact the authors of the Document well before redistributing any large number of copies, to give them a chance to provide you with an updated version of the Document. 4. MODIFICATIONS You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above, provided that you release the Modified Version under precisely this License, with the Modified Version filling the role of the Document, thus licensing the Modified possesses a copy of it. In addition, youmust do these things in the Modified Version: A. Use in the Title Page (and on the co vers, if any) a title distinct from that of the Document, and from those of prev ious versions (which should, if there were any, be listed in the History se ction of the Document). You may use the same title as a previous version if the original publisher of that version gives permission. B. List on the Title Page, as authors, one or more persons or entities responsible for authorship of the mo difications in the Modified Version, together with at least five of the principal authors of the Document (all of itsprincipal authors, if it has fewer than five), unless they release you from thisrequirement. C. State on the Title page the name of the publisher of the Modified Version, as the publisher. D. Preserve all the copyrigh t notices of the Document. E. Add an appropriate co pyright notice for your modifications adjacent to the other copyright notices. F. Include, immediately after the copy right notices, a license notice giving the public permission to use the Modi fied Version under the terms of this License, in the form show n in the Addendum below. G. Preserve in that license notice th e lists of Invariant Sections and required copy of this License. FUOC 71Z799014MO 8 Ap\u00e9ndice: GNU Free Documentation License I. Preserve the section Entitled \"History \", Preserve its Title, and add to it an item stating at least the title, year, new authors, and publisher of the Modified Version as given on the Title Page. If there is no section Entitled \"History\" in the Document, create one stating the title, year, authors, and publisher of the Document as given on its Title Page, then add an item describing the Modified Version as stated in the previous sentence. J. Preserve the network lo cation, if any, given in the Document for public access to a Transparent copy of the Document, and likewise the networklocations given in the Document for previous versions it was based on. These may be placed in the \"History \" section. You may omit a network location for a work that was published at least four years before theDocument itself, or if the original publ isher of the version it refers to gives For any section Entitl ed \"Acknowledgements\" or \"Dedications\", Preserve the Title of the section, and preserve in the sect ion all the substance and tone Sections of the Document , unaltered in their text and in their titles. Sec tion numbers or the equi valent are not considered part \"Endor sements\". section may not be included in the Modified Version. N. Do not retitle any existing section to be Entitled \"Endorsements\" or to conflict in title with any Invariant Section. O. Preserve any Wa rranty Disclaimers. If the Version includes Secondary Sections and contain no material copied from the Document, you may at your option designate some or all of these sections as invariant. To do this, add their titles to the list of Invariant Sections in the Modified Version's license notice. These ti tles must be distinct from any other section Free Documentation License example, statements of p eer review or that the te xt has been approved by an organization as the authoritative definition of a standard. You may add a passage of up to five words as a Front-Cover Text, and a passage of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified Version. Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or th rough arrangements made by) any one entity. If the Docume nt already includes a cover text for the same cover, previously added by you or by arrangement made by the same entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit pe rmission from the previous publisher that added the old one. The author(s) and publisher( s) of the Document do not by this License give permission to use their names for pu blicity for or to assert of any Modified Version. 5. COMBINING DOCUMENTS You may combine the Document with other documents released under this License, under the terms defined in se ction 4 above for modified versions, provided that you include in the combination all of the Invariant Sections of all of the original documents, unmodified, and list them all as InvariantSections of your combined work in it s license notice, and that you preserve all their Warranty Disclaimers. The combined work need only contain one copy of this License, and multiple identical Invarian t Sections may be replaced with a single copy. If there are multiple Invari ant Sections with the sa me name but different contents, make the title of each such section unique by adding at the end of it, in parentheses, the name of the original author or publisher of that section if known, or else a unique number. Make the same adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work. In the combination, you must combine an y sections Entitled \"History\" 71Z799014MO 10 Ap\u00e9ndice: GNU Free Documentation License 6. COLLECTIONS OF DOCUMENTS You may make a collection consisting of the Document and other documents released under this License, and replace the individual copies of this License in the various documents with a single copy that is included inthe collection, provided that you follow the rules of this License for verbatimcopying of each of the documents in all other respects. You may extract a single document from such a collection, and distribute it individually under this License, provid ed you insert a copy of this License into the extracted docume nt, and follow this License in all other respects regarding verbatim copying of that document. 7. AGGREGATION WITH INDEPENDENT WORKS A compilation of the Document or its derivatives with other separate and independent documents or works, in or on a volume of a storage ordistribution medium, is ca lled an \"aggregate\" if th e resulting from the compilation is not used to limit the legal rights of the compilation's users beyond what the individual works permit. When the Document is included in an aggregate, this License does not apply to the other works in the aggregate which are not themselves derivative works of the Document. If the Cover Text requirement of sectio n 3 is applicable to these copies of the Document, then if the Document is less than one half of the entire aggregate, the Document's Cover Te xts may be placed on covers that bracket the Document within the aggregate, or the electronic equivalent of covers if the Document is in electronic form. Otherwise they must appear on prin ted covers that bracket the whole aggregate. 8. TRANSLATION Translation is considered a kind of modification, so you may distribute translations of the Document under the terms of section ReplacingInvariant Sections with from their FUOC 71Z799014MO 11 Ap\u00e9ndice: GNU Free Documentation License copyright holders, but you may include tr anslations of some or Invariant original e Invariant Sections. You may include a translation of this License, and all the license notices in theDocument, and any Warranty Disclaimers, provided that you also include the original English version of this Lice nse and the original versions of those notices and disclaimers. In case of a disagreemen t between the translation and the original version of this License or a notice or disclaimer, the original version will prevail. If a section in the Document is Enti tled \"Acknowledgements\", \"Dedications\", or \"History\", the requiremen t its Title (section 1) will typically require changing the actual title. You may not copy, modify, sublicense, or distribute the Document except as expressly provided for under this Licens e. Any modify, sublicense void, automatically terminate your rights under this License. However, parties who have received copies, or rights, from you un der this License will not have their licenses terminated so long as such parties remain in full compliance. 10. FUTURE REVISIONS OF THIS LICENSE The Free Software Foundati on may publish new, revised versions of the GNU Free Documentation License from time to time. Such new versions will be similar in spirit to the present versio n, but may differ in detail to address new problems or concerns. See Each of the License is given a distinguishing version number. If the Document specifies that a particular numbered version of this License \"or any later version\" applies to it, you ha option following the terms and conditions either of that specified version or of any la ter version that has been published (not as a draft) by the Free Software Foundation. If the Document does not specify a version number of this License, you may choose any version ever published (not as a draft) by the Free Software Foundation. FUOC 71Z799014MO 12 Ap\u00e9ndice: GNU Free Documentation License ADDENDUM: How to use this License for your documents To use this License in a document you have written, include a copy of the License in the document and put the fo llowing copyright an d license notices just after the title page: Copyright (c) YEAR YOUR NAME. Permission is granted to copy, distribute and/or modify this the terms of the GNU Free Docu mentation License, Version 1.2 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A c o p y o f t h e l i c e n s e i s i n c l u d ed in the section entitled \"GNU Free Documentation License\". being LIST THEIR TITLES , with the Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST. If you have Inva riant Sections without Cover Texts, or some other combination of the three, merge those two alternatives to suit the situation. If your document contains nontrivial examples of program code, we recommend releasing these examples in para llel under your choice of free software license, such as the GNU Gene ral Public License, to permit their use in free "}