{"title": "PDF", "author": "PDF", "url": "https://ai.uga.edu/sites/default/files/inline-files/kommineni_rajesh.pdf", "hostname": "PDF", "description": "PDF", "sitename": "PDF", "date": "PDF", "cleaned_text": "SYSTEMS INTEGRATION IN THE FORESTRY DOMAIN by RAJESH K. KOMMINENI (Under the direction of Dr. Walter D. Potter) ABSTRACT The change in the user requirements over the years, has underscored the need for the integration of multiple information sources into a single viable source. In Information technology, legacy systems and data are those that have been inherited from languages, platforms and techniques earlier than the current technology. Integration of such heterogeneous applications is a difficult ta sk. This thesis proposes a framework called Open Intelligent Information System for Fore stry Domain (OIISFD) for integrating such applications in the forestry domain. OIISFD contains three components, namely, the inference component, the knowledge com ponent and the legacy component. The inference component contains applicati on description knowledge (\"what does the application do\"), domain specific knowledge and a reasoning module for handling user queries. The knowledge component contains application specific knowledge (\"how to run the application\"), input/output criteria a nd special vocabulary associated with the application. The legacy component contains le gacy applications with their wrappers. The entire framework is developed on COM/DCOM platform, with XML (Schema) being used for knowledge representation and fo r communication mechanisms between the different components. INDEX WORDS: Forestry Information Systems, Systems Integration, Intelligent Information systems, XML Schemas and Embeddable Prolog. SYSTEM INTEGRATION IN THE FORESTRY DOMAIN by Rajesh K. Kom mineni B.E., MNREC, India, 1998 A Thesis Subm itted to the Graduate Faculty of The University of Georgia in Partial Fulfillment of the Requirem ents for the Degree MASTER OF SCIENCE ATHENS, GEORGIA 2002 2002 Rajesh K. Kom mineni All Rights Reserved SYSTEM INTEGRATION IN FORESTRY DOMAIN by RAJESH K. KOMMINENI B.E., MNREC, India, 1998 Approved: Major Professor: W alter D. Potter Com mittee: Dr. Suchi Bhandarkar Dr. Eileen Kraem er Electronic Version Approved: Gordhan L. Patel Dean of the Graduate School The University of Georgia May 2002 DEDICATION I dedicate this thesis to m y parents. iv ACKNOWLEDGEMENTS I would like to express m y sincerest gra titude to Dr. W alter D. Potter, m y major professor, for his constant support and en couragem ent and invaluable advice throughout this challenging thesis project. I also wish to thank m y other com mittee m embers, Dr. Suchendra Bhandarkar and Dr. Eileen Kram er, for their support and advice. My special thanks to Priyanka P. Brahm achary for putting up with m e throughout this challenging period. v TABLE OF CONTENTS Page ACKNOWLEDGEMENTS ................................................................................................ v CHAPTER 1. INTRODUCTION .................................................................................................. 1 1.1 System s integration in forestry dom ain...................................................... 3 2. BACKGROUND AND RELATE D WORK.......................................................... 8 2.1 Open System s Approach ............................................................................ 9 2.2 Current trends in inform ation system s architecture ................................. 11 2.3 Current trends in Knowledge Base System s............................................ 17 3. XML ..................................................................................................................... 21 3.1 XML Ba ckground .................................................................................... 21 3.2 XML Schem as and its Advantages over DTDs ....................................... 22 3.3 XML as a Knowledge Representation Language ..................................... 24 3.4 Advantages of XML in system s integration ............................................. 30 3.5 XML Nam espaces .................................................................................... 31 4. DESIGN AND IMPLEMENTATI ON................................................................. 33 4.1 Design Goals ............................................................................................ 33 4.2 Open Intelligent Inform ation System for Forestry Dom ain (OIISFD) ....35 4.3 Knowledge Com ponent ............................................................................ 40 4.4 Inference Com ponent ............................................................................... 42 vi vii 4.5 Legacy Com ponent .................................................................................. 44 4.6 OIISFD Im plementation ........................................................................... 48 5. RESULTS............................................................................................................. 53 5.1 OIISFD Screen shots ................................................................................ 54 6. CONCLUSI ONS AND FUTURE DIRECTIONS ............................................... 61 7. BIBLIOGRAPHY ................................................................................................ 63 APPENDIX A HEADER FILES OF IMPORT ANT C++ CLASSES OF OIISFD ................... 66 B PROLOG SOURCE FOR REASONING .......................................................... 71 CHAPTER 1 INTRODUCTION The Internet has revolutionized the entir e concept of inform ation. In the past, information was to a large extent \"stationary \" in the sense that its reusability was lim ited. Excellent progress in interconnection afford ed by the internet, web and distributed computing infrastructures has led to an eas y access to a large num ber of independently created and m anaged inform ation resources of broad variety. This in turn has resulted in dram atic changes in the design of inform ation system s. Current inform ation system s are designed such that they can be scalable and reusable. The trend is towards developm ent of sm all, individual, non-m onolithic units that can be em bedded in the web of inform ation technology. In the past, applicati ons were developed without m uch foresight of their reusability and scalability. These applications can be ref erred to as legacy applications as they are rigid and not am enable to present day changes. In inform ation technology, legacy applications and data are those that have been inherited from languages, platform s, and techniques earlier th an current technology. Integration of these legacy applications into current system s is a very difficult task. Over the years com puter user's requirem ents have changed. He/she no longer wants to gather inf ormation f rom multiple sources but pref ers a single source. For exam ple, one of the requirem ents for NED-1 was to develop a com puter program that would com bine all the previously independe ntly produced growth and yield m odels 1 2 developed by scientists within the station (Twery, 1997) . This change in the requirem ents led to a need f or integration of multiple inf ormation resources into a single resource. There are various problem s associated with the integration of multiple inform ation sources into a single source. In the forestry dom ain, briefly, the problem s are: heterogeneity of applications, absence of program matic interf aces into applications, rigid input and output form ats, lack of reusability, scalability of proposed architectures, expensive knowledge acquisition process and m aintainability and little or no use of domain expert's knowledge in problem solvi ng. These problem s hinder the integration of multiple applications. This thesis proposes an architecture for overcom ing the above problem s. W e propose to use a knowledge representation language that is easy to author and to interpret (by dom ain experts them selves). This strategy will lessen the expensive process of knowledge acquisition and m aintainability of the system . We also propose to use a common m arkup language to describe the output and input file form ats of the applications. This helps in easing the interoperability process between various applications. The fram ework for this archite cture encodes the knowledge of applications in such a way that it can be reusable and c ontain dom ain expert's knowledge that is very useful in decision-m aking process. To test various proposed ideas in the thes is, a fram ework has been developed with two interacting applications. The knowledge of these applications is encoded in a m arkup language and has been used for decision-m aking. Interfaces have been developed to translate rigid input/output file form ats in to a com mon language and thereby reduce the difficulty in conversion of the data between applications. The entire fram ework is 3 developed on a platform that is guaranteed to handle the various issues involved with heterogeneous nature of the applications. This im plem entation includes a sophisticated intelligent m odule that is extensible and aids in decision-m aking. The process of integrating an application into the fram ework is as follows: Describe the various knowledge types (\"what\" does the application do and if necessary, \"how\" to run the applicati on, special vocabulary associated with the application). Describe the input and output form ats of the application in a m arkup language. Develop a wrapper that provides an interf ace into the application in the form at proposed by the fram ework. Develop the graphical user interface screens that m ight help the user. Once the above steps are fulfilled for an application, this application can be integrated into the f ramework. Even though this fram ework has been im plem ented only in the forestry dom ain, the proposed architecture can be applied to any dom ain with relative ease. 1.1 Systems integration in forestry domain Decision Support System s (DSSs) are interactive com puter-based system s intended to help decision m akers utilize data and m odels to identif y and solve problem s and m ake decisions. The \"system must aid a decision m aker in solving unprogram med, unstructured (or \"sem i-structured\") problem s...the system must possess an interactive query facility, with a query language that ...is ...easy to learn and use (Bonczek, 4 Holsapple & W hinston, 1981; p. 19)\". They are designed to assist m anagers in their decision processes in sem i-structured (or unstr uctured) tasks. They support, rather than replace, m anagerial judgm ent; and their objectiv e is to im prove the effectiveness of the decisions, not the efficiency with which decisions are being m ade. Several Decision Support System s have been developed over the years for providing useful scientific data for the m anagement of forest eco-system s. A typical decision support system for forest eco-syste m managem ent contains a user interface, database, geographical inform ation system (GIS), a knowledge base, sim ulation and optim ization m odels, help/hypertext m anage ment, data visualization and decision methods (Rauscher 1999). There have been more than thirty Forest Ecosystem Managem ent (FEM)-DSSs developed for use in the United States with dif ferent FEM- DSSs supporting different parts of the eco-system managem ent process (Mowrer et al. 1997). There is not a single FEM-DSS that is com petent enough to deal with issues concerning both ecological and m anagem ent interaction in f orest eco-system managem ent (Liu 1998). An ideal FEM syst em therefore requires all available DSSs (Potter et al. 1998). This can be accom plished by integration and enhancem ent of existing system s rather than developing a totally new system . The two m ain issues that concern the integration of forestry applications are: Heterogeneity of the application . Most FEM-DSSs were developed indepe ndently of one another with little or no coordination between m ost of them , leading to a heterogeneous developm ent environm ent (Liu 1998). Most of them were developed to run on one m achine and if 5 they had to be integrated into a distri buted system , their heterogeneous platform s played an im portant role. Legacy Systems . Most of the FEM system s are legacy system s, written in languages like FORTRAN and have a com mand line interface. These legacy system s are not designed for a distributed technology and they are not am enable for reuse and extension. They are the stereotypic, m onolithic, closed system s that are expensive to m aintain (Liu 1998). Their integration into current FEM-DSS is not a trivial issue and requires m uch effort . (Liu, 1998) has identified several features fo r more effective decision support for forest ecosystem managem ent: Various existing decision support system modules have to be integrated so that they can interoperate. This interoperable fram ework should offer an interface standard that prom otes communication between com ponent m odules. It should also be possible to integrate newly developed m odules and refine current ones over tim e, if necessary. This fram ework should provide language in teroperability, platform independence, module com munication m echanism s, object reusability and interfacing standards for dealing with legacy system s. 6 This thesis takes into consideration the various f eatures of Liu's m odel f or effective decision support for forest ecosystem managem ent. The thesis m ainly f ocuses on two things: The architecture for integration system and com munication m echanism s between different com ponents of the architecture. Representation of Knowledge and Data of legacy system s and developm ent of wrappers (interface standards) for the legacy system s with prim e importance to their reusability. It uses the Forest Vegetation Sim ulator (FVS) as a testing ground for the proposed ideas. This thesis is organized as f ollows: The second chapter exam ines the integration system called the Intelligent Inform ation System (IIS) (Som asekar, 1999), which has been proposed for the FEM system . It identifies the inherent disadvantag es of the architecture of IIS. This chapter describes the guidelines or features that an individual m odule in FEM should possess, using an open system s approach. It exam ines the architectures of current generation information system s. This chapter brief ly describes two architectures f or inf ormation system s: Mediator based inform ation architecture Inform ation brokering architecture This chapter also describes the knowledge engineering principles behind the current generation knowledge based system s. This thesis uses the Extensible Markup Language (XML) as a m eans for communication between the different m odules of OIISFD. The third chapter contains 7 background of XML and its role in the proposed ar chitecture. It also analyzes the features in XML that can be used to represent knowledge. The fourth chapter contains the proposed architecture for FEM, called Open Intelligent Inf ormation System for Forestry Do main (OIISFD). This chapter explains how platform independence and language neutrality can be achieved using the Distributed Com ponent Object Model (DCOM) as a platform for OIISFD. The three m ain components of OIISFD are: Knowledge Com ponent Legacy Com ponent Inference Com ponent This chapter also contains im plem entation details of the above com ponents. The fifth and sixth chapters contain resu lts and conclusions respectively. The fifth chapter describes various queries that are handled by the proposed architecture and screen shots of the im plem entation. CHAPTER 2 BACK GROUND AND RELATED WORK Much research has been done on the archit ectures for inform ation system s (Sheth, 1998). These sam e architectures can also be applied for the developm ent of FEM-DSSs. NED-1 (Twery et al., 1997), is a goal driven, full service ecosystem managem ent system developed for the eastern US. It provides ba seline analyses of conditions needed for multiple resource m anagem ent areas that are com posed of a set of forest stands. The architecture is essentially a client-server archit ecture. It is a standalone system and hence, does not have distributed processing capability. More over, it does not address the issues related to legacy applications. It is not plat form or language independent and it is difficult to add m ore forestry applications to it (Liu, 1998). In order to circum vent the above di fficulties, Som asekar (1999) proposed the Intelligent Inform ation System (IIS) m odel. Th is system contains three m odules: legacy applications and wrappers, client interface m odule and an Intelligent Inform ation Module (IIM). The IIM contains production rules, whic h are triggered according to the user's request. It then runs the appropriate applicati on with the help of wrappers and returns the results to the user. The setbacks of this m odel are as f ollows: Intelligence (in the form of production rules) of the integrated system is centralized. Ownership of these production rules is a problem . This results in a difficulty to m aintain 8 9 the system . Addition or deletion of any of the production rules lead to a tem porary dysfunction of the system . The wrappers built f or the legacy applications are custom wrappers that have to be changed when inte grated into another system . Integrating a new system into the above system is very diffi cult. The knowledge and effort invested in developing these custom wrappers is not re usable. This custom wrapper needs to be modified if the current legacy system wants to interact with another system . Hence, it is essential that we have n-n wrappers for in teraction between n applications. Also, there are no standards used for com munication between the different m odules of the IIS m odel. We get a few pointers from the disadvant ages of the above m odel. Prim arily, a legacy system should be m ade \"open\". The fram ework should be developed keeping in mind its future extensibility. Standards should be used when ever possible. Reusability should be given prim e importance. 2.1 Open Systems Approach An open system (SEI, 1986) can be defined as a system , with characteristics that com ply with specif ied, publicly m aintained, readily av ailable standards and that therefore can be connected to other system s that com ply with these sam e standards. An open system (SEI, 1990) can also be defined as A collection of interacting software, hardware, and hum an com ponents Designed to satisfy stated needs With interface specifications of its com ponents that are Fully defined Available to the public 10 Maintained according to group consensus In which the im plem entations of the components conform to the interface specifications. An open system s approach for system s integration can be described in the following steps Adopt standard interfaces Acquire com ponents Integrate com ponents Use & support the integrated system s This approach when com pared to the traditional approach differs in the first two steps. In a traditional approach, instead of adopting standard interfaces, unique interfaces are defined. Also, instead of acquiring com pone nts, unique com ponents are developed. The differences between the two approaches are outlined in figure 2.1 Figure 2.1 Differences between Traditional and Open System s approach (SEI, 1990) 11 2.2 Current trends in information systems architecture Sheth et al (Sheth, 1998) have describe d the changing focus towards developing inform ation system architectures. Accordi ng to them , the evolution of inform ation system s, in the context of interoperability, has occurred in three generations. Generation I covers the period up to roughly 1985, Genera tion II covers the decade through 1995, and Generation III covers a period yet to be bound from 1996. The various features evolved during the different generations are as follows: 1. Software and inform ation system architecture Generation I Term inal access, point-to-point; m ainfram es and m inicom puters with remote access, client-server Generation II Client-server; Generation III Network, distributed and m obile 2. Key hum an roles in supporting interoperability Generation I Data (base) adm inistrators or experienced users, software developer written access program s Generation II Software developers to generate wrappers and m ediators (with som e toolkits) involving data level issues Generation III Dom ain experts for developing ontologi es and for generating inform ation correlations 12 An ontology can be defined as a sp ecific vocabulary and relationships used to describe certain aspects of reality, and a set of explicit assum ptions regarding the intended m eaning of the vocabulary of words (Gruber 1991; Guarino 1998). Ontologies are used to m ap dom ain specific information to a set of rules and axiom s. 3. Dom inant interoperability architecture Generation I Multidatabases or f ederated databases During this generation, there was m ore em phasis on achieving system interoperability, in particular, by a ddressing the heterogeneity due to differences in DataBase Managem ent System s (DBMSs). Correspondingly, the em phasis was on data m anagem ent and data (as opposed to inform ation or knowledge). More inform ation on the work that took place during this generation can be found in the contex t of m ultidatabases (Litwin et al. 1982) and federated database syst ems (Heim bigner and McLeod 1985; Sheth and Larson 1990). Generation II Federated inform ation system s, mediator architectures According to Sheth et al (Sheth, 1998), the key trends and achievem ents of this generation are as f ollows: Technology for dealing with heterogeneity of system s, data, and representational levels; Support for a broader variety of data - not just structured databases, but also text, sem i-structured, a nd unstructured (including im age and video) data Some of the system s in this generation adapted the Federated DataBase System s (FDBS) (Heim bigner a nd McLeod 1985; architecture to f ederated inf ormation system s architecture. However, the mediator architectures (W iederhold 1992) were clearly the dom inant ones, involving wrappers for encapsulating he terogeneous inform ation sources to provide a m ore uniform interface to the rest of the world. Generation III Mediator architectures, inform ation brokering architectures These architectures are described in detail in the later sections of this chapter. 13 As m entioned above the dom inant third generation inform ation architectures are based on mediators and inform ation brokers. 2.2.1 Mediator-based Information Architecture In m ediator-based inform ation architectures (W iederhold, 1992), the inform ation creators and providers are d ecoupled from inform ation users. Here, inform ation creators and providers are hete rogeneous inform ation sources. The m ain difference between creators and providers is the way they own inform ation. Inform ation creators, when requested, obtain inform ation from a rem ote source that is not known locally. They contain support for rem ote com munication. Inform ation providers are static inform ation sources like databases. The m ediator-based inform ation architecture is prim arily com posed of three distinct laye rs that form a pyram id. The inform ation providers and creators form the base of the pyram id (Fig 2.2). The m ediators fall in the center of the pyram id while the inf ormation user s form the apex as the application layer. Mediators bridge the gap between the inform ation creators/providers and the inform ation users. This whole architecture m akes ex tensive use of wrappers. A wrapper encapsulates a single data source to m ake it us able in a m ore convenient fashion than the original unwrapped source. The user requests inform ation from the m ediator who queries the wrapper to retrieve the inform ation. The wr appers convert the m ediator's query to the source level queries. The wrapper translates the language for the m ediator and m akes it possible for the m ediator to deal with only one language. 14 Figure 2.2 Functional Layer of Mediator ba sed inform ation system (Wiederhold, 1997) 15 2.2.2 Information brokering Architecture This architecture is heavily based on the use of agent technology (Martin, 1997). An inform ation brokering system provide s coordinated access to a heterogeneous collection of structured and sem i-structure d inform ation sources (Sheth, 1998). In this architecture, a broker agent accepts the reque sts from the user. The broker agent then with the help of a facilitator agent f orwards the requests to the source agent(s). Af ter retrieving the inf ormation f rom the agent(s), the broker agent integrates the requested inf ormation and gives the result to the user. The source agent(s) that is in charge of the application (inform ation sour ce) possesses a high degree of independence and autonom y. It can be created, adm inister ed and enhanced independently. Figure 2.3 depicts ideal inform ation brokering system s architecture. In this figure BQ (Broker Query) and BR (Broker Response) refer to ite ms expressed in the broker schem a whereas SQ (Source Query) and SR (Source Response) refer to item s expressed in the source schem a. RDB abbreviates Relation Data Ba se and KB abbreviates Knowledge base. Schem a, here, is essentially the sam e as a relational data base schem a. From developer's point of view, equivalently, it m ay be thought of as a collection of Prolog Predicates. 16 Figure 2.3: Inform ation brokering system architecture 17 2.3 Current trends in Know ledge Base Systems A Knowledge Base System (KBS) is a sy stem that represents an application containing a significant am ount of real know ledge, and has been designed, im plem ented and possibly m aintained with due regard for the structure of the data, inform ation and knowledge (Durkin, 1994). In the early 1980s, the developm ent of KBS was seen as a process of transferring human knowledge to an im plem ented knowledge base (Studer etal.1999). The knowledge in these generation\" KBSs is in the form of associational rule-of-thum b the m apped from observable features to conclusions. T ypically, knowledge was im plem ented in som e type of production rules that were executed by an associated rule interpreter. These system s solved problem s by chaining rules together, either forward (from prem ises to conclusions) or back ward (from goal to in itial conditions). Thus, early KBSs typically had a sim ple control structure and uniform representation of knowledge, in the form for associational production rules. The knowledge was typically represented at a single level of abstraction and im plicitly com bined knowle dge about \"how\" to perform a task, \"what\" is in the dom ain, and \"why\" things work. W hile it was initially thought that this would make system s fairly easy to develop, in fa ct it leads to several problem s related to knowledge acquisition, explanation, brittleness and m aintainability. Because of these problem s, this transfer approach was onl y feasible f or the developm ent of small prototypical system s. This approach failed to produce large, reliable and m aintainable knowledge base (David etal. 1993). The above problem s resulted in a paradigm shift from the transfer approach to the modeling approach (Studer etal. 1999). This pa radigm shift was inspired by Newel's 18 knowledge level notion (Newell, 1982). The second generation KBSs can be distinguished from the earlier KBSs in the following ways: The knowledge is m odeled independently from its im plem entation Different knowledge form alism s are us ed for representing various knowledge types. The control knowledge (\"how\" to perform a task) is explicit. The control knowledge m entioned above is the rationale behind the use of Problem - Solving methods (PSMs) (Fensal etal., 1996). This thesis uses two types of knowledge (and their corresponding PSMs) for decision- making. The following sections provide their necessary background. 2.3.1 Associational Know ledge and Production Systems Production system s are com posed of three com ponents (Peter, 1998). These are: The rule set A working storage area which contains the current state of the system An inference engine that knows how to apply the rules The rules are of the form : left hand side (LHS) ==> right hand side (RHS). The LHS is a collection of conditions that m ust be m atched in working storage for the rule to be executed. The RHS contains the ac tions to be taken if the LHS conditions are met. The execution cycle is: 1. Select a rule whose left hand side conditi ons m atch the current state as stored in the working storage. 19 2. Execute the right hand side of that rule, thus som ehow changing the current state. 3. Repeat until there are no rules that apply. Production system s can be im plem ented in any program ming language such as C, C++, Java or Prolog. Prolog is usually preferred over other program ming languages (Peter, 1998). The expressiveness of Prolog is due to three m ajor features of the language: rule-based program ming, built-in pattern m atching, and backtracking execution. The rule-based program ming allows th e program code to be written in a form that is m ore declarative than procedural. This is m ade possible by the built-in pattern matching and backtracking that autom atically provide for the flow of control in the program . These features together m ake it po ssible to elegantly im plem ent m any types of production system s. Goal driven reasoning or backward chaining is an inference technique that uses IF THEN rules to repetitively break a goal into smaller sub-goals that are easier to prove. This is an ef ficient way to solve problem s that can be m odeled as \"structured selection\" problem s. That is, the aim of the system is to pick the best choice from many enum erated possibilities. For exam ple, an identification problem falls in this category. Diagnostic system s also fit this m odel, si nce the aim of the system is to pick the correct diagnosis. The features of prolog m ake it an ideal language for goal driven reasoning system . On the other hand, Data driven reasoning or forward chaining is an inference technique that uses IF THEN rules to deduce a problem solution f rom initial data. Production system s are usually called forwar d chaining system s (Elaine etal, 1991). A forward chaining reasoning can be im plem ented using Prolog. The features of Prolog make it an ideal language to im plem ent rule-based forward chaining inference engine. 20 2.3.1 Ontologies and Frame-logic ontology can be defined as a specific voca bulary and relationships used to describe certain aspects of reality, and a set of explicit assum ptions regarding the intended meaning of the vocabulary of words (Grube r 1991; Guarino 1998). Ontologies are used to m ap dom ain specific inform ation to a set of rules and axiom s. One way to represent ontology is to use fram es (Karp et al. 1995). A fram e is a collection of attributes (usu ally called slots) and associated values (and possibly constraints on values) that descri be som e entity in the world (Rich et al. 1991). An own slot of a fram e has associated with it a set of own facets, and each own facet of a slot of a fram e has associated w ith it a set of entities called facet values. Fram e system s are built out of collections of fr ames that each other by relationships. An exam ple relation is a-kind-of . This relationship is used for inheritance. CHAPTER 3 XML This thesis uses XML for two purposes: for com munication m echanism s between different com ponents and as a knowledge representation language. The following sections describe the features of XML and the rationale behind using XML as a knowledge representation language. 3.1 XML background eXtensible Markup Language (XML) (XML, 1998), a subset of Standard Generalized Markup Language (SGML), is desi gned to be the universal data exchange language, with a special status as the next generation language. XML is different from other previous data exchange f ormats in its two m ajor characteristics: extensibility and self-description. XML is extensible in that any author can extend the tags used in an XML docum ent to m eet his/her own needs for the docum ent. XML is self -describing in that the tags in an XML docum ent express the structure of the docum ent and, in m ost cases, the intention of the author as well. What makes XML even m ore attractive for m any other purposes, and to a certain degree m ore self-describing, is the existence of Docum ent Type Definition (DTDs) and XML Schem as (XML Schem as, 2000). XML Schem as (and DTDs) state the structure of an XML docum ent and specify the allowed elem ent types and the characteristics of each 21 22 elem ent type, and also its allowed attributes. Although a XML Schem a is optional for an XML docum ent, its existence is valuable for m any practical purposes. Both XML Schem as and DTDs can be us ed to represent the knowledge. This thesis uses XML Schem as to represent the knowledge. The following section explains the rationale behind using XML schem as (over DTDs ) and its features that are useful for knowledge representation. 3.2 XML Schemas and its Advantages over DTDs Even though XML schem as and DTDs both are used to do the validation of the docum ent, Schem as are preferred over DTDs in this thesis for the following reasons: DTDs are Difficult to W rite and Understand DTDs use a syntax other than XML, namely Extended Backus Naur Form (EBNF), and m any people find it difficult to read and use. The proposed XML schem as, however, actually use XML to describe the languages they define, removing the difficulty of learning EBNF before learning to read and write them . Program matic Processing Of Metadata Is Difficult The use of EBNF also m akes the autom atic processing of m etadata in DTDs difficult. It is not possible to inquire into the DTD from a program using the Docum ent Object Model (DOM). Th e DOM m akes no provision for gaining access to vocabulary's m etadata wr itten in EBNF. Hence, ation associated with the docum ent won't be available for processing. Since schem as are written using XML syntax, this problem of program matic processing of m etadata can be overcom e. 23 DTDs Are Not Extensible And Do Not Provide Support For Nam espaces All the rules in a vocabulary m ust exis t in the DTD. One can't borrow f rom other sources without creating extern al entities. Creating and m aintaining subsets of m arkup declarations isn't as flexible as sim ply referring to an existing definition. As all rules in a voc abulary m ust exist in the DTD, one cannot m ix nam espaces. While one can use a nam espace to introduce an elem ent type into a docum ent, he/she cannot use a nam espace to refer to an elem ent declaration in a DTD. If a nam espace is used, all elem ents from the nam espace m ust be declared in the DTD. DTDs Do Not Support Data Types DTDs offer few data types other than te xt. This is a serious shortcom ing when using XML in a knowledge-based application. DTDs Do Not Support Inheritance With DTDs there is no way of expressing inheritance. So if we have an entity called plot, there is no way one can say th at plot entity is a subclass of forest entity. Due to the above reasons XML schem as are used in the proposed architecture. To understand how well XML is suited fo r knowledge representation purposes, an exam ination of the sem antic expressiveness is useful here. 24 3.3 XML as a Know ledge Representation Language Semantic Expressiveness The expressiveness of XML can be ex amined by studying XML Schem as (XML Schem as, 2001). XML Schem as include four types of declarations: element declaration, attribute declaration, entity declaration and notation declaration . An elem ent describes a minimal section of XML texts, and the com bination of all the elem ents described in XML Schem as form the contents of XML. Each XML docum ent has exactly one root elem ent, which indicates what kind of docum ent it is and encom passes all other elem ents in the docum ent. Each elem ent has an optional attribute list, which further describes the elem ent. The basic com ponents of an attribute are attribute nam e, attribute type, data type and default value. The following features are present in XML Schem as that can be used for knowledge representation: Enumeration For any XML elem ent or attribute, it is necessary to be able to enum erate the possible values for it. In knowledge representation languages, it is necessary som etimes to enum erate all instances of a class or all possible values for a slot. XML Schemas fully supports enumeration and has a mechanism for specifying a default value for an element or attribute. The fact that SouthEastern elem ent m ay contain elem ents of type GeorgiaState or FloridaState can be represented ents can be enum erated. \"default\" keyword is used to m ake one of the elem ents to be default. Optional An XML Schem a has the capability to indi cate whether som e attribute or elem ent is optional. This is necessary for knowledge representation purposes. Som etimes additional properties of an object m ight help for inference purposes with out m aking the classification of the object difficult. Such a dditional properties can be m ade optional. For exam ple, we need to indicate whether som e aspect of a class definition is optional. XML Schemas also have various other symbols to express \"one or more occurrences\" and \"zero or one occurrence\" SpeciesNam e and SpeciesCode are two elem ents that are usually present in data f iles of Forestry Applications. SpeciesCode elem ent is necessary for calculating different properties of a tree while SpeciesNam e elem ent is present for inform ational purposes. This fact that SpeciesCode elem ent shoul d always present and SpeciesNam e elem ent presence is optional can be represented using XMLSchem as follows: the keyword \"m inOccurs\" is used to specify whether the elem ent is optional or not by m entioning its count. 26 Value Restriction XML Schem as supports value restriction. W e can specify the possible values of an elem ent. In other words, XML Schemas can be used to indicate what class the value type of an element or attribute . The fact that the value of the elem ent quantity should not exceed 100 can be represented in XML Schem as as f Types The structures defined for XML Schem as rely heavily on type definitions. These allow declaring extended types that can be used throughout a schem a. They will be used to specify the content and type of elem ents and attributes. Current XML is used m ostly for general-purpose texts, where a few ve ry basic types are enough. However, for knowledge representation and various other pur poses, we need the capability to express more com plicated data types and m athem atic expressions. XML Schemas can be used to represent complex data types using type definitions but not mathematical expressions . Additional support can be added at the processing level (of the schem as) to handle mathem atical expressions. By using value restriction, value extension and grouping of elem ents, com plicated data types can be defined. For exam ple, a telephone num ber contains the form at ddd-dddd. A new data type called TelephoneNum ber can be defined that conform s to the above form at as follows: are sem i-structured data, which m eans that data in an XML docum ent is not as precisely structured as that in a database. However, for knowledge representation as well as m any other purposes like for handling com munications between different m odules, XML optionally support st rong data typing. W hat strong data typing will achieve is to ensure what is purported to be within a pair of tags is truly the type of data the tags say it is. For exam ple, in order to ensure what is extracted out of the <birthrate> </birthdate> tag pair is truly a da te type, we want to m ake sure there is no other random text between the tags. For exam ple, <date> is 4/8/99</date> is not valid, but <date> 4/8/99 </date> is valid. XML Schemas support strong data typing. With th e help of schema support, we can make sure the data between tags is of the type we wanted. For exam ple the elem ent m oney is a currency sign, followed by one or m ore digits, optionally followed by a period and two digits. This can be represented in XML Schem as with out any problem . <cost>$45.99</cost> Grammar Further sem antic expressiveness also re quires a gram mar for XML Schem as. The gram mar will specif y the allowed f ormats of what goes between a pair of tags. The elem ent type of an elem ent can be of vari ous form s. XML Schem as, with the help of enum eration property, can specify the allowed form ats. For exam ple, there are num erous form ats for expressing <date>, such as \"Month/Date/Year\" or \"Date/Month/Year\". Knowing what form ats are allowed in a certain XML docum ent not only enables XML authors to correctly write XML docum ents, but also helps different software applications to correctly interpret and extract XML docum ents. Currently, XML Schemas have extensive built-in data types . More com plex data types can be derived using these built-in data types. Validation Currently, validated XML docum ents refer to docum ents that conform to an XML Schem a. Validation m eans that the docum ent c ontains the allowed elem ents and does not violate the specified structure of the tags . However, the validation validates the content of the document to a certain extent only . Schema Interaction XML Schem as are specif ic entities that speci fy the structures of different XML docum ents. However, the method for inter-referencing between XML Schemas is achieved through XML names spaces . For exam ple, the citizenship of any person needs to be of the \"country\" type. In any Schem a that includes the <citizenship> tag, it does not have to define the country class. Through nam espaces by referring the <citizenship> that 29 it belongs to <country> Schem a, we can de velop interaction between two different Schem as. For attaining the above interaction we have to first declare the Nam espace country using im port statem ent type=\"CountrySchem XML Schem as provide reusability. It also avoids the problem s of ambiguities and name collisions of tags. The features that are partially supported in XML Schem as that can be used for knowledge representation purposes are: Representing Axioms An im portant power of knowledge representa tion languages is that they support axiom representation. Current XML Schem as (XML Schem as, 2001) specification can express the attributes/elem ent types for different attributes/elem ents, but does not provide methods for expressing the relationships between elem ents and/or between attributes. The relationships that can be specified using XML Schemas are Inheritance and Composition. More com plex relationships can be achieved by custom validation of the docum ents. With all the sem antic aspects m entione d above, we have an XML Schem a that provides reasoning support and is expressive in m any dim ensions. The sem antics and expressive power of the XML Schem as is m ore in line with that of a general knowledge 30 representation language. The positive effect that comes out of this is the same language for representing knowledge as well as data while other languages or representations fail to achieve the same . (Kent, R 1999) has shown that DTDs are as expressive as ontologies. Since XML Schem as are m ore power ful than DTDs, they can be used to represent the knowledge. Michel etal. have i nvestigated the relation between ontologies and XML Schem as and found that XML Schem as are com parable to Ontology Interface Language (OIL) (Klein etal.) XML schem as specification is widely accepted and standardized. Any application that confor ms to this specification can process the docum ent with out any m odifications. This is the m ain advantage of representation of knowledge in XML. XML presents trem endous opportunities for the knowledge representation com munity. One intuition is to see an Internet of XML docum ents as a vast source of knowledge. Since XML is inheren tly structured, it is easy to extract. An XML docum ent can be directly parsed into a knowledge base for m ore sophisticated inference m echanism s (Frank, 1999). 3.4 Advantages of XML in systems integration Application experts need a language that is easy to use for authoring knowledge schem as. XML is an ideal language for representing the knowledge com ponent for the following reasons: It is hum an readable. So, it can be r eadily understood and the knowledge schem as can be edited easily. It is easy to author. 31 It is universally standardized. 3.5 XML Namespaces XML nam espaces are the solutions to the problem s of am biguity and nam e collisions. According to the W orld W ide W mendation January 1999), a nam espace is ... A collection of names identified by Uniform Resource Identifier ( URI), that are used in XML documents as element types and attribute names. With the help of XML nam espaces, one can standardize the definitions of various entities. He/she can also standardize the relationship and interactions between the different entities. Each nam espace is identified with a URI. So, when som eone refers to an elem ent or entity with a URI, he/she can clearly identify its context (definition, structure). Nam espaces will also help XML vocabulary designers to break com plex problem s into smaller pieces and m ix multiple vocabularies as needed to fully describe a problem in a single XML docum ent. 3.5.1 Declaring A Namespace A nam espace is declared by using the keyword xmlns . The value of the attribute is the URI that uniquely defines the nam espace in use. The URI is often an URL pointing to a schem a but it doesn't have to be. A UR I, managed in such a way as to uniquely differentiate the nam espace, is sufficient. An exam ple of a nam espace is described as follows: Application 1 (FVS) Application n Wrapper n COM/DCOM Platform XML nam es spaces XML Schem as (contains dom ain specific knowledge) of forestry dom ain Inference Component Knowledge Component ......... Knowledge of Application n in XML Knowledge of Application 1 in XML U S E R I N T E R F A C E Figure 4.1 Architecture of Open Intelligent Inform ation System in Forestry Dom ain CHAPTER 4 DESIGN AND IMPLEMENTATION An integrating architecture form s a gene ral fram ework for inform ation exchange and co-ordination am ongst a variety of software system s. The prim ary aim of this thesis is to design a general-purpose fram ewor k for integrating existing and future heterogeneous applications in the forestry dom ain. This design takes into account the specific challenges posed by the forestry dom ain (Liu, 1998) and is also am enable to other dom ains. 4.1 Design Goals An ideal FEM-DSS should be one that has m ost or all of the legacy system s working as a whole across f orest ecosystem process. Most of the m onolithic legacy FEM- DSSs works in isolation with only one or few aspects of the entire forest ecosystem process. There are no standards used in de velopm ent of the FEM-DSSs. Therefore, the integration of these independently developed software solutions is desirable for building effective FEM-DSSs as software developm ent is growing toward constructing system s from pre-existing com ponents (Jorgensen et al. 1996.). Hence an interoperable architecture should be open, generic and gene ral purpose. It should be a com munication channel between a num ber of software co mponents and independent developers. To attain this goal, the system architecture must satisfy m any requirem ents. The design 33 34 should be language independent such that it should be able to integrate applications developed with different languages. The design m ust have extensibility such that it can be used over a period of time and not becom e obsolete. This will enable integration of new com ponents into the existing system with relative ease. This ensu res the growth and evolution of the existing system into a new m ore capable system over tim e. The design should provide a com mon plat form for com munication and interaction between the com ponents of the system . The design should be able to handle the peculiarities of the legacy system s. For exam ple, m any legacy applications are not object-oriented, and data and f unctionality of one application m ay not be readily available to other applications, even if the applications are im plem ented with the sam e program ming language and run on the sam e machine. The design should provide guidelines in dealing with the integration of legacy system s. Considerable am ounts of effort and tim e will be spent in the integration of the legacy system s into a DSS. The design stra tegy should support the notion that instead of a legacy system being integrated into a pa rticular DSS, it should be feasible for the legacy system to be integrated into any DSS with relative ease. The design should also propose standard s for the forestry dom ain that will alleviate problem s of knowledge disparity. The design should be realistically applicable when im plem ented. 35 4.2 Open Intelligent Information Syst em for Forestry Domain (OIISFD) In accordance with the above requirem ents, we propose a m odel for system s integration in the forestry dom ain. In this section, we describe a detailed design, Open Intelligent Inf ormation System for Forestry Dom ain (OIISFD) that provides a general fram ework for integration (fig 3.1). The basic ai m of the system is to provide inform ation to the user. The OIIFSD m ay perform various operations such as sim ple data retrieval, simulation run, com plex calculations or a com bination of these in order to provide the user with the inform ation. It will m ake use of one or m ore com ponents of the system . It is mandatory that the OIISFD interprets the us ers needs correctly and then undertakes the appropriate action. This entire process of info rmation retrieval should be hidden from the user. The OIISFD com prises of three interacting com ponents 4.2.1 Components of OIISFD The OIISFD contains three com Inference com ponent Knowledge com ponent Legacy com ponent Each of these com ponents will be explained in detail in later sections. This architecture is a blend of m ediation (W iederhold, 1992) and inform ation brokering architectures (Martin, 1997). Here, the legacy com ponent uses wrapper technology and acts as a mediator between the legacy application and inference com ponent. The inference component acts as an inform ation broker by pr ocessing the user's query and issuing the action statem ents to the legacy com ponent. 36 A typical OIISFD f low is outlined below: The user interface sends a query and data to the inference com ponent. The inference com ponent based on the user's query, infers the m odel(s) that has to be run, using application specific and dom ain specific schem as. Then the input data (provided by the user) is preprocessed (in XML) using the application's input file schem a. The inference com ponent invokes the application' s wrapper. The wrapper first converts the input XML data into raw application data, la unches the application, runs the application, parses the output data into XML and then returns it to the inference com ponent. If there are no m odels to be run, it returns the data to the user. If there are m odels, it will go through the above process once again. To m eet the design criteria, the fram ework should be language and platform independent and have inherent m echan isms for com munication. COM/DCOM was selected as a platform on which the fram ework is im plem ented. This platform meets the design guidelines. The salient features of CO M/DCOM are described in the next section. 4.2.2 COM/DCOM platform COM or Com ponent Object Model (COM) is Microsoft's binary standard that defines the interactions between objects. Di stributed COM (Microsoft, 1996.) (DCOM) is an extension of the COM and has been called \"COM with a longer wire\". It allows COM objects to be activated on rem ote machines. To a client of a DCOM object, the location of the object (local or rem ote) doesn't m atter. It sees a rem ote object as if it were a local object. Since, DCOM is sim ply distributed COM, both the term s COM and DCOM are often used interchangeably. 37 DCOM is a binary specification to in tegrate com ponents. A com ponent is a reusable piece of software in a binary form that can be plugged into other com ponents. DCOM defines a binary interoperability standard rather than a language-based standard. Figure 4.2: DCOM Architecture (Microsoft, 1996) 4.2.2.1 DCOM Architecture Figure 3.2 shows the basic DCOM archit ecture. Each client uses DCOM components through interfaces. The client sends a request to activate the object of a server through CoCreateInstance (stands for Com ponent Create Instance) and is passed back an interface pointer to that object. Th e client can access this interface through proxy object. The proxy object contains all the necessary network related com mands. It marshals the client request and sends it th rough the channel called Distributed Com puting 38 Environm ent Rem ote Procedure Call (DCE RPC) to the stub object. The stub object unmarshals the client request and invokes the m ethod on the server object. The client and server processes m ay run on different m achines, possibly even different operating system s. Since DCOM is language independent and platform independent, to f acilitate the com munication between client and server, it provides a common language through Interface Definition Language (IDL). IDL is language independent and provides m apping to C or C++. The server's interface is developed with IDL and is com piled with Microsoft IDL (M IDL) com piler that produces proxy and stub code. 4.2.2.2 Protocol Neutrality DCOM provides this abstraction transparently: DCOM can use any including TCP/IP, nd NetBIOS. DCOM provides protocols, incl uding connectionless and connection-oriented protocols. 4.2.2.3 Platform Neutrality DCOM is open to all approaches to cross-plat form developm ent. It does not preclude the use of platform -specific services or optim izations, nor does it favor a certain style of system services over others. DCOM' s architecture allows the integra tion of platform ized custom com ponents into a single distributed application. 39 4.2.2.4 Cross-Platform Interoperability Standard On the other hand, DCOM defines atform services (or abstractions) for object-oriented distributed com puting, in cluding connection to, and creation of, components, locating com ponents, invoking methods on com ponents, and a security fram ework. Beyond this, DCOM sim ply uses the services available on each platform to implem ent m ultithreading and concurrency control, user interface, file system interaction, non-DCOM network interaction, and the actual security provider. 4.2.2.5 Available Platforms DCOM on Window s Implem entations of DCOM are available t oday on the Microsoft W indows NT platform in W indows NT W orkstation 9x, on Apple Macintosh Microsoft im plem ented DCOM for the Apple Macintosh. DCOM on UNIX/Mainframe Versions of DCOM for UNIX pl atform s are developed (Software AG and Digital in close cooperation with Microsoft) and have been previewed publicly interoperating with implem entations on W indows currently supported for Sun Solaris, AIX, MVS, and Linux. 40 4.3 Know ledge Component The knowledge com ponent contains the application specific knowledge. This application specific knowledge encodes the rules for the usage of a particular application. Depending on the application, this type of knowle dge m ay or m ay not exist. If the legacy application is m enu-driven, selection of different m enus will lead to dif ferent outputs. This m apping between m enu-selection and output can be encoded in application specific knowledge. It also contains input and output file form ats. Most of the legacy system s in the forestry dom ain have been im plem ented in different languages like FORTRAN and C. The input and output form ats are pretty rigid. For describing the application we need a knowledge representation language. Since knowledge that is described in the component is sort of a gateway to the application, this knowledge representation language should be well known, user friendly, and a standard. Application experts are the people who are involved in the developm ent of a particular legacy system and are well ve rsed with usage of the system . On the other hand dom ain experts are the people who are f amiliar with an individual dom ain rather than a specific application. For exam ple, app lication experts are involved in developm ent of the knowledge com ponent that is very a pplication specific while, dom ain experts are involved in developm ent of the inference co mponent. Application experts who need not be experts in knowledge representation au thor the knowledge schem a. As described earlier, XML is used for representing know ledge within the knowledge and inference components. 41 The applications present in OIISFD act as inform ation sources that are highly autonom ous and independent. The application experts are in charge of developing and maintaining the application schem as. The partial knowledge schem a custom XML Parser extracts rules from the knowledge component. A typical entry in the knowle dge com ponent about Forest ext=\"cov\" reg=\"eleven\">Southeast</Variant> (If the region is \"eleven\" (SouthEast region) and extension is \"cov\" (Cover Shrubs), then 42 FVS variant is SouthEast). 4.4 Inference Component The Inference com ponent plays a pivotal ro le in the OIISFD architecture. It acts as a m ediator/inform ation broker between th e user and the inform ation sources (the legacy applications). The inference com ponent possesses dom ain (forestry) knowledge, application (that are supported by OIISFD) desc ription knowledge rather than application specific knowledge that is contained in th e knowledge com ponent. This draws a clear line between application and dom ain experts about who is in charge of adm inistering the components. W hile dom ain experts develop and m aintain the inference com ponent, application experts develop and m aintain the knowledge com ponent. One of the m ain requirem ents for an open system architecture is the use of standards wherever possible. Ideally, the forestry com munity should have a consensus on the sem antics of the dif ferent term s used in the forestry dom ain. The developm ent of such standards requires m uch consensus and effort. Ideally, the forestry com munity should have som e language like a Forestry Markup Language (FML) that clearly specifies the semantics of the term s used in the f orestry domain. This will alleviate the integration of various applications used in the forestry dom ain. For exam ple, a plot can be described as a group of trees. However, there are no general standards that specify the num ber of trees that constitute a single plot. Another exam ple of m isunderstanding of term s is the usage of the term \"plot\". In som e applications, a \"plot\" signifies a particular area of land. However, in other applications, the term \"plot\" refers to a group of trees. This will lead to ambiguity (in the f ormer exam ple) and nam e collisions (in the latter exam ple) 43 The inference com ponent tries to solve these problem s using XML nam espaces (Nam espaces, 1999). Since one of the prim ary m otivations for using nam espaces is to be able to m ix nam es from different sources, it is possible to provi de an alias. This can be done by appending a colon and alias to the xm lns attribute. For exam ple, the elem ent plot can be uniquely identif ied by xmlns:plot = \"http://www.ai.uga.edu/forestry/forest.xm l\" The inference com ponent provides support for containing forestry vocabulary. The inference com ponent also contains application description knowledge. 4.4.1 Application Description Know ledge This type of knowledge describes the applic ation and relation(s) between applications. This knowledge aids in identifying the application for satisfying the user query. Ontologies are used to describe the knowledge of the application. In OIISFD, application's m eta-knowledge (knowledge of what it does) is represented using ontologies (in XML). The root ontology contains the following attributes: Slot Name Slot Description Slot Default Value Nam e The Application's nam e None Version Version of the application's knowledge schem a 0.1 Description Brief description of the application usage (used only for docum entation purposes). This application is used in Forestry domain Keyword List List of key words associated with this application None. Species List List of species supported by this application None Region List List of the regions supported by this application Entire United States Dependency List Application on which this application is depend on. And a m apping function for each None 44 application above that m aps output(s) of application with input(s) of the current application Owner The original developer of the application United States Departm ent of Agriculture Platform s Platform s (operating system s) on which this application is supported on. Windows Every application present in the OIISFD know ledge schem a will be derived from this root ontology. The derived schem a can possess extra slots that are pertinent to the application it represents. A reduced version of FVS's knowledge that is used in the inference com ponent as legacy com ponent contains the legacy applications or databases and their wrappers. 45 These legacy applications com prise the main inform ation sources. Som e of the exam ples in legacy applications in forestry dom ains are decision support m odels such as growth and yield sim ulation m odels, forecasti ng m odels and visualization m odels. Som e of these legacy applications such as visualization m odels cannot be wrapped, as they need to be interactive with the user. Theref ore, they cannot be a part of the legacy component. Legacy applications such as for ecasting m odels and growth and yield m odels are the ideal m embers to be part of legacy com ponents. An exam ple legacy application that is used here is FVS (Teck et. al, 1997). We need to provide a m echanism by which the services of a legacy system can be accessed by the inference com ponent. W rappers are used for attaining this goal. 4.5.1 Wrappers The wrappers around the legacy applica tions are an im portant part of the architecture. W rappers should be designed such that, they hide idiosyncrasies of the legacy applications. They encapsulate and integrate the legacy applications with the rest of the system (Wiederhold, 1992). W rappers basically expose the functionality of the legacy application. Since m ost of these legacy system s are huge, and stand alone, wrappers should provide a m echanism for i nvoking these applications rem otely. All the communications between the legacy applicati ons and the rest of the com ponents are done through the wrappers. The inference com pone nt expects the output in the form at specified in the outputschem afile of the app lications knowledge schem as. So the wrapper should be able to parse the raw application sp ecific data into the form at specified in the outputschem afile of the applications knowle dge schem as. Having the output from the legacy com ponent in XML helps the inference com ponent as it can easily m anipulate 46 data of the elem ents present in the output f ile. This in turn, will help dynam ic inform ation exchanges that m ight be perform ed by the inference com ponent. By taking into consideration of above requirem ents, we have designed a custom wrapper for FVS. The wrapper in the lega cy com ponent in OIISFD is COM/DCOM based. Ideally, after developing these wrappers , the legacy applications can be invoked from any where without worrying about the mundane networking details. And also the interfaces of wrappers are clearly defined. Th e output and input into these wrappers are structured XML docum ents, rather than flat files. Active Tem plate Library (ATL) by Micros oft has been used for developing the wrapper for FVS. ATL has been specifically de veloped by Microsoft to assist developers building DCOM com ponents in C++. It helps in the com ponent registration process. All the custom interfaces required for the wra ppers are defined using Microsoft Interface Definition Language (MIDL). The key point here is definition of language and platform neutral interfaces. From now, the clients, (who access the wrappers: in OIISFD, the inference com ponent) who are developed us ing different languages and on different platform s can still be able to access the wra ppers. W e defined the following interface for the FVS W rapper: Interface is derived from IUnknown; DCOM interfaces are derived from IUnknown. [in] and [out] are used to specify directions of data flow. [in] param eters are those that pass data from the client to the component. [out] param eters pass data from the com ponent to the client. In IDL, all param eters, whether standard data types or buffe r pointers, m ust be m arked as [in], the param eter that receives the return value of the interface m ember. A ll DCOM interfaces return a value of type HRESULT that returns S_OK if the opera tion succeeds and an error status code (E_FAIL, for exam ple) if it fails. The FVS W rapper interface contains four m ethods: RawFVSExecute This is the m ain m ethod of the inte rface and is internally called by other methods of the interface. This m ethod takes stand data (the tree stand data on which the sim ulation has to be run), key file (the key f ile tells the sim ulation param eters that are to be used) as input and generates tree list and post process results as output. FVSExecute This m ethod is used by the inference com ponent to invoke the application. It takes XML stream s as input and therefor e hides the FVS specific form at from 48 the user. It then converts these XML stream s into FVS specific form at and then calls RawFVSExecute FVSOutputRaw2XML, FVSInputXML2Raw These are the two helper functions that convert XML stream s into FVS specific form at and vice versa. They us e inputfileform at and outputfileform at schem as present in the knowledge com ponent. The inference com ponent can obtain the results from FVS in two ways: It can directly call FVSExecute and pass input data in XML Use helper functions and call rawFVSExecute. 4.6 OIISFD Implementation OIISFD is im plem Forest Vegetation Sim ulator (FVS) Test Application The later application is a dum my applicati on used f or testing interoperability of the fram ework. The test application takes output from FVS and calculates average height of the stand before and after the sim ulation. Th e inference com ponent acts as a controller and co-ordinates actions between various com ponents of the fram ework. OIISFD uses prolog for providing support for inference m echanism s. Am zi! Inc. provides a version of Prolog, which can be em bedded in m ost of the popular program ming languages. OIISFD's inference engine is developed using Am zi! Prolog. When the system is invoked, the inference com ponent initializes the COM/DCOM fram ework. It the inference engine. 49 The inference com ponent contains a list of applications that are supported by OIISFD and their corresponding knowledge sche mas in XML. It contains a custom XMLSchem a parser that can parse the know ledge schem as. Application specific knowledge schem as are handled differently from application description knowledge schem as. If an application specific knowledge schem a contains any rules, the parser parses them into Prolog production rules. For exam ple, the following entry in application specific knowledge schem a of FVS is reg=\"eleven\">Southeast</Variant> (If the region is \"eleven\" (SouthEast region) and extension is \"cov\" (Cover Shrubs), then FVS variant is internally. The parser parses application description knowledge schem as into fram es. For exam ple, the following entry in the application description knowledge schem a of FVS is parsed into a Rule Interpreter Fram e-logic Processor. As m entioned earlier, the inference engine is im plem ented using Prolog. Once various rules associated with different applications are asserted in the rule base, the rule interpreter PSM can be invoked by calling the predicate go/0. The m ain processing of the rule interpreter is as f engine contained in the inference com ponent of OIISFD is a fram e-logic processor. Once va rious fram es associated with different applications are asserted in the fram e ba se, the fram e-logic processor PSM can be invoked by calling the predicate get_frame/2 . The m ain processing of the fram slot_vals(Thing, ReqList, are used for m aintaining the fram e base: 51 % add_fram e/2 % The add_fram e predicate uses the sam e basic form as get_fram e. % For updat es, first the old slot list is retrieved from the exi sting fram e. % Then t he predi cate add_sl ots is called with the old list (SlotList) and t he updat e list (ULi st). % It returns the new del_fram e predicate uses the sam e basic form as get_fram e. % Fo r deletions, first th e old slot list is retriev ed from the existing fram e. % Then t he predi cate del _slots is called with the old list (SlotList) and t he updat e list %(ULi st). % It returns the developed for data t ype conversion (from Prolog to C++ and vice- versa), handling Am zi! Prolog fo r loading/unloading em bedded Prolog. This fram ework includes an abstract layer ( over the API provided by Am zi! Prolog) for making prolog queries, calling C++ m ethods by prolog predicates and prolog query result processing. 4.6.2 Query Processing Implementation The query-processing m odule is part of the inference com ponent. The OIISFD user interacts with the system by typing appropriate requests. Depending upon the query, appropriate applications are run, if needed, the system presents screens for user input and results are displayed. The inference com pone nt contains a query-processing m odule to handle different types of que ries. The inference com ponent with the help of query- processing m odule and controller m odule responds to the user requests. The query- processing m odule converts the user request into a prolog query and then hands the 52 prolog query to the controller m odule for appr opriate action. For exam ple, if the user wants to f ind the description of FVS, he/she will type: fvsdescription . The prolog query: get_frame(fvs,[description-Description]). The controller m odule then queries the knowledge base with this prolog query and displays the result to the user. For handling sophisticated user queries, a query planner has been im plem ented. This query planner tries to satisfy the user constraints before running appropriate application. The m ain processing of query planner is as have been successfully implem ented for the FVS application. Leg acy and knowledge com ponents are developed according to the OIISFD architecture. The inference com ponent uses an em bedded inference engine for decision-m aking. XML is used as a com munication m echanism between different m odules. Additional applica tions can easily be added to the fram ework. Since, XML is hum an readable and eas y to author, a knowledge com ponent can be developed with relative ease by the appli cation experts them selves. Developm ent of wrappers for the legacy com ponent requires considerable program ming effort. To m ake these wrappers reusable, the interfaces s hould be developed as generic as possible (similar to IFVSW rapper). The inference com ponent is a m iddlem an between the user and the knowledge component. W hen the user forwards a request , the inference com ponent using the prolog module identifies the needed application(s). Once it identifies the required application(s), it preprocesses the data associated with the us er's requests. W ith the help of input-file- schem as of those applications it translates th e user's data into the form at required by the wrapper(s). The knowledge com ponent also cont ains the location and Interface IDentifier (IID) of the wrapper. The inference com ponent then invokes the wrapper with the help of 53 54 COM/DCOM run tim e services. Once it gets th e wrapper's interface pointer, it runs the methods with the preprocessed (and translated) user's data as input. The next section shows the various usage cases of the OIISFD fram ework. 5.1 OIISFD Screen shots When the system is invoked, it presents the following screen to the user: Figure 5.1 OIISFD initialization Screen The user can ask various questions to the system by typing in the com mand-line box. For exam ple, if the user wants to know various species supported by fvs, he/she will type: fvsspecieslist The query processor converts this query to the following prolog request and presents the results to the user. get_frame(fvs, [specieslist-X]). 55 The user can also query the em bedded the knowledge base by prepending \"prolog\" to his/her query. For exam ple, if the user want s to see rules present in the knowledge base, he/she will type \"prolog rule(X).\". The query processor recognizes that this query is a prolog query and passes it unchanged to the c ontroller. The following screen shows the above process. Figure 5.2 Output of the query \"prolog rule(X)\" OIISFD has support for running applications ba sed on the user query. For exam ple, if the user wants to run a sim ulation, he/she will type, \" query simulation \" in the com mand-line box. The query processor converts this query into the following prolog query: get_frame(X,[keywordlist-simulation, dependencylist-Y]). Here, dependencylist contains the list of applications (and their corresponding wrapper names). Since FVS is not dependent on any a pplications, this list will be em pty. Once the inference com ponent infers the application as FVS, it launches the FVS screen. For 56 identifying the correct variant of FVS, the us er has to select region and extension. The user selections are passed to the inference e ngine, which uses the rules associated with FVS to identif y the correct variant. Af ter identif ying the appropriate variant, the controller asks the user for input data. It then runs the application and displays the results to the user. Figure 5.3 Fvs input screen. 57 Figure 5.4 FVS output screen. To test the interoperability f ramework, a test application has been added to the OIISFD. This test application calculates the averag e height of a stand before and after the simulation. The knowledge schem a of this test application is as follows: average_distance\", the inference com ponent identif ies the application as Dum my. But sin ce this application depends on FVS, it first runs FVS. During the system initialization all the wrapper f unctions are loaded in a m ap. 58 It later uses the wrapper function to convert FVS data to the dum my application input data. It then launches the dum my application that calculates the average height and then the inference com ponent displays the results to the user. Figure 5.4: FVS is identified as an dependent application and it is run first. 59 Figure 5.5: The final output of the query \"query average_distance\". Some of the query satisfaction process can be autom ated. For exam ple, one of the common queries for FVS is to vary the sim ulation tim e. This type of com mon query can be encoded as a constraint and a constraint satisfaction m ethod can be developed that satisfies the user query without his/her in tervention. For exam ple, the user can query OIISFD as f ollows: query -keyword average_height -constraint_name time - constraint_value 50-inputfile standfile (Find average height of the stand present in standfile after running the sim ulation for 50 years). The inference com ponent uses query_planner/3 for satisfying this type of query. The query_planner first infers the application that can be used to satisfy the keyword. It then searches for a constraint satisfaction function that can satisfy the given constraint in the 60 current application and all the dependent appli cations. It runs the constraint satisfaction function and then runs the application and dependent applications with m inimum user intervention. CHAPTER 6 CONCLUSIONS AND FUTURE DIRECTIONS The prim ary goal of this thesis was to propose an architecture for the integration of system s in the forestry dom ain. The archit ecture is scalable, flexible and extensible. Hum an roles are clearly identif ied in the in tegration of the legacy system s. Dom ain experts will develop and m aintain the inference com ponent, application experts m aintain the knowledge com ponent while program mers/developers will develop and m aintain wrappers in the legacy com ponent. Usi ng COM/DCOM as a platform , on which the various com ponents are built, the proposed arch itecture is language and platform neutral. With the help of the schem as that are defi ned in the inference com ponent we have a common language in which various legacy com ponents can exchange inform ation. According to the open system s approach, sta ndards should be used wherever possible. Since XML is a universal standard, the proposed architecture conform s to this requirem ent. By using XML nam espaces, am biguities in nam e collisions of various entities in f orestry dom ains, can be avoided. Another goal of this thesis was to i nvestigate the use of XML as a knowledge representation language. It has been dem onstrated that XML with schem as has enough expressiveness to use it as a knowledge representation language. This breaks down the barriers between data and inform ation. Since XML is hum an readable and easy to author, the schem as can be easily m aintained. The experts them selves can develop these schem as, thereby avoiding the tedious process of knowledge acquisition. Building 61 62 wrappers and knowledge schem as in the proposed way, the legacy system s can be integrated into any system with little m odifications. The inf erence engine present in the inference com ponent was built using knowledge engineering principles. The forestry com munity does not have a com mon language for the integration of various system s. This hinders the process of integrating legacy system s. Efforts should be made to develop a com mon language (Forestry m arkup Language) preferably using XML. The current work provides guidelines for integrating growth and yield m odels and forecasting m odels. The process of integrati ng visualization m odels still needs to be investigated. The current inference com pone nt contains knowledge that is built from scratch. The inference com ponent has to be made interoperable with existing knowledge sources. More theoretical foundations have to be developed for the use of XML as a knowledge representation language. BIBLIOGRAPHY A. Newell. 1982. The Knowledge Level. Journal of Artificial Intelligence , 18(1): pages 87-127. D. Fensel, H. Eriksson, M. A. Musen, a nd R. Studer. 1996. Conceptual and Formal Specifications of Problem -Solving Methods , International Journal of Expert Systems , 9(4):507-532. Durking, J. 1994. Expert Systems: Design and development , Prentence Hall Publications. Grim es, 1997. Professional DCOM Programming , Birm ingham , U.K: W rox Press Ltd. Gruber T. 1991. The role of a com mon ontology in achieving sharable, reusable knowledge bases. Proceedings of the 2nd International Conference on Principles of Knowledge Representation and Reasoning , Cam bridge: 601-602. Guarino N. 1998. Form al ontology and inform ation system s. Proceedings of the 1st International Conference on Formal Ontology in Information Systems [FOIS'98], Torino: 3-15 and . Second Generation Expert Systems , Springer-Verlag, Berlin. Liu, S. 1998. Integration of Forest D ecision Support System s: A search for Interoperability. Master's Thesis, The University of Georgia , Athens, GA. M. Klein, D. Fensel, F. van Harm elen, and I. Horrocks: The relation between ontologies and XML schem as, to appear in Electronic Transactions on Artificial Intelligence ( ETAI). Martin, D., Ooham a, H., Moran, D., and Cheyer, A., 1997. Inform ation Brokering in an Agent Architecture . Proceedings of The Practical Application of Intelligent Agents and Multi-Agent Technology (PAAM 97) . Microsoft. 1996. The Distributed Com ponent Object Model: Technical overview http://www.microsoft.com/com 63 64 Mowrer, H.T., Barber, K., Cam pbell, N., Cr ookston, C., Dahm s, J., Day, J., Laacke, J., Merzenich, Mighton, Rauscher, M., Thom pson, J., Trenchi, P., and Twery, M. 1997. Decision Support System s for Ecosystem Managem ent: An evaluation of existing system s. General Technical Report RM-GTR-296 . Fort Collins, CO: USDA Forest Service, Rocky Mountain Forest and Range Experim ent Station. Nam espaces in XML 1.0 http://www.w3.org/TR/REC-xml-names , February 1999. W 3C Recom mendation Kent, R.. 1999. Conceptual Knowledge Mar kup Language: The Central Core. Electronic Proceedings of the Twelfth Works hop on Knowledge Acquisition, Modeling and Management , Banff, Alberta, Canada, 16-21 October 1999. Rudi Studer, Dieter Fensel, Stefan Deck er, and V. Richard Benjam ins. March, 1999. Knowledge Engineering: Survey and Future Directions . Lecture Notes in Artificial Intelligence , LNAI 1570, Springer-Verlag. Sheth, A. 1998. Changing Focus in Inform ation System s: From System , Syntax, Structure to Sem antics. Interoperating Geographic Information Systems , Kluwer Publications. Software Engineering Institute. The Open System s Approach at SEI, Carnegie Mellon http://www.sei.cmu.edu/opensystems/welcome.html Somasekar, S. 1999. An Intelligent Inform ation System for Integration of Forest Decision Support System s. Master's Thesis, The University of Georgia , Athens, GA. Teck, R., Moeur, M., and Eav, B. 1997. The forest vegetation sim ulator: A decision support tool for integrating resources http://www.fs.fed.us/ftproot/pub/fmsc/fvsdesc.htm Twery, M.J., Bennett, D.J., Steinm an, J., Gustafson, E., Miller, G., Cleveland, H., Grove, M., Mc Guinness, B., Chen, N., and Nute, D.E. 1997. NED-1: An integrated decision s upport system for ecosystem managem ent. Proceedings of the Resource Technology 1997 Meeting. Pp 331-343 Twery, M. NED: A Set of Tools For Managing Non Industrial Private Forests in the East http://www.fs.fed.us/ne/burlington/research/ne4454/ned/pub1.htm Wiederhold G. 1992. Mediators in the architecture of future inform ation system s. IEEE Computer 25(3): 38-49. Wiederhold G. 1997. Integration of Heterogeneous Inform ation at Stanford. Power point Presentation. http://www-db.stanford.edu/pub/gio/slides/Stanford1/index.htm 65 Extensible Markup Language (XML) 1.0. http://www.w3.org/TR/REC-xml , W 3C Recom 2001. W 3C Recom mendation APPENDIX A OF /*XML(Schema) "}