{"title": "Apache Kafka", "author": null, "url": null, "hostname": null, "description": "Apache Kafka: A Distributed Streaming Platform.", "sitename": "Apache Kafka", "date": "2023-01-01", "cleaned_text": "Kafka protocol guide This document covers the wire protocol implemented in Kafka. It is meant to give a readable guide to the protocol that covers the available requests, their binary format, and the proper way to make use of them to implement a client. This document assumes you understand the basic design and terminology described [here](https://kafka.apache.org/documentation.html#design) Kafka uses a binary protocol over TCP. The protocol defines all APIs as request response message pairs. All messages are size delimited and are made up of the following primitive types. The client initiates a socket connection and then writes a sequence of request messages and reads back the corresponding response message. No handshake is required on connection or disconnection. TCP is happier if you maintain persistent connections used for many requests to amortize the cost of the TCP handshake, but beyond this penalty connecting is pretty cheap. The client will likely need to maintain a connection to multiple brokers, as data is partitioned and the clients will need to talk to the server that has their data. However it should not generally be necessary to maintain multiple connections to a single broker from a single client instance (i.e. connection pooling). The server guarantees that on a single TCP connection, requests will be processed in the order they are sent and responses will return in that order as well. The broker's request processing allows only a single in-flight request per connection in order to guarantee this ordering. Note that clients can (and ideally should) use non-blocking IO to implement request pipelining and achieve higher throughput. i.e., clients can send requests even while awaiting responses for preceding requests since the outstanding requests will be buffered in the underlying OS socket buffer. All requests are initiated by the client, and result in a corresponding response message from the server except where noted. The server has a configurable maximum limit on request size and any request that exceeds this limit will result in the socket being disconnected. Kafka is a partitioned system so not all servers have the complete data set. Instead recall that topics are split into a pre-defined number of partitions, P, and each partition is replicated with some replication factor, N. Topic partitions themselves are just ordered \"commit logs\" numbered 0, 1, ..., P-1. All systems of this nature have the question of how a particular piece of data is assigned to a particular partition. Kafka clients directly control this assignment, the brokers themselves enforce no particular semantics of which messages should be published to a particular partition. Rather, to publish messages the client directly addresses messages to a particular partition, and when fetching messages, fetches from a particular partition. If two clients want to use the same partitioning scheme they must use the same method to compute the mapping of key to partition. These requests to publish or fetch data must be sent to the broker that is currently acting as the leader for a given partition. This condition is enforced by the broker, so a request for a particular partition to the wrong broker will result in an the NotLeaderForPartition error code (described below). How can the client find out which topics exist, what partitions they have, and which brokers currently host those partitions so that it can direct its requests to the right hosts? This information is dynamic, so you can't just configure each client with some static mapping file. Instead all Kafka brokers can answer a metadata request that describes the current state of the cluster: what topics there are, which partitions those topics have, which broker is the leader for those partitions, and the host and port information for these brokers. In other words, the client needs to somehow find one broker and that broker will tell the client about all the other brokers that exist and what partitions they host. This first broker may itself go down so the best practice for a client implementation is to take a list of two or three URLs to bootstrap from. The user can then choose to use a load balancer or just statically configure two or three of their Kafka hosts in the clients. The client does not need to keep polling to see if the cluster has changed; it can fetch metadata once when it is instantiated cache that metadata until it receives an error indicating that the metadata is out of date. This error can come in two forms: (1) a socket error indicating the client cannot communicate with a particular broker, (2) an error code in the response to a request indicating that this broker no longer hosts the partition for which data was requested. - Cycle through a list of \"bootstrap\" Kafka URLs until we find one we can connect to. Fetch cluster metadata. - Process fetch or produce requests, directing them to the appropriate broker based on the topic/partitions they send to or fetch from. - If we get an appropriate error, refresh the metadata and try again. As mentioned above the assignment of messages to partitions is something the producing client controls. That said, how should this functionality be exposed to the end-user? Partitioning really serves two purposes in Kafka: - It balances data and request load over brokers - It serves as a way to divvy up processing among consumer processes while allowing local state and preserving order within the partition. We call this semantic partitioning. For a given use case you may care about only one of these or both. To accomplish simple load balancing a simple approach would be for the client to just round robin requests over all brokers. Another alternative, in an environment where there are many more producers than brokers, would be to have each client chose a single partition at random and publish to that. This later strategy will result in far fewer TCP connections. Semantic partitioning means using some key in the message to assign messages to partitions. For example if you were processing a click message stream you might want to partition the stream by the user id so that all data for a particular user would go to a single consumer. To accomplish this the client can take a key associated with the message and use some hash of this key to choose the partition to which to deliver the message. Our APIs encourage batching small things together for efficiency. We have found this is a very significant performance win. Both our API to send messages and our API to fetch messages always work with a sequence of messages not a single message to encourage this. A clever client can make use of this and support an \"asynchronous\" mode in which it batches together messages sent individually and sends them in larger clumps. We go even further with this and allow the batching across multiple topics and partitions, so a produce request may contain data to append to many partitions and a fetch request may pull data from many partitions all at once. The client implementer can choose to ignore this and send everything one at a time if they like. Kafka has a \"bidirectional\" client compatibility policy. In other words, new clients can talk to old servers, and old clients can talk to new servers. This allows users to upgrade either clients or servers without experiencing any downtime. Since the Kafka protocol has changed over time, clients and servers need to agree on the schema of the message that they are sending over the wire. This is done through API versioning. Before each request is sent, the client sends the API key and the API version. These two 16-bit numbers, when taken together, uniquely identify the schema of the message to follow. The intention is that clients will support a range of API versions. When communicating with a particular broker, a given client should use the highest API version supported by both and indicate this version in their requests. The server will reject requests with a version it does not support, and will always respond to the client with exactly the protocol format it expects based on the version it included in its request. The intended upgrade path is that new features would first be rolled out on the server (with the older clients not making use of them) and then as newer clients are deployed these new features would gradually be taken advantage of. Note that [KIP-482 tagged fields](https://cwiki.apache.org/confluence/display/KAFKA/KIP-482%3A+The+Kafka+Protocol+should+Support+Optional+Tagged+Fields) can be added to a request without incrementing the version number. This offers an additional way of evolving the message schema without breaking compatibility. Tagged fields do not take up any space when the field is not set. Therefore, if a field is rarely used, it is more efficient to make it a tagged field than to put it in the mandatory schema. However, tagged fields are ignored by recipients that don't know about them, which could pose a challenge if this is not the behavior that the sender wants. In such cases, a version bump may be more appropriate. In order to work against multiple broker versions, clients need to know what versions of various APIs a broker supports. The broker exposes this information since 0.10.0.0 as described in [KIP-35](https://cwiki.apache.org/confluence/display/KAFKA/KIP-35+-+Retrieving+protocol+version). Clients should use the supported API versions information to choose the highest API version supported by both client and broker. If no such version exists, an error should be reported to the user. The following sequence may be used by a client to obtain supported API versions from a broker. - Client sends ApiVersionsRequest to a broker after connection has been established with the broker. If SSL is enabled, this happens after SSL connection has been established. - On receiving ApiVersionsRequest, a broker returns its full list of supported ApiKeys and versions regardless of current authentication state (e.g., before SASL authentication on an SASL listener, do note that no Kafka protocol requests may take place on an SSL listener before the SSL handshake is finished). If this is considered to leak information about the broker version a workaround is to use SSL with client authentication which is performed at an earlier stage of the connection where the ApiVersionRequest is not available. Also, note that broker versions older than 0.10.0.0 do not support this API and will either ignore the request or close connection in response to the request. - If multiple versions of an API are supported by broker and client, clients are recommended to use the latest version supported by the broker and itself. - Deprecation of a protocol version is done by marking an API version as deprecated in the protocol documentation. - Supported API versions obtained from a broker are only valid for the connection on which that information is obtained. In the event of disconnection, the client should obtain the information from the broker again, as the broker might have been upgraded/downgraded in the mean time. The following sequence is used for SASL authentication: - Kafka ApiVersionsRequest may be sent by the client to obtain the version ranges of requests supported by the broker. This is optional. - Kafka SaslHandshakeRequest containing the SASL mechanism for authentication is sent by the client. If the requested mechanism is not enabled in the server, the server responds with the list of supported mechanisms and closes the client connection. If the mechanism is enabled in the server, the server sends a successful response and continues with SASL authentication. - The actual SASL authentication is now performed. If SaslHandshakeRequest version is v0, a series of SASL client and server tokens corresponding to the mechanism are sent as opaque packets without wrapping the messages with Kafka protocol headers. If SaslHandshakeRequest version is v1, the SaslAuthenticate request/response are used, where the actual SASL tokens are wrapped in the Kafka protocol. The error code in the final message from the broker will indicate if authentication succeeded or failed. - If authentication succeeds, subsequent packets are handled as Kafka API requests. Otherwise, the client connection is closed. For interoperability with 0.9.0.x clients, the first packet received by the server is handled as a SASL/GSSAPI client token if it is not a valid Kafka request. SASL/GSSAPI authentication is performed starting with this packet, skipping the first two steps above. The protocol is built out of the following primitive types. |Type ||Description | |BOOLEAN||Represents a boolean value in a byte. Values 0 and 1 are used to represent false and true respectively. When reading a boolean value, any non-zero value is considered true.| |INT8||Represents an integer between -27 and 27-1 inclusive.| |INT16||Represents an integer between -215 and 215-1 inclusive. The values are encoded using two bytes in network byte order (big-endian).| |INT32||Represents an integer between -231 and 231-1 inclusive. The values are encoded using four bytes in network byte order (big-endian).| |INT64||Represents an integer between -263 and 263-1 inclusive. The values are encoded using eight bytes in network byte order (big-endian).| |UINT32||Represents an integer between 0 and 232-1 inclusive. The values are encoded using four bytes in network byte order (big-endian).| |VARINT||Represents an integer between -231 and 231-1 inclusive. Encoding follows the variable-length zig-zag encoding from |[ Google Protocol Buffers](http://code.google.com/apis/protocolbuffers/docs/encoding.html). |VARLONG||Represents an integer between -263 and 263-1 inclusive. Encoding follows the variable-length zig-zag encoding from |[ Google Protocol Buffers](http://code.google.com/apis/protocolbuffers/docs/encoding.html). |UUID||Represents a type 4 immutable universally unique identifier (Uuid). The values are encoded using sixteen bytes in network byte order (big-endian).| |FLOAT64||Represents a double-precision 64-bit format IEEE 754 value. The values are encoded using eight bytes in network byte order (big-endian).| |STRING||Represents a sequence of characters. First the length N is given as an INT16. Then N bytes follow which are the UTF-8 encoding of the character sequence. Length must not be negative.| |COMPACT_STRING||Represents a sequence of characters. First the length N + 1 is given as an UNSIGNED_VARINT . Then N bytes follow which are the UTF-8 encoding of the character sequence.| |NULLABLE_STRING||Represents a sequence of characters or null. For non-null strings, first the length N is given as an INT16. Then N bytes follow which are the UTF-8 encoding of the character sequence. A null value is encoded with length of -1 and there are no following bytes.| |COMPACT_NULLABLE_STRING||Represents a sequence of characters. First the length N + 1 is given as an UNSIGNED_VARINT . Then N bytes follow which are the UTF-8 encoding of the character sequence. A null string is represented with a length of 0.| |BYTES||Represents a raw sequence of bytes. First the length N is given as an INT32. Then N bytes follow.| |COMPACT_BYTES||Represents a raw sequence of bytes. First the length N+1 is given as an UNSIGNED_VARINT.Then N bytes follow.| |NULLABLE_BYTES||Represents a raw sequence of bytes or null. For non-null values, first the length N is given as an INT32. Then N bytes follow. A null value is encoded with length of -1 and there are no following bytes.| |COMPACT_NULLABLE_BYTES||Represents a raw sequence of bytes. First the length N+1 is given as an UNSIGNED_VARINT.Then N bytes follow. A null object is represented with a length of 0.| |RECORDS||Represents a sequence of Kafka records as NULLABLE_BYTES. For a detailed description of records see |[Message Sets](/documentation/#messageformat). |ARRAY||Represents a sequence of objects of a given type T. Type T can be either a primitive type (e.g. STRING) or a structure. First, the length N is given as an INT32. Then N instances of type T follow. A null array is represented with a length of -1. In protocol documentation an array of T instances is referred to as [T].| |COMPACT_ARRAY||Represents a sequence of objects of a given type T. Type T can be either a primitive type (e.g. STRING) or a structure. First, the length N + 1 is given as an UNSIGNED_VARINT. Then N instances of type T follow. A null array is represented with a length of 0. In protocol documentation an array of T instances is referred to as [T].| The [BNF](https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form)s below give an exact context free grammar for the request and response binary format. The BNF is intentionally not compact in order to give human-readable name. As always in a BNF a sequence of productions indicates concatenation. When there are multiple possible productions these are separated with '|' and may be enclosed in parenthesis for grouping. The top-level definition is always given first and subsequent sub-parts are indented. All requests and responses originate from the following grammar which will be incrementally describe through the rest of this document: message_size field gives the size of the subsequent request or response message in bytes. The client can read requests by first reading this 4 byte size as an integer N, and then reading and parsing the subsequent N bytes of the request.| A description of the record batch format can be found [here](/documentation/#recordbatch). We use numeric codes to indicate what problem occurred on the server. These can be translated by the client into exceptions or whatever the appropriate error handling mechanism in the client language. Here is a table of the error codes currently in use: |Error ||Code ||Retriable ||Description | |UNKNOWN_SERVER_ERROR||-1||False||The server error when processing the request.| |NONE||0||False| |OFFSET_OUT_OF_RANGE||1||False||The requested offset is not within the range of offsets maintained by the server.| |CORRUPT_MESSAGE||2||True||This message has failed its CRC checksum, exceeds the valid size, has a null key for a compacted topic, or is otherwise corrupt.| |UNKNOWN_TOPIC_OR_PARTITION||3||True||This server does not host this topic-partition.| |INVALID_FETCH_SIZE||4||False||The requested fetch size is invalid.| |LEADER_NOT_AVAILABLE||5||True||There is no leader for this topic-partition as we are in the middle of a leadership election.| |NOT_LEADER_OR_FOLLOWER||6||True||For requests intended only for the leader, this error indicates that the broker is not the current leader. For requests intended for any replica, this error indicates that the broker is not a replica of the topic partition.| |REQUEST_TIMED_OUT||7||True||The request timed out.| |BROKER_NOT_AVAILABLE||8||False||The broker is not available.| |REPLICA_NOT_AVAILABLE||9||True||The replica is not available for the requested topic-partition. Produce/Fetch requests and other requests intended only for the leader or follower return NOT_LEADER_OR_FOLLOWER if the broker is not a replica of the topic-partition.| |MESSAGE_TOO_LARGE||10||False||The request included a message larger than the max message size the server will accept.| |STALE_CONTROLLER_EPOCH||11||False||The controller moved to another broker.| |OFFSET_METADATA_TOO_LARGE||12||False||The metadata field of the offset request was too large.| |NETWORK_EXCEPTION||13||True||The server disconnected before a response was received.| |COORDINATOR_LOAD_IN_PROGRESS||14||True||The coordinator is loading and hence can't process requests.| |COORDINATOR_NOT_AVAILABLE||15||True||The coordinator is not available.| |NOT_COORDINATOR||16||True||This is not the correct coordinator.| |INVALID_TOPIC_EXCEPTION||17||False||The request attempted to perform an operation on an invalid topic.| |RECORD_LIST_TOO_LARGE||18||False||The request included message batch larger than the configured segment size on the server.| |NOT_ENOUGH_REPLICAS||19||True||Messages are rejected since there are fewer in-sync replicas than required.| |NOT_ENOUGH_REPLICAS_AFTER_APPEND||20||True||Messages are written to the log, but to fewer in-sync replicas than required.| |INVALID_REQUIRED_ACKS||21||False||Produce request specified an invalid value for required acks.| |ILLEGAL_GENERATION||22||False||Specified group generation id is not valid.| |INCONSISTENT_GROUP_PROTOCOL||23||False||The group member's supported protocols are incompatible with those of existing members or first group member tried to join with empty protocol type or empty protocol list.| |INVALID_GROUP_ID||24||False||The configured groupId is invalid.| |UNKNOWN_MEMBER_ID||25||False||The coordinator is not aware of this member.| |INVALID_SESSION_TIMEOUT||26||False||The session timeout is not within the range allowed by the broker (as configured by group.min.session.timeout.ms and group.max.session.timeout.ms).| |REBALANCE_IN_PROGRESS||27||False||The group is rebalancing, so a rejoin is needed.| |INVALID_COMMIT_OFFSET_SIZE||28||False||The committing offset data size is not message is out of acceptable range.| |UNSUPPORTED_SASL_MECHANISM||33||False||The broker does not support the requested SASL mechanism.| |ILLEGAL_SASL_STATE||34||False||Request is not valid given the current SASL state.| |UNSUPPORTED_VERSION||35||False||The version of API is not supported.| |TOPIC_ALREADY_EXISTS||36||False||Topic with this name already exists.| |INVALID_PARTITIONS||37||False||Number of partitions is below 1.| |INVALID_REPLICATION_FACTOR||38||False||Replication factor is below 1 or larger than the number of available brokers.| |INVALID_REPLICA_ASSIGNMENT||39||False||Replica assignment is invalid.| |INVALID_CONFIG||40||False||Configuration is invalid.| |NOT_CONTROLLER||41||True||This is not the correct controller for this cluster.| |INVALID_REQUEST||42||False||This most likely occurs because of a request being malformed by the client library or the message was sent to an incompatible broker. See the broker logs for more details.| |UNSUPPORTED_FOR_MESSAGE_FORMAT||43||False||The message format version on the broker does not support the request.| |POLICY_VIOLATION||44||False||Request parameters do not satisfy the configured policy.| |OUT_OF_ORDER_SEQUENCE_NUMBER||45||False||The broker received an out of order sequence number.| |DUPLICATE_SEQUENCE_NUMBER||46||False||The broker received a duplicate sequence number.| |INVALID_PRODUCER_EPOCH||47||False||Producer attempted to produce with an old epoch.| |INVALID_TXN_STATE||48||False||The producer attempted a transactional operation in an invalid state.| |INVALID_PRODUCER_ID_MAPPING||49||False||The producer attempted to use a producer id which is not currently assigned to its transactional id.| |INVALID_TRANSACTION_TIMEOUT||50||False||The transaction timeout is larger than the maximum value allowed by the broker (as configured by transaction.max.timeout.ms).| |CONCURRENT_TRANSACTIONS||51||True||The producer attempted to update a transaction while another concurrent operation on the same transaction was ongoing.| |TRANSACTION_COORDINATOR_FENCED||52||False||Indicates that the transaction coordinator sending a WriteTxnMarker is no longer the current coordinator for a given producer.| |TRANSACTIONAL_ID_AUTHORIZATION_FAILED||53||False||Transactional Id authorization failed.| |SECURITY_DISABLED||54||False||Security features are disabled.| |OPERATION_NOT_ATTEMPTED||55||False||The broker did not attempt to execute this operation. This may happen for batched RPCs where some operations in the batch failed, causing the broker to respond without trying the rest.| |KAFKA_STORAGE_ERROR||56||True||Disk error when trying to access log file on the disk.| |LOG_DIR_NOT_FOUND||57||False||The user-specified log directory is not found in the broker config.| |SASL_AUTHENTICATION_FAILED||58||False||SASL Authentication failed.| |UNKNOWN_PRODUCER_ID||59||False||This exception is raised by the broker if it could not locate the producer metadata associated with the producerId in question. This could happen if, for instance, the producer's records were deleted because their retention time had elapsed. Once the last records of the producerId are removed, the producer's metadata is removed from the broker, and future appends by the producer will return this exception.| |REASSIGNMENT_IN_PROGRESS||60||False||A partition reassignment is in progress.| |DELEGATION_TOKEN_AUTH_DISABLED||61||False||Delegation Token feature is not enabled.| |DELEGATION_TOKEN_NOT_FOUND||62||False||Delegation Token is not found on server.| |DELEGATION_TOKEN_OWNER_MISMATCH||63||False||Specified Principal is not valid Owner/Renewer.| |DELEGATION_TOKEN_REQUEST_NOT_ALLOWED||64||False||Delegation Token requests are not allowed on PLAINTEXT/1-way SSL channels and on delegation token authenticated |GROUP_ID_NOT_FOUND||69||False||The group id does not exist.| |FETCH_SESSION_ID_NOT_FOUND||70||True||The fetch session ID was not found.| |INVALID_FETCH_SESSION_EPOCH||71||True||The fetch session epoch is invalid.| |LISTENER_NOT_FOUND||72||True||There is no listener on the leader broker that matches the listener on which metadata request was processed.| |TOPIC_DELETION_DISABLED||73||False||Topic deletion is disabled.| |FENCED_LEADER_EPOCH||74||True||The leader epoch in the request is older than the epoch on the broker.| |UNKNOWN_LEADER_EPOCH||75||True||The leader epoch in the request is newer than the epoch on the broker.| |UNSUPPORTED_COMPRESSION_TYPE||76||False||The requesting client does not support the compression type of given partition.| |STALE_BROKER_EPOCH||77||False||Broker epoch has changed.| |OFFSET_NOT_AVAILABLE||78||True||The leader high watermark has not caught up from a recent leader election so the offsets cannot be guaranteed to be monotonically increasing.| |MEMBER_ID_REQUIRED||79||False||The group member needs to have a valid member id before actually entering a consumer group.| |PREFERRED_LEADER_NOT_AVAILABLE||80||True||The preferred leader was not available.| |GROUP_MAX_SIZE_REACHED||81||False||The consumer group has reached its max size.| |FENCED_INSTANCE_ID||82||False||The broker rejected this static consumer since another consumer with the same group.instance.id has registered with a different member.id.| |ELIGIBLE_LEADERS_NOT_AVAILABLE||83||True||Eligible topic partition leaders are not available.| |ELECTION_NOT_NEEDED||84||True||Leader election not needed for topic partition.| |NO_REASSIGNMENT_IN_PROGRESS||85||False||No partition reassignment is in progress.| |GROUP_SUBSCRIBED_TO_TOPIC||86||False||Deleting offsets of a topic is forbidden while the consumer group is actively subscribed to it.| |INVALID_RECORD||87||False||This record has failed the validation on broker and hence will be rejected.| |UNSTABLE_OFFSET_COMMIT||88||True||There are unstable offsets that need to be cleared.| |THROTTLING_QUOTA_EXCEEDED||89||True||The throttling quota has been exceeded.| |PRODUCER_FENCED||90||False||There is a newer producer with the same transactionalId which fences the current one.| |RESOURCE_NOT_FOUND||91||False||A request illegally referred to a resource that does not exist.| |DUPLICATE_RESOURCE||92||False||A request illegally referred to the same resource twice.| |UNACCEPTABLE_CREDENTIAL||93||False||Requested credential would not meet criteria for acceptability.| |INCONSISTENT_VOTER_SET||94||False||Indicates that the either the sender or recipient of a voter-only request is not one of the expected voters| |INVALID_UPDATE_VERSION||95||False||The given update version was invalid.| |FEATURE_UPDATE_FAILED||96||False||Unable to update finalized features due to an unexpected server error.| |PRINCIPAL_DESERIALIZATION_FAILURE||97||False||Request principal deserialization failed during forwarding. This indicates an internal error on the broker cluster security setup.| |SNAPSHOT_NOT_FOUND||98||False||Requested snapshot was not found| |POSITION_OUT_OF_RANGE||99||False||Requested position is not greater than or equal to zero, and less than the size of the snapshot.| |UNKNOWN_TOPIC_ID||100||True||This server does not host this topic ID.| |DUPLICATE_BROKER_REGISTRATION||101||False||This broker ID is already in use.| |BROKER_ID_NOT_REGISTERED||102||False||The given broker ID was not registered.| |INCONSISTENT_TOPIC_ID||103||True||The log's topic ID did not match the topic ID in the request| |INCONSISTENT_CLUSTER_ID||104||False||The clusterId in the request does not match that found on the server| |TRANSACTIONAL_ID_NOT_FOUND||105||False||The transactionalId could not be found| |FETCH_SESSION_TOPIC_ID_ERROR||106||True||The fetch session encountered inconsistent topic ID usage| |INELIGIBLE_REPLICA||107||False||The new ISR contains at least one ineligible replica.| |NEW_LEADER_ELECTED||108||False||The AlterPartition request successfully updated the partition state but the leader has changed.| |OFFSET_MOVED_TO_TIERED_STORAGE||109||False||The requested offset is moved to tiered storage.| |FENCED_MEMBER_EPOCH||110||False||The member epoch is fenced by the group coordinator. The member must abandon all its partitions and rejoin.| |UNRELEASED_INSTANCE_ID||111||False||The instance ID is still used by another member in the consumer group. That member must leave first.| |UNSUPPORTED_ASSIGNOR||112||False||The assignor or its version range is not supported by the consumer group.| The following are the numeric codes that the ApiKey in the request can take for each of the below request types. This section gives details on each of the individual API Messages, their usage, their binary format, and the meaning of their fields. Headers: |request_api_version||The API version of this request.| |correlation_id||The correlation |request_api_version||The API version of this request.| |correlation_id||The correlation ID of this request.| |request_api_version||The API version of this request.| |correlation_id||The correlation ID this request.| |client_id||The | |acks||The number of acknowledgments the producer requires the leader to have received before considering a request complete. Allowed values: 0 for no acknowledgments, 1 for only the leader and -1 for the full ISR.| |timeout_ms||The timeout to await a response in milliseconds.| |topic_data||Each topic to produce to.| |name||The produce |records||The | |acks||The number of acknowledgments the producer requires the leader to have received before considering a request complete. Allowed values: 0 for no acknowledgments, 1 for only the leader and -1 for the full ISR.| |timeout_ms||The timeout to await a response in milliseconds.| |topic_data||Each topic to produce to.| |name||The produce |records||The | |acks||The number of acknowledgments the producer requires the leader to have received before considering a request complete. Allowed values: 0 for no acknowledgments, 1 for only the leader and -1 for the full ISR.| |timeout_ms||The timeout to await a response in milliseconds.| |topic_data||Each topic to produce to.| |name||The produce |records||The ||Description | |transactional_id||The transactional null the producer is not transactional.| |acks||The number of acknowledgments the producer requires the leader to have received before considering a request complete. Allowed values: 0 for no acknowledgments, 1 for only the leader and -1 for the full ISR.| |timeout_ms||The timeout to await a response in milliseconds.| |topic_data||Each topic to produce to.| |name||The produce |records||The ||Description | |transactional_id||The transactional null the producer is not transactional.| |acks||The number of acknowledgments the producer requires the leader to have received before considering a request complete. Allowed values: 0 for no acknowledgments, 1 for only the leader and -1 for the full ISR.| |timeout_ms||The timeout to await a response in milliseconds.| |topic_data||Each topic to produce to.| |name||The produce |records||The ||Description | |transactional_id||The transactional null the producer is not transactional.| |acks||The number of acknowledgments the producer requires the leader to have received before considering a request complete. Allowed values: 0 for no acknowledgments, 1 for only the leader and -1 for the full ISR.| |timeout_ms||The timeout to await a response in milliseconds.| |topic_data||Each topic to produce to.| |name||The produce |records||The ||Description | |transactional_id||The transactional null the producer is not transactional.| |acks||The number of acknowledgments the producer requires the leader to have received before considering a request complete. Allowed values: 0 for no acknowledgments, 1 for only the leader and -1 for the full ISR.| |timeout_ms||The timeout to await a response in milliseconds.| |topic_data||Each topic to produce to.| |name||The produce |records||The ||Description | |transactional_id||The transactional null the producer is not transactional.| |acks||The number of acknowledgments the producer requires the leader to have received before considering a request complete. Allowed values: 0 for no acknowledgments, 1 for only the leader and -1 for the full ISR.| |timeout_ms||The timeout to await a response in milliseconds.| |topic_data||Each topic to produce to.| |name||The produce |records||The ||Description | |transactional_id||The transactional null the producer is not transactional.| |acks||The number of acknowledgments the producer requires the leader to have received before considering a request complete. Allowed values: 0 for no acknowledgments, 1 for only the leader and -1 for the full ISR.| |timeout_ms||The timeout to await a response in milliseconds.| |topic_data||Each topic to produce to.| |name||The produce producer is not transactional.| |acks||The number of acknowledgments the producer requires the leader to have received before considering a request complete. Allowed values: 0 for no acknowledgments, 1 for only the leader and -1 for the full ISR.| |timeout_ms||The timeout to await a response in milliseconds.| |topic_data||Each topic to produce to.| |name||The produce to within the topic.| |index||The partition index.| |error_code||The error code, or 0 if there was no error.| |base_offset||The base offset.| Produce to within the topic.| |index||The partition index.| |error_code||The error code, or 0 if there was no error.| |base_offset||The base offset.| |throttle_time_ms||The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| Produce Response (Version: 2) => to within the topic.| |index||The partition index.| |error_code||The error code, or 0 was no error.| |base_offset||The base offset.| |log_append_time_ms||The timestamp returned by broker after appending the messages. If CreateTime is used for the topic, the timestamp will be -1. If LogAppendTime is used for the topic, the timestamp will be the broker local time when the messages are appended.| |throttle_time_ms||The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| Produce Response (Version: 3) => to within the topic.| |index||The partition index.| |error_code||The error code, or 0 was no error.| |base_offset||The base offset.| |log_append_time_ms||The timestamp returned by broker after appending the messages. If CreateTime is used for the topic, the timestamp will be -1. If LogAppendTime is used for the topic, the timestamp will be the broker local time when the messages are appended.| |throttle_time_ms||The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| Produce Response (Version: 4) => to within the topic.| |index||The partition index.| |error_code||The error code, or 0 was no error.| |base_offset||The base offset.| |log_append_time_ms||The timestamp returned by broker after appending the messages. If CreateTime is used for the topic, the timestamp will be -1. If LogAppendTime is used for the topic, the timestamp will be the broker local time when the messages are appended.| |throttle_time_ms||The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| Produce Response (Version: 5) => to within the topic.| |index||The partition index.| |error_code||The error code, or 0 was no error.| |base_offset||The base offset.| |log_append_time_ms||The timestamp returned by broker after appending the messages. If CreateTime is used for the topic, the timestamp will be -1. If LogAppendTime is used for the topic, the timestamp will be the broker local time when the messages are appended.| |log_start_offset||The log start offset.| |throttle_time_ms||The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| Produce Response (Version: 6) => to within the topic.| |index||The partition index.| |error_code||The error code, or 0 was no error.| |base_offset||The base offset.| |log_append_time_ms||The timestamp returned by broker after appending the messages. If CreateTime is used for the topic, the timestamp will be -1. If LogAppendTime is used for the topic, the timestamp will be the broker local time when the messages are appended.| |log_start_offset||The log start offset.| |throttle_time_ms||The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| Produce Response (Version: 7) => to within the topic.| |index||The partition index.| |error_code||The error code, or 0 was no error.| |base_offset||The base offset.| |log_append_time_ms||The timestamp returned by broker after appending the messages. If CreateTime is used for the topic, the timestamp will be -1. If LogAppendTime is used for the topic, the timestamp will be the broker local time when the messages are appended.| |log_start_offset||The log start offset.| |throttle_time_ms||The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| Produce Response (Version: 8) => to within the topic.| |index||The partition index.| |error_code||The error code, or 0 was no error.| |base_offset||The base offset.| |log_append_time_ms||The timestamp returned by broker after appending the messages. If CreateTime is used for the topic, the timestamp will be -1. If LogAppendTime is used for the topic, the timestamp will be the broker local time when the messages are appended.| |log_start_offset||The log start offset.| |record_errors||The batch indices of records that caused the batch to be dropped| |batch_index||The batch index of the record that cause the batch to be dropped| |batch_index_error_message||The error message of the record that caused the batch to be dropped| |error_message||The global error message summarizing the common root cause of the records that caused the batch to be dropped| |throttle_time_ms||The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| Requests: Produce Response to within the topic.| |index||The partition index.| |error_code||The error code, or 0 was no error.| |base_offset||The base offset.| |log_append_time_ms||The timestamp returned by broker after appending the messages. If CreateTime is used for the topic, the timestamp will be -1. If LogAppendTime is used for the topic, the timestamp will be the broker local time when the messages are appended.| |log_start_offset||The log start offset.| |record_errors||The batch indices of records that caused the batch to be dropped| |batch_index||The batch index of the record that cause the batch to be dropped| |batch_index_error_message||The error message of the record that caused the batch to be dropped| |_tagged_fields||The tagged fields| |error_message||The global error message summarizing the common root cause of the records that caused the batch to be dropped| |_tagged_fields||The tagged fields| |_tagged_fields||The tagged fields| |throttle_time_ms||The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |_tagged_fields||The tagged of the follower, of -1 if this request is from a consumer.| |max_wait_ms||The maximum time in milliseconds to wait for the response.| |min_bytes||The minimum bytes to accumulate in the response.| |topics||The topics to fetch.| |topic||The name maximum bytes to fetch from this partition. See KIP-74 for cases where this limit may not be honored.| of the follower, of -1 if this request is from a consumer.| |max_wait_ms||The maximum time in milliseconds to wait for the response.| |min_bytes||The minimum bytes to accumulate in the response.| |topics||The topics to fetch.| |topic||The name maximum bytes to fetch from this partition. See KIP-74 for cases where this limit may not be honored.| of the follower, of -1 if this request is from a consumer.| |max_wait_ms||The maximum time in milliseconds to wait for the response.| |min_bytes||The minimum bytes to accumulate in the response.| |topics||The topics to fetch.| |topic||The name maximum bytes to fetch from this partition. See KIP-74 for cases where this limit may not be honored.| of the follower, of -1 if this request is from a consumer.| |max_wait_ms||The maximum time in milliseconds to wait for the response.| |min_bytes||The minimum bytes to accumulate in the response.| |max_bytes||The maximum bytes to fetch. See KIP-74 for cases where this limit may not be honored.| |topics||The topics to fetch.| |topic||The name maximum bytes to fetch from this partition. See KIP-74 for cases where this limit may not be honored.| of the follower, of -1 if this request is from a consumer.| |max_wait_ms||The maximum time in milliseconds to wait for the response.| |min_bytes||The minimum bytes to accumulate in the response.| |max_bytes||The maximum bytes to fetch. See KIP-74 for cases where this limit may not be honored.| |isolation_level||This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records| |topics||The topics to fetch.| |topic||The maximum bytes to fetch from this partition. See KIP-74 for cases where this limit may not be honored.| of the follower, of -1 if this request is from a consumer.| |max_wait_ms||The maximum time in milliseconds to wait for the response.| |min_bytes||The minimum bytes to accumulate in the response.| |max_bytes||The maximum bytes to fetch. See KIP-74 for cases where this limit may not be honored.| |isolation_level||This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records| |topics||The topics to fetch.| |topic||The |log_start_offset||The earliest available offset of the follower replica. The field is only used when the request is sent by the follower.| |partition_max_bytes||The maximum bytes to fetch from this partition. See KIP-74 for cases where this limit may not be honored.| of the follower, of -1 if this request is from a consumer.| |max_wait_ms||The maximum time in milliseconds to wait for the response.| |min_bytes||The minimum bytes to accumulate in the response.| |max_bytes||The maximum bytes to fetch. See KIP-74 for cases where this limit may not be honored.| |isolation_level||This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records| |topics||The topics to fetch.| |topic||The |log_start_offset||The earliest available offset of the follower replica. The field is only used when the request is sent by the follower.| |partition_max_bytes||The maximum bytes to fetch from this partition. See KIP-74 for cases where this limit may not be honored.| broker ID of the follower, of -1 if this request is from a consumer.| |max_wait_ms||The maximum time in milliseconds to wait for the response.| |min_bytes||The minimum bytes to accumulate in the response.| |max_bytes||The maximum bytes to fetch. See KIP-74 for cases where this limit may not be honored.| |isolation_level||This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records| |session_id||The fetch session ID.| |session_epoch||The fetch session epoch, which is used for ordering requests in a session.| |topics||The topics to fetch.| |topic||The name |log_start_offset||The earliest available offset of the follower replica. The field is only used when the request is sent by the follower.| |partition_max_bytes||The maximum bytes to fetch from this partition. See KIP-74 for cases where this limit may not be honored.| |forgotten_topics_data||In an incremental fetch request, the partitions name.| broker ID of the follower, of -1 if this request is from a consumer.| |max_wait_ms||The maximum time in milliseconds to wait for the response.| |min_bytes||The minimum bytes to accumulate in the response.| |max_bytes||The maximum bytes to fetch. See KIP-74 for cases where this limit may not be honored.| |isolation_level||This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records| |session_id||The fetch session ID.| |session_epoch||The fetch session epoch, which is used for ordering requests in a session.| |topics||The topics to fetch.| |topic||The name |log_start_offset||The earliest available offset of the follower replica. The field is only used when the request is sent by the follower.| |partition_max_bytes||The maximum bytes to fetch from this partition. See KIP-74 for cases where this limit may not be honored.| |forgotten_topics_data||In an incremental fetch request, the partitions name.| broker ID of the follower, of -1 if this request is from a consumer.| |max_wait_ms||The maximum time in milliseconds to wait for the response.| |min_bytes||The minimum bytes to accumulate in the response.| |max_bytes||The maximum bytes to fetch. See KIP-74 for cases where this limit may not be honored.| |isolation_level||This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records| |session_id||The fetch session ID.| |session_epoch||The fetch session epoch, which is used for ordering requests in a session.| |topics||The topics to fetch.| |topic||The name fetch.| |partition||The the partition.| |fetch_offset||The message offset.| |log_start_offset||The earliest available offset of the follower replica. The field is only used when the request is sent by the follower.| |partition_max_bytes||The maximum bytes to fetch from this partition. See KIP-74 for cases where this limit may not be honored.| |forgotten_topics_data||In an incremental fetch request, the partitions name.| broker ID of the follower, of -1 if this request is from a consumer.| |max_wait_ms||The maximum time in milliseconds to wait for the response.| |min_bytes||The minimum bytes to accumulate in the response.| |max_bytes||The maximum bytes to fetch. See KIP-74 for cases where this limit may not be honored.| |isolation_level||This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records| |session_id||The fetch session ID.| |session_epoch||The fetch session epoch, which is used for ordering requests in a session.| |topics||The topics to fetch.| |topic||The name fetch.| |partition||The the partition.| |fetch_offset||The message offset.| |log_start_offset||The earliest available offset of the follower replica. The field is only used when the request is sent by the follower.| |partition_max_bytes||The maximum bytes to fetch from this partition. See KIP-74 for cases where this limit may not be honored.| |forgotten_topics_data||In an incremental fetch request, the partitions name.| ID of the follower, of -1 if this request is from a consumer.| |max_wait_ms||The maximum time in milliseconds to wait for the response.| |min_bytes||The minimum bytes to accumulate in the response.| |max_bytes||The maximum bytes to fetch. See KIP-74 for cases where this limit may not be honored.| |isolation_level||This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records| |session_id||The fetch session ID.| |session_epoch||The fetch session epoch, which is used for ordering requests in a session.| |topics||The topics to fetch.| |topic||The name fetch.| |partition||The the partition.| |fetch_offset||The message offset.| |log_start_offset||The earliest available offset of the follower replica. The field is only used when the request is sent by the follower.| |partition_max_bytes||The maximum bytes to fetch from this partition. See KIP-74 for cases where this limit may not be honored.| |forgotten_topics_data||In an incremental fetch request, the partitions name.| |partitions||The partitions indexes |rack_id||Rack of the of the follower, of -1 if this request is from a consumer.| |max_wait_ms||The maximum time in milliseconds to wait for the response.| |min_bytes||The minimum bytes to accumulate in the response.| |max_bytes||The maximum bytes to fetch. See KIP-74 for cases where this limit may not be honored.| |isolation_level||This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records| |session_id||The fetch session ID.| |session_epoch||The fetch session epoch, which is used for ordering requests in a session.| |topics||The topics to fetch.| |topic||The name fetch.| |partition||The the partition.| |fetch_offset||The message offset.| |last_fetched_epoch||The epoch of the last fetched record or -1 if there is none| |log_start_offset||The earliest available offset of the follower replica. The field is only used when the request is sent by the follower.| |partition_max_bytes||The maximum bytes to fetch from this partition. See KIP-74 for cases where this limit may not be honored.| |_tagged_fields||The tagged fields| |_tagged_fields||The tagged fields| the consumer making of the follower, of -1 if this request is from a consumer.| |max_wait_ms||The maximum time in milliseconds to wait for the response.| |min_bytes||The minimum bytes to accumulate in the response.| |max_bytes||The maximum bytes to fetch. See KIP-74 for cases where this limit may not be honored.| |isolation_level||This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records| |session_id||The fetch session ID.| |session_epoch||The fetch session epoch, which is used for ordering requests in a session.| |topics||The topics to the partition.| |fetch_offset||The message offset.| |last_fetched_epoch||The epoch of the last fetched record or -1 if there is none| |log_start_offset||The earliest available offset of the follower replica. The field is only used when the request is sent by the follower.| |partition_max_bytes||The maximum bytes to fetch from this partition. See KIP-74 for cases where this limit may not be honored.| |_tagged_fields||The tagged fields| |_tagged_fields||The tagged fields| the consumer making of the follower, of -1 if this request is from a consumer.| |max_wait_ms||The maximum time in milliseconds to wait for the response.| |min_bytes||The minimum bytes to accumulate in the response.| |max_bytes||The maximum bytes to fetch. See KIP-74 for cases where this limit may not be honored.| |isolation_level||This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records| |session_id||The fetch session ID.| |session_epoch||The fetch session epoch, which is used for ordering requests in a session.| |topics||The topics to the partition.| |fetch_offset||The message offset.| |last_fetched_epoch||The epoch of the last fetched record or -1 if there is none| |log_start_offset||The earliest available offset of the follower replica. The field is only used when the request is sent by the follower.| |partition_max_bytes||The maximum bytes to fetch from this partition. See KIP-74 for cases where this limit may not be honored.| |_tagged_fields||The tagged fields| |_tagged_fields||The tagged fields| consumer to wait for the response.| |min_bytes||The minimum bytes to accumulate in the response.| |max_bytes||The maximum bytes to fetch. See KIP-74 for cases where this limit may not be honored.| |isolation_level||This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records| |session_id||The fetch session ID.| |session_epoch||The fetch session epoch, which is used for ordering requests in a session.| |topics||The topics to the partition.| |fetch_offset||The message offset.| |last_fetched_epoch||The epoch of the last fetched record or -1 if there is none| |log_start_offset||The earliest available offset of the follower replica. The field is only used when the request is sent by the follower.| |partition_max_bytes||The maximum bytes to fetch from this partition. See KIP-74 for cases where this limit may not be honored.| |_tagged_fields||The tagged fields| |_tagged_fields||The tagged fields| the consumer making |_tagged_fields||The fields| Fetch Response index.| |error_code||The error code, or 0 if there was no fetch error.| |high_watermark||The current high water mark.| in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |responses||The response index.| |error_code||The error code, or 0 if there was no fetch error.| |high_watermark||The current high water mark.| in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |responses||The response index.| |error_code||The error code, or 0 if there was no fetch error.| |high_watermark||The current high water mark.| in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |responses||The response index.| |error_code||The error code, or 0 if there was no fetch error.| |high_watermark||The current high water mark.| in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |responses||The response index.| |error_code||The error code, or 0 if there was no fetch error.| |high_watermark||The current high water mark.| |last_stable_offset||The last stable offset (or LSO) of the partition. This is the last offset such that the state of all transactional records prior to this offset have been decided (ABORTED or COMMITTED)| |aborted_transactions||The aborted transactions.| |producer_id||The producer id associated with the aborted transaction.| |first_offset||The first offset in the aborted transaction.| in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |responses||The response index.| |error_code||The error code, or 0 if there was no fetch error.| |high_watermark||The current high water mark.| |last_stable_offset||The last stable offset (or LSO) of the partition. This is the last offset such that the state of all transactional records prior to this offset have been decided (ABORTED or COMMITTED)| |log_start_offset||The current log start offset.| |aborted_transactions||The aborted transactions.| |producer_id||The producer id associated with the aborted transaction.| |first_offset||The first offset in the aborted transaction.| in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |responses||The response index.| |error_code||The error code, or 0 if there was no fetch error.| |high_watermark||The current high water mark.| |last_stable_offset||The last stable offset (or LSO) of the partition. This is the last offset such that the state of all transactional records prior to this offset have been decided (ABORTED or COMMITTED)| |log_start_offset||The current log start offset.| |aborted_transactions||The aborted transactions.| |producer_id||The producer id associated with the aborted transaction.| |first_offset||The first offset in the aborted transaction.| in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The top level response error code.| |session_id||The fetch session ID, or 0 if this is not part of a fetch session.| |responses||The response index.| |error_code||The error code, or 0 if there was no fetch error.| |high_watermark||The current high water mark.| |last_stable_offset||The last stable offset (or LSO) of the partition. This is the last offset such that the state of all transactional records prior to this offset have been decided (ABORTED or COMMITTED)| |log_start_offset||The current log start offset.| |aborted_transactions||The aborted transactions.| |producer_id||The producer id associated with the aborted transaction.| |first_offset||The first offset in the aborted transaction.| in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The top level response error code.| |session_id||The fetch session ID, or 0 if this is not part of a fetch session.| |responses||The response index.| |error_code||The error code, or 0 if there was no fetch error.| |high_watermark||The current high water mark.| |last_stable_offset||The last stable offset (or LSO) of the partition. This is the last offset such that the state of all transactional records prior to this offset have been decided (ABORTED or COMMITTED)| |log_start_offset||The current log start offset.| |aborted_transactions||The aborted transactions.| |producer_id||The producer id associated with the aborted transaction.| |first_offset||The first offset in the aborted transaction.| in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The top level response error code.| |session_id||The fetch session ID, or 0 if this is not part of a fetch session.| |responses||The response index.| |error_code||The error code, or 0 if there was no fetch error.| |high_watermark||The current high water mark.| |last_stable_offset||The last stable offset (or LSO) of the partition. This is the last offset such that the state of all transactional records prior to this offset have been decided (ABORTED or COMMITTED)| |log_start_offset||The current log start offset.| |aborted_transactions||The aborted transactions.| |producer_id||The producer id associated with the aborted transaction.| |first_offset||The first offset in the aborted transaction.| in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The top level response error code.| |session_id||The fetch session ID, or 0 if this is not part of a fetch session.| |responses||The response index.| |error_code||The error code, or 0 if there was no fetch error.| |high_watermark||The current high water mark.| |last_stable_offset||The last stable offset (or LSO) of the partition. This is the last offset such that the state of all transactional records prior to this offset have been decided (ABORTED or COMMITTED)| |log_start_offset||The current log start offset.| |aborted_transactions||The aborted transactions.| |producer_id||The producer id associated with the aborted transaction.| |first_offset||The first offset in the aborted transaction.| in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The top level response error code.| |session_id||The fetch session ID, or 0 if this is not part of a fetch session.| |responses||The response index.| |error_code||The error code, or 0 if there was no fetch error.| |high_watermark||The current high water mark.| |last_stable_offset||The last stable offset (or LSO) of the partition. This is the last offset such that the state of all transactional records prior to this offset have been decided (ABORTED or COMMITTED)| |log_start_offset||The current log start offset.| |aborted_transactions||The aborted transactions.| |producer_id||The producer id associated with the aborted transaction.| |first_offset||The first offset in the aborted transaction.| |preferred_read_replica||The preferred read replica for the consumer to use on its next fetch request| |records||The record milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The top level response error code.| |session_id||The fetch session ID, or 0 if this is not part of a fetch session.| |responses||The response index.| |error_code||The error code, or 0 if there was no fetch error.| |high_watermark||The current high water mark.| |last_stable_offset||The last stable offset (or LSO) of the partition. This is the last offset such that the state of all transactional records prior to this offset have been decided (ABORTED or COMMITTED)| |log_start_offset||The current log start offset.| |aborted_transactions||The aborted transactions.| |producer_id||The producer id associated with the aborted transaction.| |first_offset||The first offset in the aborted transaction.| |_tagged_fields||The tagged fields| |preferred_read_replica||The preferred read replica for the consumer to use on its next fetch request| |records||The record milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The top level response error code.| |session_id||The fetch session ID, or 0 if this is not part of a fetch session.| |responses||The response topics.| partition index.| |error_code||The error code, or 0 if there was no fetch error.| |high_watermark||The current high water mark.| |last_stable_offset||The last stable offset (or LSO) of the partition. This is the last offset such that the state of all transactional records prior to this offset have been decided (ABORTED or COMMITTED)| |log_start_offset||The current log start offset.| |aborted_transactions||The aborted transactions.| |producer_id||The producer id associated with the aborted transaction.| |first_offset||The first offset in the aborted transaction.| |_tagged_fields||The tagged fields| |preferred_read_replica||The preferred read replica for the consumer to use on its next fetch request| |records||The record milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The top level response error code.| |session_id||The fetch session ID, or 0 if this is not part of a fetch session.| |responses||The response topics.| partition index.| |error_code||The error code, or 0 if there was no fetch error.| |high_watermark||The current high water mark.| |last_stable_offset||The last stable offset (or LSO) of the partition. This is the last offset such that the state of all transactional records prior to this offset have been decided (ABORTED or COMMITTED)| |log_start_offset||The current log start offset.| |aborted_transactions||The aborted transactions.| |producer_id||The producer id associated with the aborted transaction.| |first_offset||The first offset in the aborted transaction.| |_tagged_fields||The tagged fields| |preferred_read_replica||The preferred read replica for the consumer to use on its next fetch request| |records||The record milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The top level response error code.| |session_id||The fetch session ID, or 0 if this is not part of a fetch session.| |responses||The response topics.| partition index.| |error_code||The error code, or 0 if there was no fetch error.| |high_watermark||The current high water mark.| |last_stable_offset||The last stable offset (or LSO) of the partition. This is the last offset such that the state of all transactional records prior to this offset have been decided (ABORTED or COMMITTED)| |log_start_offset||The current log start offset.| |aborted_transactions||The aborted transactions.| |producer_id||The producer id associated with the aborted transaction.| |first_offset||The first offset in the aborted transaction.| |_tagged_fields||The tagged fields| |preferred_read_replica||The preferred read replica for the consumer to use on its next fetch request| |records||The record the requestor, or -1 if this request is being made by a normal consumer.| |topics||Each topic in the request.| |name||The the requestor, or -1 if this request is being made by a normal consumer.| |topics||Each topic in the request.| |name||The the requestor, or -1 if this request is being made by a normal consumer.| |isolation_level||This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records| |topics||Each topic in the the requestor, or -1 if this request is being made by a normal consumer.| |isolation_level||This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records| |topics||Each topic in the the requestor, or -1 if this request is being made by a normal consumer.| |isolation_level||This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records| |topics||Each topic in the the requestor, or -1 if this request is being made by a normal consumer.| |isolation_level||This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records| |topics||Each topic in the the requestor, or -1 if this request is being made by a normal consumer.| |isolation_level||This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records| |topics||Each topic in the the requestor, or -1 if this request is being made by a normal consumer.| |isolation_level||This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records| |topics||Each topic in the the requestor, or -1 if this request is being made by a normal consumer.| |isolation_level||This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records| |topics||Each topic in the the response.| |partition_index||The partition index.| |error_code||The partition error code, or 0 if there was no error.| |old_style_offsets||The result offsets.| the response.| |partition_index||The partition index.| |error_code||The partition error code, or 0 if there was no error.| |timestamp||The timestamp associated with the milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||Each topic in the response.| |name||The the response.| |partition_index||The partition index.| |error_code||The partition error code, or 0 if there was no error.| |timestamp||The timestamp associated with the milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||Each topic in the response.| |name||The the response.| |partition_index||The partition index.| |error_code||The partition error code, or 0 if there was no error.| |timestamp||The timestamp associated with the for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||Each topic in the response.| |name||The the response.| |partition_index||The partition index.| |error_code||The partition error code, or 0 if there was no error.| |timestamp||The timestamp associated with for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||Each topic in the response.| |name||The the response.| |partition_index||The partition index.| |error_code||The partition error code, or 0 if there was no error.| |timestamp||The timestamp associated with for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||Each topic in the response.| |name||The the response.| |partition_index||The partition index.| |error_code||The partition error code, or 0 if there was no error.| |timestamp||The timestamp associated with for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||Each topic in the response.| |name||The the response.| |partition_index||The partition index.| |error_code||The partition error code, or 0 if there was no error.| |timestamp||The timestamp associated with for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||Each topic in the response.| |name||The the response.| |partition_index||The partition index.| |error_code||The partition error code, or 0 if there was no error.| |timestamp||The timestamp associated with |name||The name.| |allow_auto_topic_creation||If this is true, the broker may auto-create topics that we requested which do not already exist, if it is configured to do so.| Metadata Request (Version: 5) |name||The name.| |allow_auto_topic_creation||If this is true, the broker may auto-create topics that we requested which do not already exist, if it is configured to do so.| Metadata Request (Version: 6) |name||The name.| |allow_auto_topic_creation||If this is true, the broker may auto-create topics that we requested which do not already exist, if it is configured to do so.| Metadata Request (Version: 7) |name||The name.| |allow_auto_topic_creation||If this is true, the broker may auto-create topics that we requested which do not already exist, if it is configured to do so.| Metadata |name||The name.| |allow_auto_topic_creation||If this is true, the broker may auto-create topics that we requested which do not already exist, if it is configured to do so.| |include_cluster_authorized_operations||Whether to include cluster authorized operations.| |include_topic_authorized_operations||Whether to |_tagged_fields||The fields| |allow_auto_topic_creation||If this is true, the broker may auto-create topics that we requested which do not already exist, if it is configured to do so.| |include_cluster_authorized_operations||Whether to include cluster authorized operations.| |include_topic_authorized_operations||Whether to this is true, the broker may auto-create topics that we requested which do not already exist, if it is configured to do so.| |include_cluster_authorized_operations||Whether to include cluster authorized operations.| |include_topic_authorized_operations||Whether to this is true, the broker may auto-create topics that we requested which do not already exist, if it is configured to do so.| |include_topic_authorized_operations||Whether to include topic authorized this is true, the broker may auto-create topics that we requested which do not already exist, if it is configured to do so.| |include_topic_authorized_operations||Whether to include topic authorized in the response.| |error_code||The topic error, or 0 if there was no error.| |name||The topic name.| |partitions||Each partition in the topic.| |error_code||The partition error, or 0 if there was no error.| |partition_index||The partition index.| |leader_id||The ID of the leader broker.| |replica_nodes||The set of all nodes that host this partition.| |isr_nodes||The set of nodes that are in sync with the leader for this partition.| Metadata |port||The broker port.| |rack||The rack of the broker, or null if it has not been assigned to a rack.| |controller_id||The ID of the controller broker.| |topics||Each topic in the response.| |error_code||The topic error, or 0 if there was no error.| |name||The topic name.| |is_internal||True if the topic is internal.| |partitions||Each partition in the topic.| |error_code||The partition error, or 0 if there was no error.| |partition_index||The partition index.| |leader_id||The ID of the leader broker.| |replica_nodes||The set of all nodes that host this partition.| |isr_nodes||The set of nodes that are in sync with the leader for this partition.| Metadata |port||The broker port.| |rack||The rack of the broker, or null if it has not been assigned to a rack.| |cluster_id||The cluster ID that responding broker belongs to.| |controller_id||The ID of the controller broker.| |topics||Each topic in the response.| |error_code||The topic error, or 0 if there was no error.| |name||The topic name.| |is_internal||True if the topic is internal.| |partitions||Each partition in the topic.| |error_code||The partition error, or 0 if there was no error.| |partition_index||The partition index.| |leader_id||The ID of the leader broker.| |replica_nodes||The set of all nodes that host this partition.| |isr_nodes||The set of nodes that are in sync with the leader for this partition.| for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |brokers||Each broker in the |port||The broker port.| |rack||The rack of the broker, or null if it has not been assigned to a rack.| |cluster_id||The cluster ID that responding broker belongs to.| |controller_id||The ID of the controller broker.| |topics||Each topic in the response.| |error_code||The topic error, or 0 if there was no error.| |name||The topic name.| |is_internal||True if the topic is internal.| |partitions||Each partition in the topic.| |error_code||The partition error, or 0 if there was no error.| |partition_index||The partition index.| |leader_id||The ID of the leader broker.| |replica_nodes||The set of all nodes that host this partition.| |isr_nodes||The set of nodes that are in sync with the leader for this partition.| for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |brokers||Each broker in the |port||The broker port.| |rack||The rack of the broker, or null if it has not been assigned to a rack.| |cluster_id||The cluster ID that responding broker belongs to.| |controller_id||The ID of the controller broker.| |topics||Each topic in the response.| |error_code||The topic error, or 0 if there was no error.| |name||The topic name.| |is_internal||True if the topic is internal.| |partitions||Each partition in the topic.| |error_code||The partition error, or 0 if there was no error.| |partition_index||The partition index.| |leader_id||The ID of the leader broker.| |replica_nodes||The set of all nodes that host this partition.| |isr_nodes||The set of nodes that are in sync with the leader for this partition.| for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |brokers||Each broker in the |port||The broker port.| |rack||The rack of the broker, or null if it has not been assigned to a rack.| |cluster_id||The cluster ID that responding broker belongs to.| |controller_id||The ID of the controller broker.| |topics||Each topic in the response.| |error_code||The topic error, or 0 if there was no error.| |name||The topic name.| |is_internal||True if the topic is internal.| |partitions||Each partition in the topic.| |error_code||The partition error, or 0 if there was no error.| |partition_index||The partition index.| |leader_id||The ID of the leader broker.| |replica_nodes||The set of all nodes that host this partition.| |isr_nodes||The set of nodes that are in sync with the leader for this partition.| |offline_replicas||The set of offline replicas of for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |brokers||Each broker in the |port||The broker port.| |rack||The rack of the broker, or null if it has not been assigned to a rack.| |cluster_id||The cluster ID that responding broker belongs to.| |controller_id||The ID of the controller broker.| |topics||Each topic in the response.| |error_code||The topic error, or 0 if there was no error.| |name||The topic name.| |is_internal||True if the topic is internal.| |partitions||Each partition in the topic.| |error_code||The partition error, or 0 if there was no error.| |partition_index||The partition index.| |leader_id||The ID of the leader broker.| |replica_nodes||The set of all nodes that host this partition.| |isr_nodes||The set of nodes that are in sync with the leader for this partition.| |offline_replicas||The set of offline replicas of for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |brokers||Each broker in the |port||The broker port.| |rack||The rack of the broker, or null if it has not been assigned to a rack.| |cluster_id||The cluster ID that responding broker belongs to.| |controller_id||The ID of the controller broker.| |topics||Each topic in the response.| |error_code||The topic error, or 0 if there was no error.| |name||The topic name.| |is_internal||True if the topic is internal.| |partitions||Each partition in the topic.| |error_code||The partition error, or 0 if there was no error.| |partition_index||The partition index.| |leader_id||The ID of the leader broker.| |leader_epoch||The leader epoch of this partition.| |replica_nodes||The set of all nodes that host this partition.| |isr_nodes||The set of nodes that are in sync with the leader for this partition.| |offline_replicas||The set of offline replicas of for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |brokers||Each broker in the |port||The broker port.| |rack||The rack of the broker, or null if it has not been assigned to a rack.| |cluster_id||The cluster ID that responding broker belongs to.| |controller_id||The ID of the controller broker.| |topics||Each topic in the response.| |error_code||The topic error, or 0 if there was no error.| |name||The topic name.| |is_internal||True if the topic is internal.| |partitions||Each partition in the topic.| |error_code||The partition error, or 0 if there was no error.| |partition_index||The partition index.| |leader_id||The ID of the leader broker.| |leader_epoch||The leader epoch of this partition.| |replica_nodes||The set of all nodes that host this partition.| |isr_nodes||The set of nodes that are in sync with the leader for this partition.| |offline_replicas||The set of offline replicas of this partition.| |topic_authorized_operations||32-bit bitfield to represent authorized operations for this topic.| |cluster_authorized_operations||32-bit bitfield to represent authorized operations for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |brokers||Each broker in the |port||The broker port.| |rack||The rack of the broker, or null if it has not been assigned to a rack.| |_tagged_fields||The tagged fields| |cluster_id||The cluster ID that responding broker belongs to.| |controller_id||The ID of the controller broker.| |topics||Each topic in the response.| |error_code||The topic error, or 0 if there was no error.| |name||The topic name.| |is_internal||True if the topic is internal.| |partitions||Each partition in the topic.| |error_code||The partition error, or 0 if there was no error.| |partition_index||The partition index.| |leader_id||The ID of the leader broker.| |leader_epoch||The leader epoch of this partition.| |replica_nodes||The set of all nodes that host this partition.| |isr_nodes||The set of nodes that are in sync with the leader for this partition.| |offline_replicas||The set of offline replicas of this partition.| |_tagged_fields||The tagged fields| |topic_authorized_operations||32-bit bitfield to topic.| |_tagged_fields||The tagged fields| |cluster_authorized_operations||32-bit bitfield to for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |brokers||Each broker in the |port||The broker port.| |rack||The rack of the broker, or null if it has not been assigned to a rack.| |_tagged_fields||The tagged fields| |cluster_id||The cluster ID that responding broker belongs to.| |controller_id||The ID of the controller broker.| |topics||Each topic in the response.| |error_code||The topic error, or 0 if there was no error.| |name||The topic name.| |topic_id||The topic id.| |is_internal||True internal.| |partitions||Each partition in the topic.| |error_code||The partition error, or 0 if there was no error.| |partition_index||The partition index.| |leader_id||The ID of the leader broker.| |leader_epoch||The leader epoch of this partition.| |replica_nodes||The set of all nodes that host this partition.| |isr_nodes||The set of nodes that are in sync with the leader for this partition.| |offline_replicas||The set of offline replicas of this partition.| |_tagged_fields||The tagged fields| |topic_authorized_operations||32-bit bitfield to topic.| |_tagged_fields||The tagged fields| |cluster_authorized_operations||32-bit bitfield to for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |brokers||Each broker in the |port||The broker port.| |rack||The rack of the broker, or null if it has not been assigned to a rack.| |_tagged_fields||The tagged fields| |cluster_id||The cluster ID that responding broker belongs to.| |controller_id||The ID of the controller broker.| |topics||Each topic in the response.| |error_code||The topic error, or 0 if there was no error.| |name||The topic name.| |topic_id||The topic id.| |is_internal||True internal.| |partitions||Each partition in the topic.| |error_code||The partition error, or 0 if there was no error.| |partition_index||The partition index.| |leader_id||The ID of the leader broker.| |leader_epoch||The leader epoch of this partition.| |replica_nodes||The set of all nodes that host this partition.| |isr_nodes||The set of nodes that are in sync with the leader for this partition.| |offline_replicas||The set of offline replicas of this partition.| |_tagged_fields||The tagged fields| |topic_authorized_operations||32-bit bitfield to for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |brokers||Each broker in the |port||The broker port.| |rack||The rack of the broker, or null if it has not been assigned to a rack.| |_tagged_fields||The tagged fields| |cluster_id||The cluster ID that responding broker belongs to.| |controller_id||The ID of the controller broker.| |topics||Each topic in the response.| |error_code||The topic error, or 0 if there was no error.| |name||The topic name.| |topic_id||The topic id.| |is_internal||True internal.| |partitions||Each partition in the topic.| |error_code||The partition error, or 0 if there was no error.| |partition_index||The partition index.| |leader_id||The ID of the leader broker.| |leader_epoch||The leader epoch of this partition.| |replica_nodes||The set of all nodes that host this partition.| |isr_nodes||The set of nodes that are in sync with the leader for this partition.| |offline_replicas||The set of offline replicas of this partition.| |_tagged_fields||The tagged fields| |topic_authorized_operations||32-bit bitfield to epoch.| |ungrouped_partition_states||The state each partition, in a v0 or v1 message.| |topic_name||The topic name. This is v1.| |partition_index||The partition index.| in-sync replica IDs.| |partition_epoch||The current epoch for the partition. The epoch is a monotonically increasing value which is incremented after every partition change. (Since the LeaderAndIsr request is only used by the legacy controller, this corresponds to the zkVersion)| |replicas||The replica epoch.| |ungrouped_partition_states||The state each partition, in a v0 or v1 message.| |topic_name||The topic name. This is v1.| |partition_index||The partition index.| in-sync replica IDs.| |partition_epoch||The current epoch for the partition. The epoch is a monotonically increasing value which is incremented after every partition change. (Since the LeaderAndIsr request is only used by the legacy controller, this corresponds to the zkVersion)| |replicas||The replica IDs.| |is_new||Whether the replica should have existed on the broker or not.| |live_leaders||The in-sync replica IDs.| |partition_epoch||The current epoch for the partition. The epoch is a monotonically increasing value which is incremented after every partition change. (Since the LeaderAndIsr request is only used by the legacy controller, this corresponds to the zkVersion)| |replicas||The replica IDs.| |is_new||Whether the replica should have existed on the broker or not.| |live_leaders||The in-sync replica IDs.| |partition_epoch||The current epoch for the partition. The epoch is a monotonically increasing value which is incremented after every partition change. (Since the LeaderAndIsr request is only used by the legacy controller, this corresponds to the zkVersion)| |replicas||The replica IDs.| |adding_replicas||The replica IDs that we are adding this partition to, or null if no replicas are being added.| |removing_replicas||The replica IDs that we are removing this partition from, or null if no replicas are being removed.| |is_new||Whether the replica should have existed on the broker or not.| |live_leaders||The in-sync replica IDs.| |partition_epoch||The current epoch for the partition. The epoch is a monotonically increasing value which is incremented after every partition change. (Since the LeaderAndIsr request is only used by the legacy controller, this corresponds to the zkVersion)| |replicas||The replica IDs.| |adding_replicas||The replica IDs that we are adding this partition to, or null if no replicas are being added.| |removing_replicas||The replica IDs that we are removing this partition from, or null if no replicas are being removed.| |is_new||Whether the replica should have existed on the broker or not.| |_tagged_fields||The tagged |broker_epoch||The current broker epoch.| |type||The type that indicates whether all topics are included in the request| |topic_states||Each topic.| |topic_name||The topic in-sync replica IDs.| |partition_epoch||The current epoch for the partition. The epoch is a monotonically increasing value which is incremented after every partition change. (Since the LeaderAndIsr request is only used by the legacy controller, this corresponds to the zkVersion)| |replicas||The replica IDs.| |adding_replicas||The replica IDs that we are adding this partition to, or null if no replicas are being added.| |removing_replicas||The replica IDs that we are removing this partition from, or null if no replicas are being removed.| |is_new||Whether the replica should have existed on the broker or not.| |_tagged_fields||The tagged |broker_epoch||The current broker epoch.| |type||The type that indicates whether all topics are included in the request| |topic_states||Each topic.| |topic_name||The topic in-sync replica IDs.| |partition_epoch||The current epoch for the partition. The epoch is a monotonically increasing value which is incremented after every partition change. (Since the LeaderAndIsr request is only used by the legacy controller, this corresponds to the zkVersion)| |replicas||The replica IDs.| |adding_replicas||The replica IDs that we are adding this partition to, or null if no replicas are being added.| |removing_replicas||The replica IDs that we are removing this partition from, or null if no replicas are being removed.| |is_new||Whether the replica should have existed on the broker or not.| |leader_recovery_state||1 if the partition is recovering from an unclean leader election; 0 otherwise.| |_tagged_fields||The ID.| |is_kraft_controller||If controller id is used during migration. See KIP-866| |controller_epoch||The current controller epoch.| |broker_epoch||The current broker epoch.| |type||The type that indicates whether all topics are included in the request| |topic_states||Each topic.| |topic_name||The topic in-sync replica IDs.| |partition_epoch||The current epoch for the partition. The epoch is a monotonically increasing value which is incremented after every partition change. (Since the LeaderAndIsr request is only used by the legacy controller, this corresponds to the zkVersion)| |replicas||The replica IDs.| |adding_replicas||The replica IDs that we are adding this partition to, or null if no replicas are being added.| |removing_replicas||The replica IDs that we are removing this partition from, or null if no replicas are being removed.| |is_new||Whether the replica should have existed on the broker or not.| |leader_recovery_state||1 if the partition is recovering from an unclean leader election; 0 otherwise.| |_tagged_fields||The if there was no error.| |partition_errors||Each partition in partition index.| |error_code||The partition code, or 0 if there was if there was no error.| |partition_errors||Each partition in partition index.| |error_code||The partition code, or 0 if there was if there was no error.| |partition_errors||Each partition in partition index.| |error_code||The partition code, or 0 if there was if there was no error.| |partition_errors||Each partition in partition index.| |error_code||The partition code, or 0 if there was if there was no error.| |partition_errors||Each partition in partition index.| |error_code||The partition code, or 0 if there was no error.| |_tagged_fields||The tagged |error_code||The partition error code, if there was no error.| |_tagged_fields||The tagged |error_code||The partition error code, if there was no error.| |_tagged_fields||The |error_code||The partition error code, if there was no error.| |_tagged_fields||The tagged controller id used during if there was no top-level error.| |partition_errors||The responses partition index.| |error_code||The partition error code, or 0 if there was no partition error.| if there was no top-level error.| |partition_errors||The responses partition index.| |error_code||The partition error code, or 0 if there was no partition error.| if there was no top-level error.| |partition_errors||The responses partition index.| |error_code||The partition error code, or 0 if there was no partition error.| |_tagged_fields||The tagged if there was no top-level error.| |partition_errors||The responses partition index.| |error_code||The partition error code, or 0 if there was no partition error.| |_tagged_fields||The tagged if there was no top-level error.| |partition_errors||The responses partition index.| |error_code||The partition error code, or 0 if there was no partition error.| |_tagged_fields||The tagged older versions of this RPC, each partition that we would like to update.| |topic_name||In older versions of this RPC, partition index.| |controller_epoch||The controller epoch.| |leader||The ID of the broker which is the current partition leader.| |leader_epoch||The leader epoch of this partition.| |isr||The brokers which the ISR for this older versions of this RPC, each partition that we would like to update.| |topic_name||In older versions of this RPC, partition index.| |controller_epoch||The controller epoch.| |leader||The ID of the broker which is the current partition leader.| |leader_epoch||The leader epoch of this partition.| |isr||The brokers which the ISR for this older versions of this RPC, each partition that we would like to update.| |topic_name||In older versions of this RPC, partition index.| |controller_epoch||The controller epoch.| |leader||The ID of the broker which is the current partition leader.| |leader_epoch||The leader epoch of this partition.| |isr||The brokers which the ISR for this |security_protocol||The security older versions of this RPC, each partition that we would like to update.| |topic_name||In older versions of this RPC, partition index.| |controller_epoch||The controller epoch.| |leader||The ID of the broker which is the current partition leader.| |leader_epoch||The leader epoch of this partition.| |isr||The brokers which the ISR for this older versions of this RPC, each partition that we would like to update.| |topic_name||In older versions of this RPC, partition index.| |controller_epoch||The controller epoch.| |leader||The ID of the broker which is the current partition leader.| |leader_epoch||The leader epoch of this partition.| |isr||The brokers which the ISR for this Zookeeper version.| |replicas||All the replicas of this partition which |topic_states||In newer versions of this RPC, each topic that we would like to update.| |topic_name||The topic name.| |partition_states||The partition that we |partition_index||The partition index.| |controller_epoch||The controller epoch.| |leader||The ID of the broker which is the current partition leader.| |leader_epoch||The leader epoch of this partition.| |isr||The brokers which the ISR for this Zookeeper version.| |replicas||All the replicas of this partition which |topic_states||In newer versions of this RPC, each topic that we would like to update.| |topic_name||The topic name.| |partition_states||The partition that we |partition_index||The partition index.| |controller_epoch||The controller epoch.| |leader||The ID of the broker which is the current partition leader.| |leader_epoch||The leader epoch of this partition.| |isr||The brokers which the ISR for this Zookeeper version.| |replicas||All the replicas of this this partition which |topic_states||In newer versions of this RPC, each topic that we would like to update.| |topic_name||The topic name.| |topic_id||The topic id.| |partition_states||The |partition_index||The partition index.| |controller_epoch||The controller epoch.| |leader||The ID of the broker which is the current partition leader.| |leader_epoch||The leader epoch of this partition.| |isr||The brokers which the ISR for this Zookeeper version.| |replicas||All the replicas of this this partition which used during See KIP-866| |controller_epoch||The controller epoch.| |broker_epoch||The broker epoch.| |topic_states||In newer versions of this RPC, each topic that we would like to update.| |topic_name||The topic name.| |topic_id||The topic id.| |partition_states||The |partition_index||The partition index.| |controller_epoch||The controller epoch.| |leader||The ID of the broker which is the current partition leader.| |leader_epoch||The leader epoch of this partition.| |isr||The brokers which the ISR for this Zookeeper version.| |replicas||All the replicas of this this partition which was no error.| no error.| was no error.| id broker for which controlled shutdown has been requested.| id broker for which controlled shutdown has been requested.| broker for which controlled shutdown has been requested.| |broker_epoch||The broker for which controlled shutdown has been requested.| |broker_epoch||The broker topic.| |partition_index||The topic.| |partition_index||The |partition_index||The |partition_index||The offsets for.| topic to commit offsets message offset to be metadata of the group.| |member_id||The member ID assigned by the group coordinator.| |topics||The topics to commit offsets for.| |name||The topic to commit offsets of |committed_metadata||Any of the group.| |member_id||The member ID assigned by the group coordinator.| |retention_time_ms||The time period in ms to retain the offset.| |topics||The topics to commit offsets for.| |name||The topic to commit offsets message offset to be metadata of the group.| |member_id||The member ID assigned by the group coordinator.| |retention_time_ms||The time period in ms to retain the offset.| |topics||The topics to commit offsets for.| |name||The topic to commit offsets message offset to be metadata of the group.| |member_id||The member ID assigned by the group coordinator.| |retention_time_ms||The time period in ms to retain the offset.| |topics||The topics to commit offsets for.| |name||The topic to commit offsets message offset to be metadata of the group.| |member_id||The member ID assigned by the group coordinator.| |topics||The topics to commit offsets for.| |name||The topic to commit offsets message offset to be metadata of the group.| |member_id||The member ID assigned by the group coordinator.| |topics||The topics to commit offsets for.| |name||The topic to commit offsets index.| |committed_offset||The message offset to be leader epoch of this partition.| |committed_metadata||Any associated metadata of the group.| |member_id||The member ID assigned by the group coordinator.| |group_instance_id||The unique identifier of the consumer instance provided by end user.| |topics||The topics to commit offsets for.| |name||The topic to commit offsets index.| |committed_offset||The message offset to be leader epoch of this partition.| |committed_metadata||Any associated of the group.| |member_id||The member ID assigned by the group coordinator.| |group_instance_id||The unique identifier of the consumer instance provided by end user.| |topics||The topics to commit offsets for.| |name||The topic to commit offsets index.| |committed_offset||The message offset to be leader epoch of this partition.| |committed_metadata||Any associated |partitions||The responses each partition in the topic.| |partition_index||The partition index.| |error_code||The error code, or 0 if was no error.| OffsetCommit Response (Version: 1) |partitions||The responses each partition in the topic.| |partition_index||The partition index.| |error_code||The error code, or 0 if was no error.| OffsetCommit Response (Version: 2) |partitions||The responses each partition in the topic.| |partition_index||The partition index.| |error_code||The error code, or 0 if for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||The responses for each topic.| |name||The topic name.| |partitions||The each partition in the topic.| |partition_index||The partition index.| |error_code||The error code, or 0 if for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||The responses for each topic.| |name||The topic name.| |partitions||The each partition in the topic.| |partition_index||The partition index.| |error_code||The error code, or 0 if for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||The responses for each topic.| |name||The topic name.| |partitions||The each partition in the topic.| |partition_index||The partition index.| |error_code||The error code, or 0 if for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||The responses for each topic.| |name||The topic name.| |partitions||The each partition in the topic.| |partition_index||The partition index.| |error_code||The error code, or 0 if for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||The responses for each topic.| |name||The topic name.| |partitions||The each partition in the topic.| |partition_index||The partition index.| |error_code||The error code, or 0 if for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||The responses for each topic.| |name||The topic name.| |partitions||The each partition in the topic.| |partition_index||The partition index.| |error_code||The error code, or 0 if no tagged fetch offsets for.| |topics||Each topic we would like to fetch offsets for, or null to fetch offsets for all topics.| |name||The topic name.| |partition_indexes||The partition indexes we would like Request fetch offsets for.| |topics||Each topic we would like to fetch offsets for, or null to fetch offsets for all topics.| |name||The topic name.| |partition_indexes||The partition indexes we would like Request fetch offsets for.| |topics||Each topic we would like to fetch offsets for, or null to fetch offsets for all topics.| |name||The topic name.| |partition_indexes||The partition indexes we would like Request fetch offsets for.| |topics||Each topic we would like to fetch offsets for, or null to fetch offsets for all topics.| |name||The topic name.| |partition_indexes||The partition indexes we would like Request fetch offsets for.| |topics||Each topic we would like to fetch offsets for, or null to fetch offsets for all topics.| |name||The topic name.| |partition_indexes||The partition indexes we would like Request fetch offsets for.| |topics||Each topic we would like to fetch offsets for, or null to fetch offsets for all topics.| |name||The topic name.| |partition_indexes||The partition indexes we would like offsets for.| |topics||Each topic we would like to fetch offsets for, or null to fetch offsets for all topics.| |name||The topic name.| |partition_indexes||The partition indexes we would like offsets |_tagged_fields||The tagged fetch offsets for.| |topics||Each topic we would like to fetch offsets for, or null to fetch offsets for all topics.| |name||The topic name.| |partition_indexes||The partition indexes we would like to fetch offsets for.| |_tagged_fields||The tagged fields| |require_stable||Whether broker should hold on returning unstable offsets but set a retriable error code for the partitions.| to fetch offsets for| |group_id||The group ID.| |topics||Each topic we would like to fetch offsets for, or null to fetch offsets for all topics.| |name||The topic name.| |partition_indexes||The partition indexes we would like offsets for.| |_tagged_fields||The tagged fields| |_tagged_fields||The tagged fields| |require_stable||Whether broker should hold on returning unstable offsets but set a retriable error code for the partitions.| |_tagged_fields||The |metadata||The partition metadata.| |error_code||The error code, or 0 if was no error.| OffsetFetch Response (Version: 1) |metadata||The partition metadata.| |error_code||The error code, or 0 if no OffsetFetch Response (Version: |metadata||The partition metadata.| |error_code||The error or 0 if there was no error.| |error_code||The top-level error code, or 0 if there for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||The responses per topic.| |metadata||The partition metadata.| |error_code||The error or 0 if there was no error.| |error_code||The top-level error code, or 0 if there for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||The responses per topic.| |metadata||The partition metadata.| |error_code||The error or 0 if there was no error.| |error_code||The top-level error code, or 0 if there for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||The responses per topic.| partition metadata.| |error_code||The error 0 if there was no error.| |error_code||The top-level error code, or 0 if there for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||The responses per topic.| partition metadata.| |error_code||The error code, if |_tagged_fields||The tagged fields| |_tagged_fields||The tagged fields| |error_code||The top-level was for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||The responses per topic.| partition metadata.| |error_code||The error code, if |_tagged_fields||The tagged fields| |_tagged_fields||The tagged fields| |error_code||The top-level for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |groups||The responses per group id.| |error_code||The partition-level |_tagged_fields||The tagged fields| |_tagged_fields||The tagged fields| |error_code||The group-level |_tagged_fields||The tagged fields| |_tagged_fields||The | |error_code||The error code, or duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |error_message||The error message, or null if there was duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |error_message||The error message, or null if there was milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |error_message||The error message, or null if there was for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |coordinators||Each coordinator result in the or 0 if there was no error.| |error_message||The error message, or null if there was no |_tagged_fields||The tagged group identifier.| |session_timeout_ms||The coordinator considers the consumer dead if it receives no heartbeat after this timeout in milliseconds.| |member_id||The member id assigned by the group coordinator.| |protocol_type||The unique name the for class of protocols implemented by the group we want to join.| |protocols||The list of protocols that the member group identifier.| |session_timeout_ms||The coordinator considers the consumer dead if it receives no heartbeat after this timeout in milliseconds.| |rebalance_timeout_ms||The maximum time in milliseconds that the coordinator will wait for each member to rejoin when rebalancing the group.| |member_id||The member id assigned by the group coordinator.| |protocol_type||The unique name the for class of protocols implemented by the group we want to join.| |protocols||The list of protocols that the member group identifier.| |session_timeout_ms||The coordinator considers the consumer dead if it receives no heartbeat after this timeout in milliseconds.| |rebalance_timeout_ms||The maximum time in milliseconds that the coordinator will wait for each member to rejoin when rebalancing the group.| |member_id||The member id assigned by the group coordinator.| |protocol_type||The unique name the for class of protocols implemented by the group we want to join.| |protocols||The list of protocols that the member group identifier.| |session_timeout_ms||The coordinator considers the consumer dead if it receives no heartbeat after this timeout in milliseconds.| |rebalance_timeout_ms||The maximum time in milliseconds that the coordinator will wait for each member to rejoin when rebalancing the group.| |member_id||The member id assigned by the group coordinator.| |protocol_type||The unique name the for class of protocols implemented by the group we want to join.| |protocols||The list of protocols that the member group identifier.| |session_timeout_ms||The coordinator considers the consumer dead if it receives no heartbeat after this timeout in milliseconds.| |rebalance_timeout_ms||The maximum time in milliseconds that the coordinator will wait for each member to rejoin when rebalancing the group.| |member_id||The member id assigned by the group coordinator.| |protocol_type||The unique name the for class of protocols implemented by the group we want to join.| |protocols||The list of protocols that the member group identifier.| |session_timeout_ms||The coordinator considers the consumer dead if it receives no heartbeat after this timeout in milliseconds.| |rebalance_timeout_ms||The maximum time in milliseconds that the coordinator will wait for each member to rejoin when rebalancing the group.| |member_id||The member id assigned by the group coordinator.| |group_instance_id||The unique identifier of the consumer instance provided by end user.| |protocol_type||The unique name the for class of protocols implemented by the group we want to join.| |protocols||The list of protocols that the member coordinator considers the consumer dead if it receives no heartbeat after this timeout in milliseconds.| |rebalance_timeout_ms||The maximum time in milliseconds that the coordinator will wait for each member to rejoin when rebalancing the group.| |member_id||The member id assigned by the group coordinator.| |group_instance_id||The unique identifier of the consumer instance provided by end user.| |protocol_type||The unique name the for class of protocols implemented by the group we want to join.| |protocols||The list of protocols that the member coordinator considers the consumer dead if it receives no heartbeat after this timeout in milliseconds.| |rebalance_timeout_ms||The maximum time in milliseconds that the coordinator will wait for each member to rejoin when rebalancing the group.| |member_id||The member id assigned by the group coordinator.| |group_instance_id||The unique identifier of the consumer instance provided by end user.| |protocol_type||The unique name the for class of protocols implemented by the group we want to join.| |protocols||The list of protocols that the member |session_timeout_ms||The coordinator considers the consumer dead if it receives no heartbeat after this timeout in milliseconds.| |rebalance_timeout_ms||The maximum time in milliseconds that the coordinator will wait for each member to rejoin when rebalancing the group.| |member_id||The member id assigned by the group coordinator.| |group_instance_id||The unique identifier of the consumer instance provided by end user.| |protocol_type||The unique name the for class of protocols implemented by the group we want to join.| |protocols||The list of protocols that the member |metadata||The protocol |session_timeout_ms||The coordinator considers the consumer dead if it receives no heartbeat after this timeout in milliseconds.| |rebalance_timeout_ms||The maximum time in milliseconds that the coordinator will wait for each member to rejoin when rebalancing the group.| |member_id||The member id assigned by the group coordinator.| |group_instance_id||The unique identifier of the consumer instance provided by end user.| |protocol_type||The unique name the for class of protocols implemented by the group we want to join.| |protocols||The list of protocols that the member |metadata||The protocol code, or 0 if there was no error.| |generation_id||The generation ID of the group.| |protocol_name||The group protocol selected by the coordinator.| |leader||The leader of the group.| |member_id||The member ID assigned the group coordinator.| member code, or 0 if there was no error.| |generation_id||The generation ID of the group.| |protocol_name||The group protocol selected by the coordinator.| |leader||The leader of the group.| |member_id||The member ID assigned the group coordinator.| member in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |generation_id||The generation ID of the group.| |protocol_name||The group protocol selected by the coordinator.| |leader||The leader of the group.| |member_id||The member ID assigned the group coordinator.| member in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |generation_id||The generation ID of the group.| |protocol_name||The group protocol selected by the coordinator.| |leader||The leader of the group.| |member_id||The member ID assigned the group coordinator.| member in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |generation_id||The generation ID of the group.| |protocol_name||The group protocol selected by the coordinator.| |leader||The leader of the group.| |member_id||The member ID assigned the group coordinator.| member milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |generation_id||The generation ID of the group.| |protocol_name||The group protocol selected by the coordinator.| |leader||The leader of the group.| |member_id||The member ID assigned the group coordinator.| |members| |member_id||The group member ID.| |group_instance_id||The unique identifier of the consumer instance provided by end user.| |metadata||The for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |generation_id||The generation ID of the group.| |protocol_name||The group protocol selected by the coordinator.| |leader||The leader of the group.| |member_id||The member ID assigned the group coordinator.| |members| |member_id||The group member ID.| |group_instance_id||The unique identifier of the consumer instance provided by user.| |metadata||The member for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |generation_id||The generation ID of the group.| |protocol_type||The group protocol name.| |protocol_name||The group protocol selected by the coordinator.| |leader||The leader of the group.| |member_id||The member ID assigned the group coordinator.| |members| |member_id||The group member ID.| |group_instance_id||The unique identifier of the consumer instance provided by user.| |metadata||The member for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |generation_id||The generation ID of the group.| |protocol_type||The group protocol name.| |protocol_name||The group protocol selected by the coordinator.| |leader||The leader of the group.| |member_id||The member ID assigned the group coordinator.| |members| |member_id||The group member ID.| |group_instance_id||The unique identifier of the consumer instance provided by user.| |metadata||The for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |generation_id||The generation ID of the group.| |protocol_type||The group protocol name.| |protocol_name||The group protocol selected by the coordinator.| |leader||The leader of the group.| |skip_assignment||True if the leader must skip running the assignment.| |member_id||The member ID assigned by the group coordinator.| |members| |member_id||The group member ID.| |group_instance_id||The unique identifier of the consumer instance provided by user.| |metadata||The group member metadata.| |_tagged_fields||The member ID.| |group_instance_id||The unique identifier of the consumer instance provided by member ID.| |group_instance_id||The unique identifier of the consumer instance provided by end user.| |_tagged_fields||The 0 if there was no error.| for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no of the group to leave.| |member_id||The member ID to remove from of the group to leave.| |member_id||The member ID to remove from of the group to leave.| |member_id||The member ID to remove from leave.| |members||List of leaving member identities.| |member_id||The member ID to remove from the group.| |group_instance_id||The group instance ID to remove from leave.| |members||List of leaving member identities.| |member_id||The member ID to remove from the group.| |group_instance_id||The group instance ID to remove from leave.| |members||List of leaving member identities.| |member_id||The member ID to remove from the group.| |group_instance_id||The group instance ID to remove from the group.| |reason||The reason why the member left the for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |members||List of leaving member responses.| |member_id||The member ID to remove from the group.| |group_instance_id||The group instance ID to remove from the group.| |error_code||The error code, or 0 if there was for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |members||List of leaving member responses.| |member_id||The member ID to remove from the group.| |group_instance_id||The group instance ID to remove from the group.| |error_code||The error code, or 0 if there was tagged for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |members||List of leaving member responses.| |member_id||The member ID to remove from the group.| |group_instance_id||The group instance ID to remove from the group.| |error_code||The error code, or 0 if there was no |_tagged_fields||The tagged identifier.| |generation_id||The generation of ID assigned by the group.| |assignments||Each assignment.| of identifier.| |generation_id||The generation of ID assigned by the group.| |assignments||Each assignment.| of identifier.| |generation_id||The generation of ID assigned by the group.| |assignments||Each assignment.| of identifier.| |generation_id||The generation of group.| |member_id||The member ID assigned by the group.| |group_instance_id||The unique identifier of the consumer instance provided by end user.| |assignments||Each assignment.| |member_id||The ID of group.| |member_id||The member ID assigned by the group.| |group_instance_id||The unique identifier of the consumer instance provided by end user.| |assignments||Each assignment.| |member_id||The ID of group.| |member_id||The member ID assigned by the group.| |group_instance_id||The unique identifier of the consumer instance provided by end user.| |protocol_type||The protocol type.| |protocol_name||The group protocol | |error_code||The code, or 0 if there was no error.| member in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no member in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no member in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no member milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was member milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |protocol_type||The group protocol type.| names describe| names include group.| |error_code||The error, or 0 if there was no error.| |group_id||The group ID string.| |group_state||The group state string, or the empty string.| |protocol_type||The group protocol type, or the empty string.| |protocol_data||The group protocol data, or the empty string.| |members||The group members.| |member_id||The member ID assigned by the group coordinator.| |client_id||The client ID used in the member's latest join group request.| |client_host||The client host.| |member_metadata||The metadata corresponding to the current group protocol in use.| |member_assignment||The current assignment provided by the in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |groups||Each described group.| |error_code||The describe error, or 0 if there was no error.| |group_id||The group ID string.| |group_state||The group state string, or the empty string.| |protocol_type||The group protocol type, or the empty string.| |protocol_data||The group protocol data, or the empty string.| |members||The group members.| |member_id||The member ID assigned by the group coordinator.| |client_id||The client ID used in the member's latest join group request.| |client_host||The client host.| |member_metadata||The metadata corresponding to the current group protocol in use.| |member_assignment||The current assignment provided by the in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |groups||Each described group.| |error_code||The describe error, or 0 if there was no error.| |group_id||The group ID string.| |group_state||The group state string, or the empty string.| |protocol_type||The group protocol type, or the empty string.| |protocol_data||The group protocol data, or the empty string.| |members||The group members.| |member_id||The member ID assigned by the group coordinator.| |client_id||The client ID used in the member's latest join group request.| |client_host||The client host.| |member_metadata||The metadata corresponding to the current group protocol in use.| |member_assignment||The current assignment provided by the milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |groups||Each described group.| |error_code||The describe error, or 0 if there was no error.| |group_id||The group ID string.| |group_state||The group state string, or the empty string.| |protocol_type||The group protocol type, or the empty string.| |protocol_data||The group protocol data, or the empty string.| |members||The group members.| |member_id||The member ID assigned by the group coordinator.| |client_id||The client ID used in the member's latest join group request.| |client_host||The client host.| |member_metadata||The metadata corresponding to the current group protocol in use.| |member_assignment||The current assignment provided by the group leader.| |authorized_operations||32-bit bitfield to represent authorized operations milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |groups||Each described group.| |error_code||The describe error, or 0 if there was no error.| |group_id||The group ID string.| |group_state||The group state string, or the empty string.| |protocol_type||The group protocol type, or the empty string.| |protocol_data||The group protocol data, or the empty string.| |members||The group members.| |member_id||The member ID assigned by the group coordinator.| |group_instance_id||The unique identifier of the consumer instance provided by end user.| |client_id||The client ID used in the member's latest join group request.| |client_host||The client host.| |member_metadata||The metadata corresponding to the current group protocol in use.| |member_assignment||The current assignment provided by the group leader.| |authorized_operations||32-bit bitfield to represent authorized operations for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |groups||Each described group.| |error_code||The describe error, or 0 if there was no error.| |group_id||The group ID string.| |group_state||The group state string, or the empty string.| |protocol_type||The group protocol type, or the empty string.| |protocol_data||The group protocol data, or the empty string.| |members||The group members.| |member_id||The member ID assigned by the group coordinator.| |group_instance_id||The unique identifier of the consumer instance provided by end user.| |client_id||The client ID used in the member's latest join group request.| |client_host||The client host.| |member_metadata||The metadata corresponding to the current group protocol in use.| |member_assignment||The current assignment provided by the group leader.| |_tagged_fields||The tagged fields| |authorized_operations||32-bit bitfield to of the groups we want to list. If empty all groups are returned with their state.| |_tagged_fields||The code, or 0 if there was no error.| |groups||Each group in the response.| in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |groups||Each group in the response.| in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |groups||Each group in the response.| for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |groups||Each group in the response.| for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |groups||Each group in the response.| |group_id||The code, or 0 if there was no error.| |mechanisms||The mechanisms enabled in code, or 0 if there was no error.| |mechanisms||The mechanisms enabled in the server.| index.| supported index.| supported version, supported version, inclusive.| |throttle_time_ms||The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| index.| supported version, supported version, inclusive.| |throttle_time_ms||The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| index.| supported |_tagged_fields||The tagged fields| |throttle_time_ms||The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |_tagged_fields||The tagged of partitions to create in the topic, or -1 if we are either specifying a manual partition assignment or using the default partitions.| |replication_factor||The number of replicas to create for each partition in the topic, or -1 if we are either specifying a manual partition assignment or using the default replication factor.| |assignments||The manual partition assignment, or the empty array if we are using automatic assignment.| |partition_index||The partition index.| |broker_ids||The brokers to place the partition custom to set.| |name||The configuration configuration value.| |timeout_ms||How long milliseconds of partitions to create in the topic, or -1 if we are either specifying a manual partition assignment or using the default partitions.| |replication_factor||The number of replicas to create for each partition in the topic, or -1 if we are either specifying a manual partition assignment or using the default replication factor.| |assignments||The manual partition assignment, or the empty array if we are using automatic assignment.| |partition_index||The partition index.| |broker_ids||The brokers to place the partition custom to set.| |name||The configuration configuration value.| |timeout_ms||How long in milliseconds before timing out the request.| |validate_only||If true, check that the topics can be created as specified, but don't create anything.| CreateTopics Request of partitions to create in the topic, or -1 if we are either specifying a manual partition assignment or using the default partitions.| |replication_factor||The number of replicas to create for each partition in the topic, or -1 if we are either specifying a manual partition assignment or using the default replication factor.| |assignments||The manual partition assignment, or the empty array if we are using automatic assignment.| |partition_index||The partition index.| |broker_ids||The brokers to place the partition custom to set.| |name||The configuration configuration value.| |timeout_ms||How long in milliseconds before timing out the request.| |validate_only||If true, check that the topics can be created as specified, but don't create anything.| CreateTopics Request of partitions to create in the topic, or -1 if we are either specifying a manual partition assignment or using the default partitions.| |replication_factor||The number of replicas to create for each partition in the topic, or -1 if we are either specifying a manual partition assignment or using the default replication factor.| |assignments||The manual partition assignment, or the empty array if we are using automatic assignment.| |partition_index||The partition index.| |broker_ids||The brokers to place the partition custom to set.| |name||The configuration configuration value.| |timeout_ms||How long in milliseconds before timing out the request.| |validate_only||If true, check that the topics can be created as specified, but don't create anything.| CreateTopics Request of partitions to create in the topic, or -1 if we are either specifying a manual partition assignment or using the default partitions.| |replication_factor||The number of replicas to create for each partition in the topic, or -1 if we are either specifying a manual partition assignment or using the default replication factor.| |assignments||The manual partition assignment, or the empty array if we are using automatic assignment.| |partition_index||The partition index.| |broker_ids||The brokers to place the partition custom to set.| |name||The configuration configuration value.| |timeout_ms||How long in milliseconds before timing out the request.| |validate_only||If true, check that the topics can be created as specified, but don't create anything.| CreateTopics of partitions to create in the topic, or -1 if we are either specifying a manual partition assignment or using the default partitions.| |replication_factor||The number of replicas to create for each partition in the topic, or -1 if we are either specifying a manual partition assignment or using the default replication factor.| |assignments||The manual partition assignment, or the empty array if we are using automatic assignment.| |partition_index||The partition index.| |broker_ids||The brokers to place the partition tagged custom in milliseconds before timing out the request.| |validate_only||If true, check that the topics can be created as specified, but don't create anything.| |_tagged_fields||The of partitions to create in the topic, or -1 if we are either specifying a manual partition assignment or using the default partitions.| |replication_factor||The number of replicas to create for each partition in the topic, or -1 if we are either specifying a manual partition assignment or using the default replication factor.| |assignments||The manual partition assignment, or the empty array if we are using automatic assignment.| |partition_index||The partition index.| |broker_ids||The brokers to place the partition tagged custom in milliseconds before timing out the request.| |validate_only||If true, check that the topics can be created as specified, but don't create anything.| |_tagged_fields||The of partitions to create in the topic, or -1 if we are either specifying a manual partition assignment or using the default partitions.| |replication_factor||The number of replicas to create for each partition in the topic, or -1 if we are either specifying a manual partition assignment or using the default replication factor.| |assignments||The manual partition assignment, or the empty array if we are using automatic assignment.| |partition_index||The partition index.| |broker_ids||The brokers to place the partition tagged custom in milliseconds before timing out the request.| |validate_only||If true, check that the topics can be created as specified, but don't create anything.| |_tagged_fields||The tagged fields| to create.| |name||The topic name.| |error_code||The error code, or 0 if was no error.| CreateTopics Response (Version: to create.| |name||The topic name.| |error_code||The error code, or 0 if there was no error.| |error_message||The error message, or null if there was for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||Results for each topic we tried to create.| |name||The topic name.| |error_code||The error code, or 0 if there was no error.| |error_message||The error message, or null if there was for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||Results for each topic we tried to create.| |name||The topic name.| |error_code||The error code, or 0 if there was no error.| |error_message||The error message, or null if there was for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||Results for each topic we tried to create.| |name||The topic name.| |error_code||The error code, or 0 if there was no error.| |error_message||The error message, or null if there was milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||Results for each topic we tried to create.| |name||The topic name.| |error_code||The error code, or 0 if there was no error.| |error_message||The error message, or null if there was no error.| |num_partitions||Number of partitions of the topic.| milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||Results for each topic we tried to create.| |name||The topic name.| |error_code||The error code, or 0 if there was no error.| |error_message||The error message, or null if there was no error.| |num_partitions||Number of partitions of the topic.| milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||Results for each topic we tried to create.| |name||The topic name.| |topic_id||The unique topic ID| |error_code||The error code, or 0 if there was no error.| |error_message||The error message, or null if there was no error.| |num_partitions||Number of partitions of the topic.| to delete| |timeout_ms||The length of time in milliseconds to wait for the deletions to to delete| |timeout_ms||The length of time in milliseconds to wait for the deletions to to delete| |timeout_ms||The length of time in milliseconds to wait for the deletions to to delete| |timeout_ms||The length of time in milliseconds to wait for the deletions to to delete| |timeout_ms||The length of time in milliseconds to wait for the deletions to complete.| to delete| |timeout_ms||The length of time in milliseconds to wait for the deletions to complete.| |topic_id||The unique topic |timeout_ms||The length of time in milliseconds to wait for the deletions to complete.| |_tagged_fields||The tried to delete.| |name||The topic name| |error_code||The deletion error, or 0 milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |responses||The results for each topic we tried to delete.| |name||The topic name| |error_code||The deletion error, or 0 milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |responses||The results for each topic we tried to delete.| |name||The topic name| |error_code||The deletion error, or 0 milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |responses||The results for each topic we tried to delete.| |name||The topic name| |error_code||The deletion error, or 0 for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |responses||The results for each topic we tried to delete.| |name||The topic name| |error_code||The deletion error, or 0 for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |responses||The results for each topic we tried to delete.| |name||The topic name| |error_code||The deletion error, or 0 if the deletion succeeded.| |error_message||The error message, or null if there was tagged for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |responses||The results for each topic we tried to delete.| |name||The topic name| |topic_id||the unique topic ID| |error_code||The deletion error, or 0 if the deletion succeeded.| |error_message||The error message, or null if there was no |_tagged_fields||The tagged delete records from.| |name||The topic name.| |partitions||Each partition that we want from.| |partition_index||The partition index.| |offset||The deletion offset.| |timeout_ms||How long to wait for the deletion to complete, in milliseconds.| DeleteRecords Request (Version: delete records from.| |name||The topic name.| |partitions||Each partition that we want from.| |partition_index||The partition index.| |offset||The deletion offset.| |timeout_ms||How long to for the deletion to complete, Responses: delete records from.| |name||The topic name.| |partitions||Each partition that we want fields| |timeout_ms||How long to wait for the deletion to complete, in milliseconds.| |_tagged_fields||The for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||Each topic that we wanted to delete records from.| |name||The topic name.| |partitions||Each partition that we wanted to delete records from.| |partition_index||The partition index.| |low_watermark||The partition low water mark.| |error_code||The deletion error code, or 0 if the for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||Each topic that we wanted to delete records from.| |name||The topic name.| |partitions||Each partition that we wanted to delete records from.| |partition_index||The partition index.| |low_watermark||The partition low water mark.| |error_code||The deletion error code, or 0 if the for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||Each topic that we wanted to delete records from.| |name||The topic name.| |partitions||Each partition that we wanted to delete records from.| |partition_index||The partition index.| |low_watermark||The partition low water mark.| |error_code||The deletion error code, or 0 if the deletion tagged if the producer is not transactional.| |transaction_timeout_ms||The time in ms to wait before aborting idle transactions sent by this producer. This is only relevant if a TransactionalId has been if the producer is not transactional.| |transaction_timeout_ms||The time in ms to wait before aborting idle transactions sent by this producer. This is only relevant if a TransactionalId has been if the producer is not transactional.| |transaction_timeout_ms||The time in ms to wait before aborting idle transactions sent by this producer. This is only relevant if a TransactionalId has been defined.| if the producer is not transactional.| |transaction_timeout_ms||The time in ms to wait before aborting idle transactions sent by this producer. This is only relevant if a TransactionalId has been defined.| |producer_id||The producer id. This is used to disambiguate requests if a transactional id is reused following its expiration.| |producer_epoch||The producer's current epoch. This will be checked against the producer epoch on the broker, and the request will return an error if they do not match.| |_tagged_fields||The if the producer is not transactional.| |transaction_timeout_ms||The time in ms to wait before aborting idle transactions sent by this producer. This is only relevant if a TransactionalId has been defined.| |producer_id||The producer id. This is used to disambiguate requests if a transactional id is reused following its expiration.| |producer_epoch||The producer's current epoch. This will be checked against the producer epoch on the broker, and the request will return an error if they do not match.| |_tagged_fields||The for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |producer_id||The current producer id.| |producer_epoch||The current epoch associated for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |producer_id||The current producer id.| |producer_epoch||The current epoch associated for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |producer_id||The current producer id.| |producer_epoch||The current epoch associated for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |producer_id||The current producer id.| |producer_epoch||The current epoch for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |producer_id||The current producer id.| |producer_epoch||The current epoch associated to get offsets for.| |partition||The partition index.| |leader_epoch||The epoch to look 1) to get offsets for.| |partition||The partition index.| |leader_epoch||The epoch to look 2) to get offsets partition index.| |current_leader_epoch||An epoch used to fence consumers/replicas with old metadata. If the epoch provided by the client is larger than the current epoch known to the broker, then the UNKNOWN_LEADER_EPOCH error code will be returned. If the provided epoch is smaller, then the FENCED_LEADER_EPOCH error code will be returned.| |leader_epoch||The epoch to look up an of the follower, of -1 if this request is from a consumer.| |topics||Each topic to get offsets for.| |topic||The topic to get offsets partition index.| |current_leader_epoch||An epoch used to fence consumers/replicas with old metadata. If the epoch provided by the client is larger than the current epoch known to the broker, then the UNKNOWN_LEADER_EPOCH error code will be returned. If the provided epoch is smaller, then the FENCED_LEADER_EPOCH error code will be returned.| |leader_epoch||The epoch to look up an of the follower, of -1 if this request is from a consumer.| |topics||Each topic to get offsets for.| |topic||The topic to get offsets partition index.| |current_leader_epoch||An epoch used to fence consumers/replicas with old metadata. If the epoch provided by the client is larger than the current epoch known to the broker, then the UNKNOWN_LEADER_EPOCH error code will be returned. If the provided epoch is smaller, then the FENCED_LEADER_EPOCH error code will be returned.| |leader_epoch||The epoch to look up an offset |topic||The topic name.| |partitions||Each partition in the topic we fetched offsets for.| |error_code||The error code 0, or if there was no error.| |partition||The partition index.| |end_offset||The end |topic||The topic name.| |partitions||Each partition in the topic we fetched offsets for.| |error_code||The error code 0, or if there was no error.| |partition||The partition index.| |leader_epoch||The leader epoch of the for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||Each topic we fetched offsets for.| |topic||The topic name.| |partitions||Each partition in the topic we fetched offsets for.| |error_code||The error code 0, or if there was no error.| |partition||The partition index.| |leader_epoch||The leader epoch of the for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||Each topic we fetched offsets for.| |topic||The topic name.| |partitions||Each partition in the topic we fetched offsets for.| |error_code||The error code 0, or if there was no error.| |partition||The partition index.| |leader_epoch||The leader epoch of for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||Each topic we fetched offsets for.| |topic||The topic name.| |partitions||Each partition in the topic we fetched offsets for.| |error_code||The error code 0, or if there was no error.| |partition||The partition index.| |leader_epoch||The leader epoch of the producer id in use by the transactional id.| |v3_and_below_producer_epoch||Current epoch associated with the producer id.| |v3_and_below_topics||The partitions to add to the transaction.| |name||The name of the topic.| |partitions||The partition indexes to producer id in use by the transactional id.| |v3_and_below_producer_epoch||Current epoch associated with the producer id.| |v3_and_below_topics||The partitions to add to the transaction.| |name||The name of the topic.| |partitions||The partition indexes to producer id in use by the transactional id.| |v3_and_below_producer_epoch||Current epoch associated with the producer id.| |v3_and_below_topics||The partitions to add to the transaction.| |name||The name of the topic.| |partitions||The partition indexes to producer id in use by the transactional id.| |v3_and_below_producer_epoch||Current epoch associated with the producer id.| |v3_and_below_topics||The partitions to add to the transaction.| |name||The name of the topic.| |partitions||The partition indexes to transactional id corresponding to the transaction.| id in use by the transactional id.| |producer_epoch||Current epoch associated with the producer id.| |verify_only||Boolean to signify if we want to check if the partition is in the transaction rather than add it.| |topics||The partitions to add to the transaction.| |name||The name of the topic.| |partitions||The partition indexes to the which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |results_by_topic_v3_and_below||The results for each topic.| |name||The which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |results_by_topic_v3_and_below||The results for each topic.| |name||The which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |results_by_topic_v3_and_below||The results for each topic.| |name||The which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |results_by_topic_v3_and_below||The results for each topic.| |name||The which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The response top level error code.| |results_by_transaction||Results categorized |transactional_id||The transactional |name||The to the transaction.| producer id in use by the transactional id.| |producer_epoch||Current epoch associated with the producer to the transaction.| producer id in use by the transactional id.| |producer_epoch||Current epoch associated with the producer to the transaction.| producer id in use by the transactional id.| |producer_epoch||Current epoch associated with the producer id in use by the transactional id.| |producer_epoch||Current epoch associated with the which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The response error code, or 0 if there was which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The response error code, or 0 if there was which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The response error code, or 0 if there was which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The response error code, or 0 if there was no error.| |_tagged_fields||The transaction to end.| |producer_id||The producer ID.| |producer_epoch||The current epoch associated with the producer.| |committed||True if the transaction was committed, false if it aborted.| EndTxn transaction to end.| |producer_id||The producer ID.| |producer_epoch||The current epoch associated with the producer.| |committed||True if the transaction was committed, false if it aborted.| EndTxn transaction to end.| |producer_id||The producer ID.| |producer_epoch||The current epoch associated with the producer.| |committed||True if the transaction was committed, false if it Responses: transaction to end.| |producer_id||The producer ID.| |producer_epoch||The current epoch associated with the producer.| |committed||True if the transaction was committed, false if it was aborted.| |_tagged_fields||The for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no |_tagged_fields||The tagged |producer_id||The current producer ID.| |producer_epoch||The current epoch associated with the producer ID.| |transaction_result||The result of the transaction to write to the partitions (false = ABORT, true = COMMIT).| |topics||Each topic that we want to write transaction marker(s) for.| |name||The topic name.| |partition_indexes||The indexes of the partitions to write transaction markers for.| |coordinator_epoch||Epoch associated with the transaction state partition hosted by this transaction coordinator| Responses: |producer_id||The current producer ID.| |producer_epoch||The current epoch associated with the producer ID.| |transaction_result||The result of the transaction to write to the partitions (false = ABORT, true = COMMIT).| |topics||Each topic that we want to write transaction marker(s) for.| |name||The topic name.| |partition_indexes||The indexes of transaction markers for.| |_tagged_fields||The tagged fields| |coordinator_epoch||Epoch associated with the transaction state partition hosted by this transaction coordinator| |_tagged_fields||The tagged producer ID in use by the |topics||The results |partition_index||The partition index.| |error_code||The error or 0 if producer ID in use by the |topics||The results |partition_index||The partition index.| |error_code||The error code, or 0 if no tagged ID of the group.| |producer_id||The current producer ID in use by the transactional ID.| |producer_epoch||The current epoch associated with the producer ID.| |topics||Each topic that we want to commit offsets for.| |name||The topic name.| |partitions||The partitions inside the topic that we want to committ offsets for.| |partition_index||The index of the partition within the topic.| |committed_offset||The message offset to be committed.| |committed_metadata||Any associated metadata ID of the group.| |producer_id||The current producer ID in use by the transactional ID.| |producer_epoch||The current epoch associated with the producer ID.| |topics||Each topic that we want to commit offsets for.| |name||The topic name.| |partitions||The partitions inside the topic that we want to committ offsets for.| |partition_index||The index of the partition within the topic.| |committed_offset||The message offset to be committed.| |committed_metadata||Any associated metadata ID of the group.| |producer_id||The current producer ID in use by the transactional ID.| |producer_epoch||The current epoch associated with the producer ID.| |topics||Each topic that we want to commit offsets for.| |name||The topic name.| |partitions||The partitions inside the topic that we want to committ offsets for.| |partition_index||The index of the partition within the topic.| |committed_offset||The message offset to be committed.| |committed_leader_epoch||The leader epoch of the last consumed record.| |committed_metadata||Any associated metadata the client ID of the group.| |producer_id||The current producer ID in use by the transactional ID.| |producer_epoch||The current epoch associated with the producer ID.| |generation_id||The generation of the consumer.| |member_id||The member ID assigned by the group coordinator.| |group_instance_id||The unique identifier of the consumer instance provided by end user.| |topics||Each topic that we want to commit offsets for.| |name||The topic name.| |partitions||The partitions inside the topic that we want to committ offsets for.| |partition_index||The index of the partition within the topic.| |committed_offset||The message offset to be committed.| |committed_leader_epoch||The leader epoch of the last consumed record.| |committed_metadata||Any associated metadata the client for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||The responses for each topic.| |name||The topic name.| |partitions||The each partition in the topic.| |partition_index||The partition index.| |error_code||The error code, or 0 if for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||The responses for each topic.| |name||The topic name.| |partitions||The each partition in the topic.| |partition_index||The partition index.| |error_code||The error code, or 0 if for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||The responses for each topic.| |name||The topic name.| |partitions||The each partition in the topic.| |partition_index||The partition index.| |error_code||The error code, or 0 if for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||The responses for each topic.| |name||The topic name.| |partitions||The each partition in the topic.| |partition_index||The partition index.| |error_code||The error code, or 0 if no tagged or null to match any resource name.| |principal_filter||The principal to match, or null to match any principal.| |host_filter||The host to match, or null to match any host.| |operation||The operation to match.| |permission_type||The or null to match any resource name.| |pattern_type_filter||The resource pattern to match.| |principal_filter||The principal to match, or null to match any principal.| |host_filter||The host to match, or null to match any host.| |operation||The operation to match.| |permission_type||The or null to match any resource name.| |pattern_type_filter||The resource pattern to match.| |principal_filter||The principal to match, or null to match any principal.| |host_filter||The host to match, or null to match any host.| |operation||The operation to match.| or null to match any resource name.| |pattern_type_filter||The resource pattern to match.| |principal_filter||The principal to match, or null to match any principal.| |host_filter||The host to match, or null to match any host.| |operation||The operation to match.| |permission_type||The for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |error_message||The error message, or null if there was no error.| |resources||Each Resource that is referenced for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |error_message||The error message, or null if there was no error.| |resources||Each Resource that is referenced for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |error_message||The error message, or null if there was no error.| |resources||Each Resource that is referenced for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |error_message||The error message, or null if there was no error.| |resources||Each Resource that is referenced |resource_type||The type of the resource.| |resource_name||The resource name for the ACL.| |principal||The principal for the ACL.| |host||The host for the ACL.| |operation||The operation type for the ACL (read, write, etc.).| |permission_type||The permission type for the |resource_type||The type of the resource.| |resource_name||The resource name for the ACL.| |resource_pattern_type||The pattern type for the ACL.| |principal||The principal for the ACL.| |host||The host for the ACL.| |operation||The operation type for the ACL (read, write, etc.).| |permission_type||The permission type for the |resource_type||The type of the resource.| |resource_name||The resource name for the ACL.| |resource_pattern_type||The pattern type for the ACL.| |principal||The principal for the ACL.| |host||The host for the ACL.| |operation||The operation type for the ACL (read, write, etc.).| |permission_type||The permission type for the |resource_type||The type of the resource.| |resource_name||The resource name for the ACL.| |resource_pattern_type||The pattern type for the ACL.| |principal||The principal for the ACL.| |host||The host for the ACL.| |operation||The operation type for the ACL (read, write, etc.).| |permission_type||The permission type for the for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |results||The results for each ACL creation.| |error_code||The result error, or zero if there was no error.| |error_message||The result message, or null if there was for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |results||The results for each ACL creation.| |error_code||The result error, or zero if there was no error.| |error_message||The result message, or null if there was for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |results||The results for each ACL creation.| |error_code||The result error, or zero if there was no error.| |error_message||The result message, or null if there was tagged for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |results||The results for each ACL creation.| |error_code||The result error, or zero if there was no error.| |error_message||The result message, or null if there was no |_tagged_fields||The tagged resource type.| |resource_name_filter||The resource name.| |principal_filter||The principal filter, or null to accept all principals.| |host_filter||The host filter, or null to resource name.| |pattern_type_filter||The pattern filter, or null to accept all principals.| |host_filter||The host filter, or null to resource name.| |pattern_type_filter||The pattern filter, or null to accept all principals.| |host_filter||The host filter, or null to resource name.| |pattern_type_filter||The pattern filter, or null to accept all principals.| |host_filter||The host filter, or null to for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |filter_results||The results for each filter.| |error_code||The error code, or 0 if the filter succeeded.| |error_message||The error message, or null if the filter succeeded.| |matching_acls||The ACLs which matched this filter.| |error_code||The deletion error code, or 0 if the deletion succeeded.| |error_message||The deletion error message, or null if the for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |filter_results||The results for each filter.| |error_code||The error code, or 0 if the filter succeeded.| |error_message||The error message, or null if the filter succeeded.| |matching_acls||The ACLs which matched this filter.| |error_code||The deletion error code, or 0 if the deletion succeeded.| |error_message||The deletion error message, or null if the for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |filter_results||The results for each filter.| |error_code||The error code, or 0 if the filter succeeded.| |error_message||The error message, or null if the filter succeeded.| |matching_acls||The ACLs which matched this filter.| |error_code||The deletion error code, or 0 if the deletion succeeded.| |error_message||The deletion error message, or null if the for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |filter_results||The results for each filter.| |error_code||The error code, or 0 if the filter succeeded.| |error_message||The error message, or null if the filter succeeded.| |matching_acls||The ACLs which matched this filter.| |error_code||The deletion error code, or 0 if the deletion succeeded.| |error_message||The deletion error message, or null if the |resource_type||The resource type.| |resource_name||The resource name.| |configuration_keys||The configuration keys to list, or null to list all configuration keys.| DescribeConfigs |resource_type||The resource type.| |resource_name||The resource name.| |configuration_keys||The configuration keys to list, or null to list all configuration keys.| |include_synonyms||True if we should include all |resource_type||The resource type.| |resource_name||The resource name.| |configuration_keys||The configuration keys to list, or null to list all configuration keys.| |include_synonyms||True if we should include |resource_type||The resource type.| |resource_name||The resource name.| |configuration_keys||The configuration keys to list, or null to list all configuration keys.| |include_synonyms||True if we should include all synonyms.| |include_documentation||True if we should include |resource_type||The resource type.| |resource_name||The resource name.| |configuration_keys||The configuration keys to list, or null to list all configuration keys.| |_tagged_fields||The tagged fields| |include_synonyms||True if we should include all synonyms.| |include_documentation||True if we should include configuration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |results||The results for each resource.| |error_code||The error code, or 0 if we were able to successfully describe the configurations.| |error_message||The error message, or null if we were able to successfully describe the configurations.| |resource_type||The resource the read-only.| |is_default||True if the configuration is not set.| |is_sensitive||True if milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |results||The results for each resource.| |error_code||The error code, or 0 if we were able to successfully describe the configurations.| |error_message||The error message, or null if we were able to successfully describe the configurations.| |resource_type||The resource if this milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |results||The results for each resource.| |error_code||The error code, or 0 if we were able to successfully describe the configurations.| |error_message||The error message, or null if we were able to successfully describe the configurations.| |resource_type||The resource if this milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |results||The results for each resource.| |error_code||The error code, or 0 if we were able to successfully describe the configurations.| |error_message||The error message, or null if we were able to successfully describe the configurations.| |resource_type||The resource if this type. Type can be one of the following values - BOOLEAN, STRING, INT, SHORT, LONG, DOUBLE, LIST, CLASS, PASSWORD| |documentation||The milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |results||The results for each resource.| |error_code||The error code, or 0 if we were able to successfully describe the configurations.| |error_message||The error message, or null if we were able to successfully describe the configurations.| |resource_type||The resource if this data type. Type can be one of the following values - BOOLEAN, STRING, INT, SHORT, LONG, DOUBLE, LIST, CLASS, PASSWORD| |documentation||The configuration to set for the configuration key.| |validate_only||True if we should validate the request, but not change the configurations.| AlterConfigs to set for the configuration key.| |validate_only||True if we should validate the request, but not change the configurations.| Responses: key.| |_tagged_fields||The tagged fields| |_tagged_fields||The tagged fields| |validate_only||True if we should validate the request, but not change the configurations.| |_tagged_fields||The for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |responses||The responses for each resource.| |error_code||The resource error code.| |error_message||The resource error message, or null if there was no error.| |resource_type||The resource for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |responses||The responses for each resource.| |error_code||The resource error code.| |error_message||The resource error message, or null if there was error.| |resource_type||The resource which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |responses||The responses for each resource.| |error_code||The resource error code.| |error_message||The resource error message, or null if there was no error.| |resource_type||The resource directory.| |path||The absolute directory path.| |topics||The topics to directory.| |path||The absolute directory path.| |topics||The topics to directory.| |path||The absolute directory path.| |topics||The topics to which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |results||The results for each topic.| |topic_name||The name of results for each partition.| |partition_index||The partition index.| |error_code||The error code, or 0 if which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |results||The results for each topic.| |topic_name||The name of results for each partition.| |partition_index||The partition index.| |error_code||The error code, or 0 if which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |results||The results for each topic.| |topic_name||The name of results for each partition.| |partition_index||The partition index.| |error_code||The error code, or 0 if no tagged | |topics||Each topic that we want to describe log directories for, or null for all topics.| |topic||The topic | |topics||Each topic that we want to describe log directories for, or null for all topics.| |topic||The topic topic that we want to describe log directories for, or null for all topics.| |topic||The topic topic that we want to describe log directories for, or null for all topics.| |topic||The topic topic that we want to describe log directories for, or null for all topics.| |topic||The topic milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |results||The log directories.| |error_code||The error code, or 0 if there was no error.| |log_dir||The absolute the log segments in this partition in bytes.| |offset_lag||The lag of the log's LEO w.r.t. partition's HW (if it is the current log for the partition) or current replica's LEO (if it is the future log for the partition)| |is_future_key||True if this log is created by AlterReplicaLogDirsRequest and will replace the current log of the replica in the future.| milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |results||The log directories.| |error_code||The error code, or 0 if there was no error.| |log_dir||The absolute the log segments in this partition in bytes.| |offset_lag||The lag of the log's LEO w.r.t. partition's HW (if it is the current log for the partition) or current replica's LEO (if it is the future log for the partition)| |is_future_key||True if this log is created by AlterReplicaLogDirsRequest and will replace the current log of the replica in the future.| milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |results||The log directories.| |error_code||The error code, or 0 if there was no error.| |log_dir||The absolute the log segments in this partition in bytes.| |offset_lag||The lag of the log's LEO w.r.t. partition's HW (if it is the current log for the partition) or current replica's LEO (if it is the future log for the partition)| |is_future_key||True if this log is created by AlterReplicaLogDirsRequest and will replace the current log of the replica in the future.| |_tagged_fields||The tagged milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |results||The log directories.| |error_code||The error code, or 0 if there was no error.| |log_dir||The absolute the log segments in this partition in bytes.| |offset_lag||The lag of the log's LEO w.r.t. partition's HW (if it is the current log for the partition) or current replica's LEO (if it is the future log for the partition)| |is_future_key||True if this log is created by AlterReplicaLogDirsRequest and will replace the current log of the replica in the future.| |_tagged_fields||The tagged for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |results||The log directories.| |error_code||The error code, or 0 if there was no error.| |log_dir||The absolute the log segments in this partition in bytes.| |offset_lag||The lag of the log's LEO w.r.t. partition's HW (if it is the current log for the partition) or current replica's LEO (if it is the future log for the partition)| |is_future_key||True if this log is created by AlterReplicaLogDirsRequest and will replace the current log of the replica in the future.| |_tagged_fields||The tagged fields| |_tagged_fields||The tagged fields| |total_bytes||The total size in bytes of the volume the log directory is in.| |usable_bytes||The usable size in bytes of the volume the log directory is in.| |_tagged_fields||The tagged SASL the client, as defined by mechanism.| SASL client, defined by defined by the SASL mechanism.| or 0 if there was no error.| |error_message||The error message, or null if there was no error.| |auth_bytes||The SASL authentication bytes from the server, as defined or 0 if there was no error.| |error_message||The error message, or null if there was no error.| |auth_bytes||The SASL authentication bytes from the server, as defined by the SASL mechanism.| |session_lifetime_ms||The SASL authentication bytes from the server, 0 if there was no error.| |error_message||The error message, or null if there was no error.| |auth_bytes||The SASL authentication bytes from the server, as defined by the SASL mechanism.| |session_lifetime_ms||The SASL authentication bytes from the server, the SASL mechanism.| create inside.| |name||The topic |broker_ids||The assigned broker IDs.| |timeout_ms||The time in ms to wait for the partitions to be created.| |validate_only||If true, then validate the request, but don't actually increase the number of partitions.| create inside.| |name||The topic |broker_ids||The assigned broker IDs.| |timeout_ms||The time in ms to wait for the partitions to be created.| |validate_only||If true, then validate the request, but don't actually increase the number of create inside.| |name||The topic |_tagged_fields||The tagged |timeout_ms||The time in to wait for the partitions to be created.| |validate_only||If true, then validate the request, but don't actually increase the number of partitions.| create inside.| |name||The topic |_tagged_fields||The tagged |timeout_ms||The time in to wait for the partitions to be created.| |validate_only||If true, then validate the request, but don't actually increase the number of partitions.| for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |results||The partition creation results for each topic.| |name||The topic name.| |error_code||The result error, or zero if there was no error.| |error_message||The result message, or null if there was for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |results||The partition creation results for each topic.| |name||The topic name.| |error_code||The result error, or zero if there was no error.| |error_message||The result message, or null if there was for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |results||The partition creation results for each topic.| |name||The topic name.| |error_code||The result error, or zero if there was no error.| |error_message||The result message, or null if there was tagged for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |results||The partition creation results for each topic.| |name||The topic name.| |error_code||The result error, or zero if there was no error.| |error_message||The result message, or null if there was no |_tagged_fields||The tagged |renewers||A list of those who are allowed to renew this token before it expires.| |principal_type||The type of the Kafka principal.| |principal_name||The name of the Kafka principal.| |max_lifetime_ms||The maximum lifetime of the token in milliseconds, or -1 to use the server |renewers||A list of those who are allowed to renew this token before it expires.| |principal_type||The type of the Kafka principal.| |principal_name||The name of the Kafka principal.| |max_lifetime_ms||The maximum lifetime of the token in milliseconds, or -1 to use the server of those who are allowed to renew this token before it expires.| |principal_type||The type of the Kafka principal.| |principal_name||The name of the Kafka principal.| |_tagged_fields||The tagged fields| |max_lifetime_ms||The maximum lifetime of the token in milliseconds, or -1 to use the server side type of the owner of the token. If it's null it defaults to the token request principal.| |owner_principal_name||The principal name of the owner of the token. If it's null it defaults to the token request principal.| |renewers||A list of those who are allowed to renew this token before it expires.| |principal_type||The type of the Kafka principal.| |principal_name||The name of the Kafka principal.| |_tagged_fields||The tagged fields| |max_lifetime_ms||The maximum lifetime of the token in milliseconds, or -1 to use the server side if there was no error.| |principal_type||The principal type of the token owner.| |principal_name||The name of the token owner.| |issue_timestamp_ms||When this token was generated.| |expiry_timestamp_ms||When this token lifetime of token of the delegation token.| |throttle_time_ms||The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| if there was no error.| |principal_type||The principal type of the token owner.| |principal_name||The name of the token owner.| |issue_timestamp_ms||When this token was generated.| |expiry_timestamp_ms||When this token lifetime of token of the delegation token.| |throttle_time_ms||The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| if there was no error.| |principal_type||The principal type of the token owner.| |principal_name||The name of the token owner.| |issue_timestamp_ms||When this token was generated.| |expiry_timestamp_ms||When this token lifetime of token of the delegation token.| |throttle_time_ms||The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |_tagged_fields||The if there was no error.| |principal_type||The principal type of the token owner.| |principal_name||The name of the token owner.| |token_requester_principal_type||The principal type of the requester of the token.| |token_requester_principal_name||The principal type of the requester of the token.| this token was generated.| |expiry_timestamp_ms||When token lifetime of token of the delegation token.| |throttle_time_ms||The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |_tagged_fields||The be renewed.| |renew_period_ms||The renewal time period renewed.| |renew_period_ms||The renewal time period be renewed.| |renew_period_ms||The renewal time period in there was no error.| |expiry_timestamp_ms||The timestamp in milliseconds at which this token expires.| |throttle_time_ms||The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| there was no error.| |expiry_timestamp_ms||The timestamp in milliseconds at which this token expires.| |throttle_time_ms||The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| there was no error.| |expiry_timestamp_ms||The timestamp in milliseconds at which this token expires.| |throttle_time_ms||The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |_tagged_fields||The be expired.| |expiry_time_period_ms||The expiry time period expired.| |expiry_time_period_ms||The expiry time period be expired.| |expiry_time_period_ms||The expiry time period in there was no error.| |expiry_timestamp_ms||The timestamp in milliseconds at which this token expires.| |throttle_time_ms||The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| there was no error.| |expiry_timestamp_ms||The timestamp in milliseconds at which this token expires.| |throttle_time_ms||The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| there was no error.| |expiry_timestamp_ms||The timestamp in milliseconds at which this token expires.| |throttle_time_ms||The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |_tagged_fields||The tagged owner that we want to describe delegation tokens for, or null to describe all tokens.| |principal_type||The owner principal type.| owner that we want to describe delegation tokens for, or null to describe all tokens.| |principal_type||The owner principal type.| we want to describe delegation tokens for, or null to describe all tokens.| |principal_type||The owner type.| we want to describe delegation tokens for, or null to describe all tokens.| |principal_type||The owner type.| no error.| |tokens||The tokens.| |principal_type||The token |hmac||The token HMAC.| |renewers||Those who are to renew before |principal_type||The renewer milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| no error.| |tokens||The tokens.| |principal_type||The token |hmac||The token HMAC.| |renewers||Those who are to renew before |principal_type||The renewer milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| no error.| |tokens||The tokens.| |principal_type||The token |hmac||The token HMAC.| |renewers||Those who are to renew before |principal_type||The in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |_tagged_fields||The no error.| |tokens||The tokens.| |principal_type||The token principal type.| type of the requester of the token.| |token_requester_principal_name||The principal type of the requester the token.| token issue |hmac||The token HMAC.| |renewers||Those who are to renew before |principal_type||The in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |_tagged_fields||The milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |results||The deletion results| |group_id||The group id| |error_code||The deletion milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |results||The deletion results| |group_id||The group id| |error_code||The for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |results||The deletion results| |group_id||The group id| |error_code||The deletion of a topic.| |partitions||The partitions of this topic whose leader should be elected.| |timeout_ms||The time in ms to wait for the election conduct for the partition. A value of '0' elects the preferred replica. A value of '1' elects the first live replica if there are no in-sync replica.| |topic_partitions||The topic partitions a topic.| |partitions||The partitions of this topic whose leader should be elected.| |timeout_ms||The time in ms to wait for the election conduct for the partition. A value of '0' elects the preferred replica. A value of '1' elects the first live replica if there are no in-sync replica.| |topic_partitions||The topic partitions a topic.| |partitions||The partitions of this whose leader should be elected.| |_tagged_fields||The tagged fields| |timeout_ms||The time in ms to wait for the election to complete.| |_tagged_fields||The for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |replica_election_results||The election results, or an empty array if the requester did not have permission and the request asks for all partitions.| |topic||The topic name| |partition_result||The results for each partition| |partition_id||The partition id| |error_code||The result error, or zero if there was no error.| |error_message||The result message, or null if there was for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The top level response error code.| |replica_election_results||The election results, or an empty array if the requester did not have permission and the request asks for all partitions.| |topic||The topic name| |partition_result||The results for each partition| |partition_id||The partition id| |error_code||The result error, or zero if there was no error.| |error_message||The result message, or null if there was for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The top level response error code.| |replica_election_results||The election results, or an empty array if the requester did not have permission and the request asks for all partitions.| |topic||The topic name| |partition_result||The results for each partition| |partition_id||The partition id| |error_code||The result error, or zero if there was no error.| |error_message||The result message, or null if there was no tagged (Set, Delete, Append, Subtract) of operation.| |value||The value to set for the configuration key.| |validate_only||True if we should validate the request, but not change the configurations.| Responses: (Set, Delete, Append, Subtract) of operation.| |value||The value to set for the configuration key.| |_tagged_fields||The tagged fields| |_tagged_fields||The tagged fields| |validate_only||True if we should validate the request, but not change the configurations.| |_tagged_fields||The for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |responses||The responses for each resource.| |error_code||The resource error code.| |error_message||The resource error message, or null if there was error.| |resource_type||The resource which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |responses||The responses for each resource.| |error_code||The resource error code.| |error_message||The resource error message, or null if there was no error.| |resource_type||The resource ms to wait for the request to complete.| |topics||The topics replicas to place the partitions on, or null to cancel a pending reassignment for this partition.| |_tagged_fields||The for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The top-level error code, or 0 if there was no error.| |error_message||The top-level error message, or null if there was no error.| |responses||The responses to topics to reassign.| partition index.| |error_code||The error code for this partition, or 0 if there was no error.| |error_message||The error message for this partition, or null if there was no error.| |_tagged_fields||The to wait for the request to complete.| |topics||The topics to list partition reassignments for, or null to list everything.| |name||The for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The top-level error code, or 0 if there was no error| |error_message||The top-level error message, or null if there was no error.| |topics||The ongoing reassignments for each partition.| |replicas||The current replica set.| |adding_replicas||The set of replicas we are currently adding.| |removing_replicas||The set of replicas we are currently offsets for| topic if there was no error.| |throttle_time_ms||The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||The responses for each topic.| |name||The topic name.| |partitions||The each partition in the topic.| |partition_index||The partition index.| |error_code||The error code, or 0 if was no error.| DescribeClientQuotas Request (Version: components to apply to quota entities.| |entity_type||The entity type that the filter component applies to.| |match_type||How to match the entity {0 = exact name, 1 = default name, 2 = any specified name}.| |match||The string to match against, or null if unused for the match type.| |strict||Whether the match is strict, i.e. should exclude entities with unspecified entity types.| Responses: DescribeClientQuotas components to apply to quota entities.| |entity_type||The entity type that the filter component applies to.| |match_type||How to match the entity {0 = exact name, 1 = default name, 2 = any specified name}.| |match||The string to match against, or null if unused for the match type.| |_tagged_fields||The tagged fields| |strict||Whether the match is strict, i.e. should exclude entities with unspecified entity types.| |_tagged_fields||The |Field ||Description | |throttle_time_ms||The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or `0` if the quota description succeeded.| |error_message||The error message, or `null` if the quota entity description.| |entity_type||The entity name, or null if the default.| |values||The quota values for the entity.| milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or `0` if the quota description succeeded.| |error_message||The error message, or `null` if the quota entity description.| |entity_type||The null if the default.| |_tagged_fields||The tagged fields| |values||The quota values for entity to alter.| |entity_type||The entity type.| |entity_name||The name of the entity, or null if the default.| |ops||An individual quota configuration entry to alter.| |key||The quota configuration key.| |value||The value to set, otherwise ignored if the value is to be removed.| |remove||Whether the quota configuration value should be removed, otherwise set.| |validate_only||Whether the alteration should be validated, but entity to alter.| |entity_type||The entity type.| |entity_name||The name of the entity, or null if the default.| |_tagged_fields||The tagged fields| |ops||An individual quota configuration entry to alter.| |key||The quota configuration key.| |value||The value to set, otherwise ignored if the value is to be removed.| |remove||Whether the quota configuration value should be removed, otherwise set.| |_tagged_fields||The tagged fields| |_tagged_fields||The tagged fields| |validate_only||Whether the milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |entries||The quota configuration entries to alter.| |error_code||The error code, or `0` if the quota alteration succeeded.| |error_message||The error message, or `null` if the quota alteration |entity||The quota entity to alter.| |entity_type||The entity type.| |entity_name||The name of the entity, or for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |entries||The quota configuration entries to alter.| |error_code||The error code, or `0` if the quota alteration succeeded.| |error_message||The error message, or `null` if the quota alteration |entity||The quota entity to alter.| |entity_type||The entity type.| |entity_name||The name of the entity, or the for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The message-level error code, 0 except for user authorization or infrastructure issues.| |error_message||The message-level error message, if any.| |results||The if for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |results||The results for deletions and alterations, one per affected user.| |user||The user name.| |error_code||The of the leader or -1 if the leader is unknown.| |leader_epoch||The latest known leader epoch| |high_watermark| |current_voters| |replica_id| |log_end_offset||The last known log end offset of the follower or -1 if it is unknown| of the leader or -1 if the leader is unknown.| |leader_epoch||The latest known leader epoch| |high_watermark| |current_voters| |replica_id| |log_end_offset||The last known log end offset of the follower or -1 if it is unknown| |last_fetch_timestamp||The last known leader wall clock time time when a follower fetched from the leader. This is reported as -1 both for the current leader or if it is unknown for a voter| |last_caught_up_timestamp||The leader wall clock append time of the offset for which the follower made the most recent fetch request. This is reported as the current time for the leader and -1 if unknown for a voter| epoch of the requesting broker| |topics| |topic_name||The for this partition. Deprecated since version 3.| |partition_epoch||The expected epoch of the partition which is being updated. For legacy cluster this is the ZkVersion in the LeaderAndIsr epoch of the requesting broker| |topics| |topic_name||The for this partition. Deprecated since version 3.| |leader_recovery_state||1 if the partition is recovering from an unclean leader election; 0 otherwise.| |partition_epoch||The expected epoch of the partition which is being updated. For legacy cluster this is the ZkVersion in the LeaderAndIsr epoch of the requesting broker| |topics| |topic_id||The for this partition. Deprecated since version 3.| |leader_recovery_state||1 if the partition is recovering from an unclean leader election; 0 otherwise.| |partition_epoch||The expected epoch of the partition which is being updated. For legacy cluster this is the ZkVersion in the LeaderAndIsr epoch of the requesting broker| |topics| |topic_id||The |broker_id||The ID of the broker.| |broker_epoch||The epoch of the broker. It will be -1 if the epoch check is not supported.| |_tagged_fields||The tagged fields| |leader_recovery_state||1 if the partition is recovering from an unclean leader election; 0 otherwise.| |partition_epoch||The expected epoch of the partition which is being updated. For legacy cluster this is the ZkVersion in the LeaderAndIsr for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The top level response error code| in-sync replica IDs.| |partition_epoch||The current epoch for the partition for KRaft controllers. The current ZK version for the legacy controllers.| for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The top level response error code| in-sync replica IDs.| |leader_recovery_state||1 if the partition is recovering from an unclean leader election; 0 otherwise.| |partition_epoch||The current epoch for the partition for KRaft controllers. The current ZK version for the legacy controllers.| for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The top level response error code| in-sync replica IDs.| |leader_recovery_state||1 if the partition is recovering from an unclean leader election; 0 otherwise.| |partition_epoch||The current epoch for the partition for KRaft controllers. The current ZK version for the legacy controllers.| for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The top level response error code| in-sync replica IDs.| |leader_recovery_state||1 if the partition is recovering from an unclean leader election; 0 otherwise.| |partition_epoch||The current epoch for the partition for KRaft controllers. The current ZK version for the legacy controllers.| in milliseconds before timing out the request.| |feature_updates||The list of updates to finalized features.| |feature||The name of the finalized feature to be updated.| |max_version_level||The new maximum version level for the finalized feature. A value >= 1 is valid. A value < 1, is special, and can be used to request the deletion of the finalized feature.| |allow_downgrade||DEPRECATED in version 1 (see DowngradeType). When set to true, the finalized feature version level is allowed to be downgraded/deleted. The downgrade request will fail if the new maximum version level is a value that's not lower than the existing maximum finalized version level.| |_tagged_fields||The tagged in milliseconds before timing out the request.| |feature_updates||The list of updates to finalized features.| |feature||The name of the finalized feature to be updated.| |max_version_level||The new maximum version level for the finalized feature. A value >= 1 is valid. A value < 1, is special, and can be used to request the deletion of the finalized feature.| |upgrade_type||Determine which type of upgrade will be performed: 1 will perform an upgrade only (default), 2 is safe downgrades only (lossless), 3 is unsafe downgrades (lossy).| |_tagged_fields||The tagged fields| |validate_only||True if we should validate the request, but not perform the upgrade or downgrade.| |_tagged_fields||The for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The top-level error code, or `0` if there top-level error.| |error_message||The top-level error or `null` if top-level error.| |results||Results for each feature update.| |feature||The name of the finalized feature.| |error_code||The feature update error code or `0` if the feature update succeeded.| |error_message||The feature update error, or `null` if the for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The top-level error code, or `0` if there top-level error.| |error_message||The top-level error or `null` if top-level error.| |results||Results for each feature update.| |feature||The name of the finalized feature.| |error_code||The feature update error code or `0` if the feature update succeeded.| |error_message||The feature update error, or `null` if the succeeded.| |_tagged_fields||The tagged and data.| |request_principal||Value of the initial client principal when the request is redirected by a broker.| |client_host_address||The original client's and data.| |error_code||The error code, or 0 if there was no for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The top-level error code, or 0 if there was no error| |error_message||The top-level error message, or null if there was no error.| |cluster_id||The cluster ID that responding broker belongs to.| |controller_id||The ID of the controller broker.| |brokers||Each |port||The broker port.| |rack||The rack of the broker, or null if it has not been assigned to a rack.| |_tagged_fields||The tagged fields| |cluster_authorized_operations||32-bit bitfield to for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |topics||Each topic in the response.| |name||The the response.| |partition_index||The partition index.| |error_code||The partition error code, or 0 if there was no error.| |error_message||The partition error message, which may be null if no additional details which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The error code, or 0 if there was no error.| |error_message||The top-level error message, or `null` to include in describe results. If empty, then no results will be returned.| |_tagged_fields||The for which the request was throttled due to a quota violation, or zero if the request did not violate included in the current transaction (if active). When a transaction is preparing to commit or abort, this will include only partitions which do not have by: if empty, all transactions are returned; if non-empty, then only transactions matching one of the filtered states will be returned| |producer_id_filters||The producerIds to filter by: if empty, all transactions will be returned; if non-empty, only transactions which match one of the filtered producerIds will be returned| for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code| |unknown_state_filters||Set of state filters provided in the request which were unknown to the transaction coordinator| |transaction_states| |transactional_id| |producer_id| |transaction_state||The for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The top level response error code| |producer_id_start||The first producer ID in this range, inclusive| |producer_id_len||The number of producer IDs member id generated by the coordinator. The member id must be kept during the entire lifetime of the member.| |member_epoch||The current member epoch; 0 to join the group; -1 to leave the group; -2 to indicate that the static member will rejoin.| |instance_id||null if not provided or if it didn't change since the last heartbeat; the instance Id otherwise.| |rack_id||null if not provided or if it didn't change since the last heartbeat; the rack ID of consumer otherwise.| |rebalance_timeout_ms||-1 if it didn't chance since the last heartbeat; the maximum time in milliseconds that the coordinator will wait on the member to revoke its partitions otherwise.| |subscribed_topic_names||null if it didn't change since the last heartbeat; the subscribed topic names otherwise.| |subscribed_topic_regex||null if it didn't change since the last heartbeat; the subscribed topic regex otherwise| |server_assignor||null if not used or if it didn't change since the last heartbeat; the server side assignor to use otherwise.| |client_assignors||null if not used or if it didn't change since the last heartbeat; the list of client-side assignors otherwise.| |name||The name of assignor.| |minimum_version||The minimum supported version for the metadata.| |maximum_version||The maximum supported version for the metadata.| |reason||The reason last heartbeat; for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.| |error_code||The top-level error code, or 0 if there was no error| |error_message||The top-level error message, or null if there was no error.| |member_id||The member id generated by the coordinator. Only provided when the member joins with MemberEpoch == 0.| |member_epoch||The member epoch.| |should_compute_assignment||True if the member should compute the assignment for the group.| |heartbeat_interval_ms||The heartbeat interval in milliseconds.| |assignment||null otherwise.| |error||The assigned error.| |assigned_topic_partitions||The partitions assigned to the assigned to the member that cannot be used because they are not released by their former owners yet.| |metadata_version||The version of the fields| |_tagged_fields||The tagged fields| Some people have asked why we don't use HTTP. There are a number of reasons, the best is that client implementors can make use of some of the more advanced TCP features--the ability to multiplex requests, the ability to simultaneously poll many connections, etc. We have also found HTTP libraries in many languages to be surprisingly shabby. Others have asked if maybe we shouldn't support many different protocols. Prior experience with this was that it makes it very hard to add and test new features if they have to be ported across many protocol implementations. Our feeling is that most users don't really see multiple protocols as a feature, they just want a good reliable client in the language of their choice. Another question is why we don't adopt XMPP, STOMP, AMQP or an existing protocol. The answer to this varies by protocol, but in general the problem is that the protocol does determine large parts of the implementation and we couldn't do what we are doing if we didn't have control over the protocol. Our belief is that it is possible to do better than existing messaging systems have in providing a truly distributed messaging system, and to do this we need to build something that works differently. A final question is why we don't use a system like Protocol Buffers or Thrift to define our request messages. These packages excel at helping you to managing lots and lots of serialized messages. However we have only a few messages. Support across languages is somewhat spotty (depending on the package). Finally the mapping between binary log format and wire protocol is something we manage somewhat carefully and this would not be possible with these systems. Finally we prefer the style of versioning APIs explicitly and checking this to inferring new values as nulls as it allows more nuanced control of compatibility. "}