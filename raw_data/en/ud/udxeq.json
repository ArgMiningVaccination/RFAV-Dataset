{"title": "Communication protocol - Wikipedia", "author": "Authority control National Czech Republic", "url": "https://en.wikipedia.org/wiki/Communication_protocol", "hostname": "wikipedia.org", "description": null, "sitename": "Wikimedia Foundation, Inc.", "date": "2001-11-30", "cleaned_text": "Communication protocol A communication protocol is a system of rules that allows two or more entities of a [communications system](/wiki/Communications_system) to transmit [information](/wiki/Information) via any variation of a [physical quantity](/wiki/Physical_quantity). The protocol defines the rules, [syntax](/wiki/Syntax), [semantics](/wiki/Semantics_(computer_science)), and [synchronization](/wiki/Synchronization) of [communication](/wiki/Communication) and possible [error recovery methods](/wiki/Error_detection_and_correction). Protocols may be implemented by [hardware](/wiki/Computer_hardware), [software](/wiki/Software), or a combination of both. [[1]](#cite_note-1) Communicating systems use well-defined formats for exchanging various messages. Each message has an exact meaning intended to elicit a response from a range of possible responses pre-determined for that particular situation. The specified behavior is typically independent of how it is to be [implemented](/wiki/Implementation). Communication protocols have to be agreed upon by the parties involved. [[2]](#cite_note-2) To reach an agreement, a protocol may be developed into a [technical standard](/wiki/Technical_standard). A [programming language](/wiki/Programming_language) describes the same for computations, so there is a close analogy between protocols and programming languages: protocols are to communication what programming languages are to computations. [[3]](#cite_note-AnalogyII-3) An alternate formulation states that protocols are to communication what [algorithms](/wiki/Algorithm) are to computation. [[4]](#cite_note-AnalogyI-4) Multiple protocols often describe different aspects of a single communication. A group of protocols designed to work together is known as a protocol suite; when implemented in software they are a [protocol stack](/wiki/Protocol_stack). Internet communication protocols are published by the [Internet Engineering Task Force](/wiki/Internet_Engineering_Task_Force) (IETF). The [IEEE](/wiki/IEEE) (Institute of Electrical and Electronics Engineers) handles wired and wireless networking and the [International Organization for Standardization](/wiki/International_Organization_for_Standardization) (ISO) handles other types. The [ITU-T](/wiki/ITU-T) handles [telecommunications](/wiki/Telecommunications) protocols and formats for the [public switched telephone network](/wiki/Public_switched_telephone_network) (PSTN). As the PSTN and Internet [converge](/wiki/Technological_convergence), the standards are also being driven towards convergence. Communicating systems[ [edit](/w/index.php?title=Communication_protocol&action=edit\u00a7ion=1)] History[ [edit](/w/index.php?title=Communication_protocol&action=edit\u00a7ion=2)] One of the first uses of the term protocol in a data-commutation context occurs in a memorandum entitled A Protocol for Use in the [NPL Data Communications Network](/wiki/NPL_Data_Communications_Network) written by [Roger Scantlebury](/wiki/Roger_Scantlebury) and Keith Bartlett in April 1967. [[5]](#cite_note-5) [[6]](#cite_note-6) On the [ARPANET](/wiki/ARPANET), the starting point for host-to-host communication in 1969 was the [1822 protocol](/wiki/BBN_Report_1822), which defined the transmission of messages to an IMP. [[7]](#cite_note-7) The [Network Control Protocol](/wiki/Network_Control_Protocol_(ARPANET)) (NCP) for the ARPANET was first implemented in 1970. [[8]](#cite_note-8) The NCP interface allowed [application software](/wiki/Application_software) to connect across the ARPANET by implementing higher-level communication protocols, an early example of the protocol layering concept. [[9]](#cite_note-LINCP-9) Networking research in the early 1970s by [Robert E. Kahn](/wiki/Robert_E._Kahn) and [Vint Cerf](/wiki/Vint_Cerf) led to the Control Program](/wiki/Transmission_Control_Program) (TCP). [[10]](#cite_note-10) Its [RFC](/wiki/RFC_(identifier)) [675](https://datatracker.ietf.org/doc/html/rfc675) specification was written by Cerf with [Yogen Dalal](/wiki/Yogen_Dalal) and Carl Sunshine in December 1974, still a monolithic design at this time. The [International Networking Working Group](/wiki/International_Networking_Working_Group) agreed on a connectionless [datagram](/wiki/Datagram) standard which was presented to the [CCITT](/wiki/ITU-T) in 1975 but was not adopted by the CCITT or by the ARPANET. [[11]](#cite_note-:0-11) International research, particularly the work of [R\u00e9mi Despr\u00e9s](/wiki/R%C3%A9mi_Despr%C3%A9s), contributed to the development of the [X.25](/wiki/X.25) standard, based on [virtual circuits](/wiki/Virtual_circuit) by the CCITT in 1976. [[12]](#cite_note-12) [proprietary protocols](/wiki/Proprietary_protocol) Network Systems](/wiki/Xerox_Network_Systems). [[14]](#cite_note-14) TCP software was redesigned as a modular protocol stack. Originally referred to as IP/TCP, it was installed on [SATNET](/wiki/SATNET) in 1982 and on the ARPANET in January 1983. The development of a complete protocol suite by 1989, as outlined in [RFC](/wiki/RFC_(identifier)) [1122](https://datatracker.ietf.org/doc/html/rfc1122) and [RFC](/wiki/RFC_(identifier)) [1123](https://datatracker.ietf.org/doc/html/rfc1123), laid the foundation for the growth of [TCP/IP](/wiki/TCP/IP) as a comprehensive protocol suite as the core component of the emerging [Internet](/wiki/Internet). [[15]](#cite_note-LITCPIP-15) International work on a reference model for communication standards led to the [OSI model](/wiki/OSI_model), published in 1984. For a period in the late 1980s and early 1990s, engineers, organizations and nations became [polarized over the issue of which standard](/wiki/Protocol_Wars), the OSI model or the Internet protocol suite, would result in the best and most robust computer networks. [[16]](#cite_note-ieee2017032-16) [[17]](#cite_note-17) [[18]](#cite_note-18) Concept[ [edit](/w/index.php?title=Communication_protocol&action=edit\u00a7ion=3)] The information exchanged between devices through a network or other media is governed by rules and conventions that can be set out in communication protocol specifications. The nature of communication, the actual data exchanged and any [state](/wiki/State_(computer_science))-dependent behaviors, is defined by these specifications. In digital computing systems, the rules can be expressed by [algorithms](/wiki/Algorithm) and [data structures](/wiki/Data_structure). Protocols are to communication what algorithms or programming languages are to computations. [[3]](#cite_note-AnalogyII-3) [[4]](#cite_note-AnalogyI-4) Operating systems usually contain a set of cooperating processes that manipulate shared data to communicate with each other. This communication is governed by well-understood protocols, which can be embedded in the process code itself. [[19]](#cite_note-Ben-Ari_p.18-19) [[20]](#cite_note-Ben-Ari_p.27-20) In contrast, because there is no [shared memory](/wiki/Shared_memory), communicating systems have to communicate with each other using a shared [transmission medium](/wiki/Transmission_medium). Transmission is not necessarily reliable, and individual systems may use different hardware or operating systems. To implement a networking protocol, the protocol software modules are interfaced with a framework implemented on the machine's operating system. This framework implements the networking functionality of the operating system. [[21]](#cite_note-Marsden_p.64-21) When protocol algorithms are expressed in a portable programming language the protocol software may be made [operating system](/wiki/Operating_system) independent. The best-known frameworks are the [TCP/IP model](/wiki/TCP/IP_model) and the [OSI model](/wiki/OSI_model). At the time the Internet was developed, [abstraction layering](/wiki/Abstraction_layer) had proven to be a successful design approach for both compiler and operating system design and, given the similarities between programming languages and communication protocols, the originally monolithic networking programs were decomposed into cooperating protocols. [[22]](#cite_note-22) This gave rise to the concept of layered protocols which nowadays forms the basis of protocol design. [[23]](#cite_note-Sect_p._192-23) Systems typically do not use a single protocol to handle a transmission. Instead they use a set of cooperating protocols, sometimes called a [protocol suite](/wiki/Protocol_suite). [[24]](#cite_note-Sect_p._177-24) Some of the [IPX/SPX](/wiki/IPX/SPX), [X.25](/wiki/X.25), [AX.25](/wiki/AX.25) and [AppleTalk](/wiki/AppleTalk). The protocols can be arranged based on functionality in groups, for instance, there is a group of [transport protocols](/wiki/Transport_protocol). The functionalities are mapped onto the layers, each layer solving a distinct class of problems relating to, for instance: application-, transport-, internet- and network interface-functions. [[25]](#cite_note-Sect_p._178-25) To transmit a message, a protocol has to be selected from each layer. The selection of the next protocol is accomplished by extending the message with a protocol selector for each layer. [[26]](#cite_note-26) Types[ [edit](/w/index.php?title=Communication_protocol&action=edit\u00a7ion=4)] There are two types of communication protocols, based on their representation of the content being carried: text-based and binary. [[27]](#cite_note-27) Text-based[ [edit](/w/index.php?title=Communication_protocol&action=edit\u00a7ion=5)] A text-based protocol or plain text protocol represents its content in [human-readable format](/wiki/Human-readable_medium), often in plain text. The immediate human readability stands in contrast to binary protocols which have inherent benefits for use in a computer environment (such as ease of mechanical [parsing](/wiki/Parsing) and [improved bandwidth utilization](/wiki/Lossless_compression)). Network applications have various methods of encapsulating data. One method very common with Internet protocols is a text oriented representation that transmits requests and responses as lines of [ASCII](/wiki/ASCII) text, terminated by a newline character (and usually a carriage return character). Examples of protocols that use plain, human-readable text for its commands are FTP ( [File Transfer [finger protocol](/wiki/Finger_protocol). [[28]](#cite_note-28) Text-based protocols are typically optimized for human parsing and interpretation and are therefore suitable whenever human inspection of protocol contents is required, such as during [debugging](/wiki/Debugging) and during early protocol development design phases. To be clear, all digital communication is fundamentally binary. The \"Text\" based protocols mentioned here use only binary content, which is made \"humanly readable\" by a text editor (or other such software). Binary[ [edit](/w/index.php?title=Communication_protocol&action=edit\u00a7ion=6)] A binary protocol utilizes all values of a [byte](/wiki/Byte), as opposed to a text-based protocol which only uses values corresponding to human-readable characters in [ASCII](/wiki/ASCII) encoding. Binary protocols are intended to be read by a machine rather than a human being. Binary protocols have the advantage of terseness, which translates into speed of transmission and interpretation. [[29]](#cite_note-29) Binary have been used in the normative documents describing modern standards like [EbXML](/wiki/EbXML), [HTTP/2](/wiki/HTTP/2), [HTTP/3](/wiki/HTTP/3) and [EDOC](/wiki/Enterprise_Distributed_Object_Computing). [[30]](#cite_note-30) An interface in UML [[31]](#cite_note-31) may also be considered a binary protocol. Basic requirements[ [edit](/w/index.php?title=Communication_protocol&action=edit\u00a7ion=7)] Getting the data across a network is only part of the problem for a protocol. The data received has to be evaluated in the context of the progress of the conversation, so a protocol must include rules describing the context. These kinds of rules are said to express the syntax of the communication. Other rules determine whether the data is meaningful for the context in which the exchange takes place. These kinds of rules are said to express the semantics of the communication. Messages are sent and received on communicating systems to establish communication. Protocols should therefore specify rules governing the transmission. In general, much of the following should be addressed: [[32]](#cite_note-32) - Data formats for data exchange - Digital message bitstrings are exchanged. The bitstrings are divided in fields and each field carries information relevant to the protocol. Conceptually the bitstring is divided into two parts called the header and the payload. The actual message is carried in the payload. The header area contains the fields with relevance to the operation of the protocol. Bitstrings longer than the [maximum transmission unit](/wiki/Maximum_transmission_unit)(MTU) are divided in pieces of appropriate size. [[33]](#cite_note-33) - Address formats for data exchange - Addresses are used to identify both the sender and the intended receiver(s). The addresses are carried in the header area of the bitstrings, allowing the receivers to determine whether the bitstrings are of interest and should be processed or should be ignored. A connection between a sender and a receiver can be identified using an address pair (sender address, receiver address). Usually, some address values have special meanings. An all-1s address could be taken to mean an addressing of all stations on the network, so sending to this address would result in a broadcast on the local network. The rules describing the meanings of the address value are collectively called an addressing scheme. [[34]](#cite_note-34) - Address mapping - Sometimes protocols need to map addresses of one scheme on addresses of another scheme. For instance, to translate a logical IP address specified by the application to an Ethernet MAC address. This is referred to as address mapping. [[35]](#cite_note-35) - Routing - When systems are not directly connected, intermediary systems along the route to the intended receiver(s) need to forward messages on behalf of the sender. On the Internet, the networks are connected using routers. The interconnection of networks through routers is called [internetworking](/wiki/Internetworking). - Detection of transmission errors - Error detection is necessary on networks where data corruption is possible. In a common approach, a CRC of the data area is added to the end of packets, making it possible for the receiver to detect differences caused by corruption. The receiver rejects the packets on CRC differences and arranges somehow for retransmission. [[36]](#cite_note-36) - Acknowledgements - Acknowledgement of correct reception of packets is required for [connection-oriented communication](/wiki/Connection-oriented_communication). Acknowledgments are sent from receivers back to their respective senders. [[37]](#cite_note-37) - Loss of information - timeouts and retries - Packets may be lost on the network or be delayed in transit. To cope with this, under some protocols, a sender may expect an acknowledgment of correct reception from the receiver within a certain amount of time. Thus, on [timeouts](/wiki/Timeout_(computing)), the sender may need to retransmit the information. [[a]](#cite_note-38)In case of a permanently broken link, the retransmission has no effect, so the number of retransmissions is limited. Exceeding the retry limit is considered an error. [[38]](#cite_note-39) - Direction of information flow - Direction needs to be addressed if transmissions can only occur in one direction at a time as on [half-duplex](/wiki/Half-duplex)links or from one sender at a time as on a [shared medium](/wiki/Shared_medium). This is known as [media access control](/wiki/Media_access_control). Arrangements have to be made to accommodate the case of [collision](/wiki/Collision_(telecommunications))or [contention](/wiki/Contention_(telecommunications))where two parties respectively simultaneously transmit or wish to transmit. [[39]](#cite_note-40) - Sequence control - If long bitstrings are divided into pieces and then sent on the network individually, the pieces may get lost or delayed or, on some types of networks, take different routes to their destination. As a result, pieces may arrive out of sequence. Retransmissions can result in duplicate pieces. By marking the pieces with sequence information at the sender, the receiver can determine what was lost or duplicated, ask for necessary retransmissions and reassemble the original message. [[40]](#cite_note-41) - Flow control - Flow control is needed when the sender transmits faster than the receiver or intermediate network equipment can process the transmissions. Flow control can be implemented by messaging from receiver to sender. [[41]](#cite_note-42) - Queueing - Communicating processes or state machines employ queues (or \"buffers\"), usually FIFO queues, to deal with the messages in the order sent, and may sometimes have multiple queues with different prioritization. Protocol design[ [edit](/w/index.php?title=Communication_protocol&action=edit\u00a7ion=8)] [Systems engineering](/wiki/Systems_engineering) principles have been applied to create a set of common network protocol design principles. The design of complex protocols often involves decomposition into simpler, cooperating protocols. Such a set of cooperating protocols is sometimes called a protocol family or a protocol suite, [[24]](#cite_note-Sect_p._177-24) within a conceptual framework. Communicating systems operate concurrently. An important aspect of [concurrent programming](/wiki/Concurrent_programming) is the synchronization of software for receiving and transmitting messages of communication in proper sequencing. Concurrent programming has traditionally been a topic in operating systems theory texts. [[42]](#cite_note-43) Formal verification seems indispensable because concurrent programs are notorious for the hidden and sophisticated bugs they contain. [[43]](#cite_note-44) A mathematical approach to the study of concurrency and communication is referred to as [communicating sequential processes](/wiki/Communicating_sequential_processes) (CSP). [[44]](#cite_note-45) Concurrency can also be state machines](/wiki/Finite_state_machine), such as [Mealy](/wiki/Mealy_machine) and [Moore machines](/wiki/Moore_machine). Mealy and Moore machines are in use as design tools in digital electronics systems encountered in the form of hardware used in telecommunication or electronic devices in general. [[45]](#cite_note-46)[ [better source needed](/wiki/Wikipedia:NOTRS)] The literature presents numerous analogies between computer communication and programming. In analogy, a transfer mechanism of a protocol is comparable to a central processing unit (CPU). The framework introduces rules that allow the programmer to design cooperating protocols independently of one another. Layering[ [edit](/w/index.php?title=Communication_protocol&action=edit\u00a7ion=9)] In modern protocol design, protocols are layered to form a protocol stack. Layering is a design principle that divides the protocol design task into smaller steps, each of which accomplishes a specific part, interacting with the other parts of the protocol only in a small number of well-defined ways. Layering allows the parts of a protocol to be designed and tested without a [combinatorial explosion](/wiki/Combinatorial_explosion) of cases, keeping each design relatively simple. The communication protocols in use on the [Internet](/wiki/Internet) are designed to function in diverse and complex settings. Internet protocols are designed for simplicity and modularity and fit into a coarse hierarchy of functional layers defined in the [Internet Protocol Suite](/wiki/Internet_Protocol_Suite). [[46]](#cite_note-Comer_decomposition-47) The first two cooperating protocols, the [Transmission Control Protocol](/wiki/Transmission_Control_Protocol) (TCP) and the [Internet Protocol](/wiki/Internet_Protocol) (IP) resulted from the decomposition of the original Transmission Control Program, a monolithic communication protocol, into this layered communication suite. The [OSI model](/wiki/OSI_model) was developed internationally based on experience with networks that predated the internet as a reference model for general communication with much stricter rules of protocol interaction and rigorous layering. Typically, application software is built upon a robust data transport layer. Underlying this transport layer is a datagram delivery and routing mechanism that is typically [connectionless](/wiki/Connectionless) in the Internet. Packet relaying across networks happens over another layer that involves only network link technologies, which are often specific to certain physical layer technologies, such as [Ethernet](/wiki/Ethernet). Layering provides opportunities to exchange technologies when needed, for example, protocols are often stacked in a [tunneling](/wiki/Tunneling_protocol) arrangement to accommodate the connection of dissimilar networks. For example, IP may be tunneled across an [Asynchronous Transfer Mode](/wiki/Asynchronous_Transfer_Mode) (ATM) network. Protocol layering[ [edit](/w/index.php?title=Communication_protocol&action=edit\u00a7ion=10)] Protocol layering forms the basis of protocol design. [[23]](#cite_note-Sect_p._192-23) It allows the decomposition of single, complex protocols into simpler, cooperating protocols. [[46]](#cite_note-Comer_decomposition-47) The protocol layers each solve a distinct class of communication problems. Together, the layers make up a layering scheme or model. Computations deal with algorithms and data; Communication involves protocols and messages; So the analog of a [data flow diagram](/wiki/Data_flow_diagram) is some kind of message flow diagram. [[4]](#cite_note-AnalogyI-4) To visualize protocol layering and protocol suites, a diagram of the message flows in and between two systems, A and B, is shown in figure 3. The systems, A and B, both make use of the same protocol suite. The vertical flows (and protocols) are in-system and the horizontal message flows (and protocols) are between systems. The message flows are governed by rules, and data formats specified by protocols. The blue lines mark the boundaries of the (horizontal) protocol layers. Software layering[ [edit](/w/index.php?title=Communication_protocol&action=edit\u00a7ion=11)] The software supporting protocols has a layered organization and its relationship with protocol layering is shown in figure 5. To send a message on system A, the top-layer software module interacts with the module directly below it and hands over the message to be encapsulated. The lower module fills in the header data in accordance with the protocol it implements and interacts with the bottom module which sends the message over the communications channel to the bottom module of system B. On the receiving system B the reverse happens, so ultimately the message gets delivered in its original form to the top module of system B. [[47]](#cite_note-48) [Program translation](/wiki/Program_translation) is divided into subproblems. As a result, the translation software is layered as well, allowing the software layers to be designed independently. The same approach can be seen in the TCP/IP layering. [[48]](#cite_note-Comer_p._178-49) The modules below the application layer are generally considered part of the operating system. Passing data between these modules is much less expensive than passing data between an application program and the transport layer. The boundary between the application layer and the transport layer is called the operating system boundary. [[49]](#cite_note-50) Strict layering[ [edit](/w/index.php?title=Communication_protocol&action=edit\u00a7ion=12)] Strictly adhering to a layered model, a practice known as strict layering, is not always the best approach to networking. [[50]](#cite_note-51) Strict layering can have a negative impact on the performance of an implementation. [[51]](#cite_note-52) While the use of protocol layering is today ubiquitous across the field of computer networking, it has been historically criticized by many researchers [[52]](#cite_note-53) as abstracting the protocol stack in this way may cause a higher layer to duplicate the functionality of a lower layer, a prime example being error recovery on both a per-link basis and an end-to-end basis. [[53]](#cite_note-54) Design patterns[ [edit](/w/index.php?title=Communication_protocol&action=edit\u00a7ion=13)] Commonly recurring problems in the design and implementation of communication protocols can be addressed by [software of describing communication syntax are [Abstract Syntax Notation One](/wiki/Abstract_Syntax_Notation_One) (an [ISO](/wiki/International_Organization_for_Standardization) (an [IETF](/wiki/IETF) standard). [Finite-state machine](/wiki/Finite-state_machine) models are used to formally describe the possible interactions of the protocol. [[59]](#cite_note-60) [[60]](#cite_note-61) and communicating finite-state machines [[61]](#cite_note-62) Protocol development[ [edit](/w/index.php?title=Communication_protocol&action=edit\u00a7ion=15)] For communication to occur, protocols have to be selected. The rules can be expressed by algorithms and data structures. Hardware and operating system independence is enhanced by expressing the algorithms in a portable programming language. Source independence of the specification provides wider interoperability. Protocol standards are commonly created by obtaining the approval or support of a [standards organization](/wiki/Standards_organization), which initiates the standardization process. The members of the standards organization agree to adhere to the work result on a voluntary basis. Often the members are in control of large market shares relevant to the protocol and in many cases, standards are enforced by law or the government because they are thought to serve an important public interest, so getting approval can be very important for the protocol. The need for protocol standards[ [edit](/w/index.php?title=Communication_protocol&action=edit\u00a7ion=16)] The need for protocol standards can be shown by looking at what happened to the [Binary Synchronous Communications](/wiki/Binary_Synchronous_Communications) (BSC) protocol invented by [IBM](/wiki/IBM). BSC is an early link-level protocol used to connect two separate nodes. It was originally not intended to be used in a multinode network, but doing so revealed several deficiencies of the protocol. In the absence of standardization, manufacturers and organizations felt free to enhance the protocol, creating incompatible versions on their networks. In some cases, this was deliberately done to discourage users from using equipment from other manufacturers. There are more than 50 variants of the original bi-sync protocol. One can assume, that a standard would have prevented at least some of this from happening. [[21]](#cite_note-Marsden_p.64-21) In some cases, protocols gain market dominance without going through a standardization process. Such protocols are referred to as [de facto standards](/wiki/De_facto_standard). De facto standards are common in emerging markets, niche markets, or markets that are [monopolized](/wiki/Monopoly) (or [oligopolized](/wiki/Oligopoly)). They can hold a market in a very negative grip, especially when used to scare away competition. From a historical perspective, standardization should be seen as a measure to counteract the ill-effects of de facto standards. Positive exceptions exist; a de facto standard operating system like Linux does not have this negative grip on its market, because the sources are published and maintained in an open way, thus inviting competition. Standards organizations[ [edit](/w/index.php?title=Communication_protocol&action=edit\u00a7ion=17)] Some of the [standards organizations](/wiki/Standards_organization) of relevance for communication protocols are the [International Organization for Standardization](/wiki/International_Organization_for_Standardization) (ISO), the [International Telecommunication Union](/wiki/International_Telecommunication_Union) (ITU), the [Institute of Electrical and Electronics Engineers](/wiki/Institute_of_Electrical_and_Electronics_Engineers) (IEEE), and the [Internet Engineering Task Force](/wiki/Internet_Engineering_Task_Force) (IETF). The IETF maintains the protocols in use on the Internet. The IEEE controls many software and hardware protocols in the electronics industry for commercial and consumer devices. The ITU is an umbrella organization of telecommunication engineers designing the [public switched telephone network](/wiki/Public_switched_telephone_network) (PSTN), as well as many [radio](/wiki/Radio) communication systems. For [marine electronics](/wiki/Marine_electronics) the [NMEA](/wiki/National_Marine_Electronics_Association) standards are used. The [World Wide Web Consortium](/wiki/World_Wide_Web_Consortium) (W3C) produces protocols and standards for Web technologies. International standards organizations are supposed to be more impartial than local organizations with a national or commercial self-interest to consider. Standards organizations also do research and development for standards of the future. In practice, the standards organizations mentioned, cooperate closely with each other. [[62]](#cite_note-63) Multiple standards bodies may be involved in the development of a protocol. If they are uncoordinated, then the result may be multiple, incompatible definitions of a protocol, or multiple, incompatible interpretations of messages; important invariants in one definition (e.g., that [time-to-live](/wiki/Time-to-live) values are [monotone decreasing](/wiki/Monotone_decreasing) to prevent stable [routing loops](/wiki/Routing_loops)) may not be respected in another. [[63]](#cite_note-FOOTNOTEBryantMorrow20094-64) The standardization process[ [edit](/w/index.php?title=Communication_protocol&action=edit\u00a7ion=18)] In the ISO, the standardization process starts off with the commissioning of a sub-committee workgroup. The workgroup issues working drafts and discussion documents to interested parties (including other standards bodies) in order to provoke discussion and comments. This will generate a lot of questions, much discussion and usually some disagreement. These comments are taken into account and a draft proposal is produced by the working group. After feedback, modification, and compromise the proposal reaches the status of a draft international standard, and ultimately an international standard. International standards are reissued periodically to handle the deficiencies and reflect changing views on the subject. [[64]](#cite_note-65) OSI standardization[ [edit](/w/index.php?title=Communication_protocol&action=edit\u00a7ion=19)] by A lesson learned from [ARPANET](/wiki/ARPANET), the predecessor of the Internet, was that protocols need a framework to operate. It is therefore important to develop a general-purpose, future-proof framework suitable for structured protocols (such as layered protocols) and their standardization. This would prevent protocol standards with overlapping functionality and would allow clear definition of the responsibilities of a protocol at the different levels (layers). [[66]](#cite_note-67) This gave rise to the [Open Systems Interconnection model](/wiki/Open_Systems_Interconnection_model) (OSI model), which is used as a framework for the design of standard protocols and services conforming to the various layer specifications. [[67]](#cite_note-68) In the OSI model, communicating systems are assumed to be connected by an underlying physical medium providing a basic transmission mechanism. The layers above it are numbered. Each layer provides service to the layer above it using the services of the layer immediately below it. The top layer provides services to the application process. The layers communicate with each other by means of an interface, called a service access point. Corresponding layers at each system are called peer entities. To communicate, two peer entities at a given layer use a protocol specific to that layer which is implemented by using services of the layer below. [[68]](#cite_note-69) For each layer, there are two types of standards: protocol standards defining how peer entities at a given layer communicate, and service standards defining how a given layer communicates with the layer above it. In the OSI model, the layers and their functionality are (from highest to lowest layer): - The [Application layer](/wiki/Application_layer)may provide the following services to the application processes: identification of the intended communication partners, establishment of the necessary authority to communicate, determination of availability and authentication of the partners, agreement on privacy mechanisms for the communication, agreement on responsibility for error recovery and procedures for ensuring data integrity, synchronization between cooperating application processes, identification of any constraints on syntax (e.g. character sets and data structures), determination of cost and acceptable quality of service, selection of the dialogue discipline, including required logon and logoff procedures. [[69]](#cite_note-70) - The [presentation layer](/wiki/Presentation_layer)may provide the following services to the application layer: a request for the establishment of a session, data transfer, negotiation of the syntax to be used between the application layers, any necessary syntax transformations, formatting and special purpose transformations (e.g., data compression and data encryption). [[70]](#cite_note-71) - The [session layer](/wiki/Session_layer)may provide the following services to the presentation layer: establishment and release of session connections, normal and expedited data exchange, a quarantine service which allows the sending presentation entity to instruct the receiving session entity not to release data to its presentation entity without permission, interaction management so presentation entities can control whose turn it is to perform certain control functions, resynchronization of a session connection, reporting of unrecoverable exceptions to the presentation entity. [[71]](#cite_note-72) - The [transport layer](/wiki/Transport_layer)provides reliable and transparent data transfer in a cost-effective way as required by the selected quality of service. It may support the multiplexing of several transport connections on to one network connection or split one transport connection into several network connections. [[72]](#cite_note-73) - The [network layer](/wiki/Network_layer)does the setup, maintenance and release of network paths between transport peer entities. When relays are needed, routing and relay functions are provided by this layer. The quality of service is negotiated between network and transport entities at the time the connection is set up. This layer is also responsible for [network congestion](/wiki/Network_congestion)control. [[73]](#cite_note-74) - The [data link layer](/wiki/Data_link_layer)does the setup, maintenance and release of data link connections. Errors occurring in the physical layer are detected and may be corrected. Errors are reported to the network layer. The exchange of data link units (including flow control) is defined by this layer. [[74]](#cite_note-75) - The [physical layer](/wiki/Physical_layer)describes details like the electrical characteristics of the physical connection, the transmission techniques used, and the setup, maintenance and clearing of physical connections. [[75]](#cite_note-76) In contrast to the [TCP/IP layering scheme](#Software_layering), which assumes a connectionless network, RM/OSI assumed a connection-oriented network. [[76]](#cite_note-77) Connection-oriented networks are more suitable for wide area networks and connectionless networks are more suitable for local area networks. Connection-oriented communication requires some form of session and (virtual) circuits, hence the (in the TCP/IP model lacking) session layer. The constituent members of ISO were mostly concerned with wide area networks, so the development of RM/OSI concentrated on connection-oriented networks and connectionless networks were first mentioned in an addendum to RM/OSI [[77]](#cite_note-78) [[78]](#cite_note-79) and later incorporated into an to RM/OSI. [[79]](#cite_note-80) At the time,[ [when?](/wiki/Wikipedia:Manual_of_Style/Dates_and_numbers#Chronological_items)] the IETF had to cope with this and the fact that the Internet needed protocols that simply were not there.[ [citation needed](/wiki/Wikipedia:Citation_needed)] As a result, the IETF developed its own standardization process based on \"rough consensus and running code\". [[80]](#cite_note-81) The standardization process is described by [RFC](/wiki/RFC_(identifier)) [2026](https://datatracker.ietf.org/doc/html/rfc2026). Nowadays, the IETF has become a standards organization for the protocols in use on the Internet. RM/OSI has extended its model to include connectionless services and because of this, both TCP and IP could be developed into international standards.[ [citation needed](/wiki/Wikipedia:Citation_needed)] Wire image[ [edit](/w/index.php?title=Communication_protocol&action=edit\u00a7ion=20)] The wire image of a protocol is the information that a non-participant observer is able to glean from observing the protocol messages, including both information explicitly given meaning by the protocol, but also inferences made by the observer. [[81]](#cite_note-FOOTNOTETrammellKuehlewind20192-82) Unencrypted protocol metadata is one source making up the wire image, and [side-channels](/wiki/Side-channel_attack) including packet timing also contribute. [[82]](#cite_note-FOOTNOTETrammellKuehlewind20193-83) Different observers with different vantages may see different wire images. [[83]](#cite_note-FOOTNOTETrammellKuehlewind20194-84) The wire image is relevant to end-user [privacy](/wiki/Internet_privacy) and the [extensibility](/wiki/Extensibility) of the protocol. [[84]](#cite_note-FOOTNOTEFairhurstPerkins20217._Conclusions-85) If some portion of the wire image is not cryptographically [authenticated](/wiki/Authenticated), it is subject to modification by intermediate parties (i.e., [middleboxes](/wiki/Middleboxes)), which can influence protocol operation. [[82]](#cite_note-FOOTNOTETrammellKuehlewind20193-83) Even if authenticated, if a portion is not encrypted, it will form part of the wire image, and intermediate parties may intervene depending on its content (e.g., dropping packets with particular flags). Signals deliberately intended for intermediary consumption may be left authenticated but unencrypted. [[85]](#cite_note-FOOTNOTETrammellKuehlewind20195-86) The wire image can be deliberately engineered, encrypting parts that intermediaries should not be able to observe and providing signals for what they should be able to. [[86]](#cite_note-FOOTNOTETrammellKuehlewind20196-87) If provided signals are decoupled from the protocol's operation, they may become untrustworthy. [[87]](#cite_note-FOOTNOTETrammellKuehlewind20197-8-88) Benign network management and research are affected by metadata encryption; protocol designers must balance observability for operability and research against ossification resistance and end-user privacy. [[84]](#cite_note-FOOTNOTEFairhurstPerkins20217._Conclusions-85) The IETF announced in 2014 that it had determined that large-scale surveillance of protocol operations is an attack due to the ability to infer information from the wire image about users and their behaviour, [[88]](#cite_note-FOOTNOTEFarrellTschofenig20142-89) and that the IETF would \"work to mitigate pervasive monitoring\" in its protocol designs; [[89]](#cite_note-FOOTNOTEFarrellTschofenig20143-90) this had not been done systematically previously. [[89]](#cite_note-FOOTNOTEFarrellTschofenig20143-90) The [Internet Architecture Board](/wiki/Internet_Architecture_Board) recommended in 2023 that disclosure of information by a protocol to the network should be intentional, [[90]](#cite_note-FOOTNOTEArkkoHardiePaulyK\u00fchlewind20232.1._Intentional_Distribution-91) performed with the agreement of both recipient and sender, [[91]](#cite_note-FOOTNOTEArkkoHardiePaulyK\u00fchlewind20232.2._Control_of_the_Distribution_of_Information-92) authenticated to the degree possible and necessary, [[92]](#cite_note-FOOTNOTEArkkoHardiePaulyK\u00fchlewind20232.3._Protecting_Information_and_Authentication-93) only acted upon to the degree of its trustworthiness, [[93]](#cite_note-FOOTNOTEArkkoHardiePaulyK\u00fchlewind20232.5._Limiting_Impact_of_Information-94) and minimised and provided to a minimum number of entities. [[94]](#cite_note-FOOTNOTEArkkoHardiePaulyK\u00fchlewind20232.4._Minimize_Information-95) [[95]](#cite_note-FOOTNOTEArkkoHardiePaulyK\u00fchlewind20232.6._Minimum_Set_of_Entities-96) Engineering the wire image and controlling what signals are provided to network elements was a \"developing field\" in 2023, according to the IAB. [[96]](#cite_note-FOOTNOTEArkkoHardiePaulyK\u00fchlewind20233._Further_Work-97) Ossification[ [edit](/w/index.php?title=Communication_protocol&action=edit\u00a7ion=21)] [Protocol ossification](/wiki/Protocol_ossification) is and evolvability of [network protocols](/wiki/Network_protocols). This is largely due to [middleboxes](/wiki/Middlebox) that are sensitive to the wire image of the protocol, and which can interrupt or interfere with messages that are valid but which the middlebox does not correctly recognize. [[97]](#cite_note-FOOTNOTEPapastergiouFairhurstRosBrunstrom2017619-98) This is a violation of the [end-to-end principle](/wiki/End-to-end_principle). [[98]](#cite_note-FOOTNOTEPapastergiouFairhurstRosBrunstrom2017620-99) Secondary causes include inflexibility in endpoint implementations of protocols. [[99]](#cite_note-FOOTNOTEPapastergiouFairhurstRosBrunstrom2017620-621-100) Ossification is a major issue in [Internet](/wiki/Internet) protocol design and deployment, as it can prevent new protocols or extensions from being deployed on the Internet, or place strictures on the design of new protocols; new protocols may have to be [encapsulated](/wiki/Encapsulation_(networking)) in an already-deployed protocol or mimic the wire image of another protocol. [[100]](#cite_note-FOOTNOTEPapastergiouFairhurstRosBrunstrom2017623-4-101) Because of ossification, the [Transmission Control Protocol](/wiki/Transmission_Control_Protocol) (TCP) and [User Datagram for [transport protocols](/wiki/Transport_protocol) on the Internet, [[101]](#cite_note-FOOTNOTEMcQuistinPerkinsFayed20161-102) and TCP itself has significantly ossified, making extension or modification of the protocol difficult. [[102]](#cite_note-FOOTNOTEThomsonPauly2021A.5._TCP-103) Recommended methods of preventing ossification include [encrypting](/wiki/Encryption) protocol metadata, [[103]](#cite_note-FOOTNOTEHardie20197-8-104) and ensuring that extension points are exercised and wire image variability is exhibited as fully as possible; [[104]](#cite_note-FOOTNOTEThomsonPauly20213._Active_Use-105) remedying existing ossification requires coordination across protocol participants. [[105]](#cite_note-FOOTNOTEThomsonPauly20213.5._Restoring_Active_Use-106) [QUIC](/wiki/QUIC) is the first [IETF](/wiki/IETF) transport protocol to have been designed with deliberate anti-ossification properties. [[81]](#cite_note-FOOTNOTETrammellKuehlewind20192-82) Taxonomies[ [edit](/w/index.php?title=Communication_protocol&action=edit\u00a7ion=22)] Classification schemes for protocols usually focus on the domain of use and function. As an example of domain of use, [connection-oriented protocols](/wiki/Connection-oriented_protocol) and [connectionless protocols](/wiki/Connectionless_protocol) are used on connection-oriented networks and connectionless networks respectively. An example of function is a [tunneling protocol](/wiki/Tunneling_protocol), which is used to encapsulate packets in a high-level protocol so that the packets can be passed across a transport system using the high-level protocol. A [layering scheme](#Protocol_layering) combines both function and domain of use. The dominant layering schemes are the ones developed by the IETF and by ISO. Despite the fact that the underlying assumptions of the layering schemes are different enough to warrant distinguishing the two, it is a common practice to compare the two by relating common protocols to the layers of the two schemes. [[106]](#cite_note-107) The layering scheme from the IETF is called Internet layering or TCP/IP layering. The layering scheme from ISO is called the OSI model or ISO layering. In networking equipment configuration, a term-of-art distinction is often drawn: The term protocol strictly refers to the transport layer, and the term service refers to protocols utilizing a protocol for transport. In the common case of TCP and UDP, services are distinguished by port numbers. Conformance to these port numbers is voluntary, so in content inspection systems the term service strictly refers to port numbers, and the term application is often used to refer to protocols identified through inspection signatures. See also[ [edit](/w/index.php?title=Communication_protocol&action=edit\u00a7ion=23)] [Lists of network protocols](/wiki/Lists_of_network_protocols) [Protocol Builder](/wiki/Protocol_Builder)- build network connectivity components Notes[ [edit](/w/index.php?title=Communication_protocol&action=edit\u00a7ion=24)] [^](#cite_ref-38)Failure to receive an acknowledgment indicates that either the original transmission or the acknowledgment was lost. The sender has no means to distinguish these cases and therefore, to ensure all data is received, must make the conservative assumption that the original transmission was lost. References[ [edit](/w/index.php?title=Communication_protocol&action=edit\u00a7ion=25)] original on 12 September 2012, retrieved 24 September 2012 - ^ [a](#cite_ref-AnalogyII_3-0) [b](#cite_ref-AnalogyII_3-1)Comer 2000, Sect. 11.2 - The Need For Multiple Protocols, p. 177, \"They (protocols) are to communication what programming languages are to computation\" - ^ [a](#cite_ref-AnalogyI_4-0) [b](#cite_ref-AnalogyI_4-1) [c](#cite_ref-AnalogyI_4-2)Comer 2000, Sect. 1.3 - Internet Services, p. 3, \"Protocols are to communication what algorithms are to computation\" [^](#cite_ref-5)Naughton, John (24 September 2015). [A Brief History Future](https://books.google.com/books?id=bbonCgAAQBAJ&pg=PT290). Orion. [ISBN](/wiki/ISBN_(identifier)) [978-1-4746-0277-8](/wiki/Special:BookSources/978-1-4746-0277-8). [^](#cite_ref-6)Cambell-Kelly, Martin (1987). [\"Data Communications at the National Physical Laboratory (1965-1975)\"](https://archive.org/details/DataCommunicationsAtTheNationalPhysicalLaboratory). Annals of the History of Host and an IMP](http://www.bitsavers.org/pdf/bbn/imp/BBN1822_Jan1976.pdf)(PDF) (Report). [Bolt Beranek By HD](https://books.google.com/books?id=dRRDDwAAQBAJ&pg=PA319). High Definition Books. [^](#cite_ref-LINCP_9-0) [\"NCP - Network Control Program\"](https://livinginternet.com/i/ii_ncp.htm). Living Internet. [Archived](https://web.archive.org/web/20220807153805/https://livinginternet.com/i/ii_ncp.htm)from the original on 7 August 2022. Retrieved 8 October 2022. [^](#cite_ref-10)Cerf, V.; Kahn, R. (1974). [\"A Protocol for Packet [Archived](https://web.archive.org/web/20170106204542/http://www.cs.princeton.edu/courses/archive/fall06/cos561/papers/cerf74.pdf)(PDF) from the original on 6 January 2017. Retrieved 23 February 2020. The authors wish to thank a number of colleagues for helpful comments during early discussions of international network protocols, especially R. Metcalfe, R. Scantlebury, D. Walden, and H. Zimmerman; D. Davies and L. Pouzin who constructively commented on the fragmentation and accounting issues; and S. Crocker who commented on the creation and destruction of associations. [^](#cite_ref-:0_11-0)McKenzie, Alexander (2011). \"INWG and the Conception of the Internet: An Eyewitness Account\". IEEE Annals of the - Pre-Internet Data Networking [History A Canadian perspective [History [978-1-4669-3935-6](/wiki/Special:BookSources/978-1-4669-3935-6). [^](#cite_ref-LITCPIP_15-0) [\"TCP/IP Internet Living Internet. [Archived](https://web.archive.org/web/20220901071957/https://livinginternet.com/i/ii_tcpip.htm)from the on 1 September 2022. Retrieved 8 October 2022. [^](#cite_ref-ieee2017032_16-0)Andrew L. Russell (30 July 2013). [\"OSI: The Internet That Wasn't\"](https://spectrum.ieee.org/computing/networks/osi-the-internet-that-wasnt). [IEEE Spectrum](/wiki/IEEE_Spectrum). Vol. 50, no. 8. [^](#cite_ref-17)Russell, Andrew L. [\"Rough Consensus and Running Code' and the Internet-OSI Standards War\"](https://www2.cs.duke.edu/courses/common/compsci092/papers/govern/consensus.pdf)(PDF). IEEE Annals of the History of Computing. [Archived](https://web.archive.org/web/20191117080112/https://www2.cs.duke.edu/courses/common/compsci092/papers/govern/consensus.pdf)(PDF) from the original on 17 November 2019. Retrieved 23 February 2020. [^](#cite_ref-18) [\"Standards Wars\"](https://courses.cs.washington.edu/courses/csep590a/06au/projects/standards-wars.pdf)(PDF). 2006. [Archived](https://web.archive.org/web/20210224162416/https://courses.cs.washington.edu/courses/csep590a/06au/projects/standards-wars.pdf)(PDF) from the original on 24 February 2021. Retrieved 23 February 2020. [^](#cite_ref-Ben-Ari_p.18_19-0)Ben-Ari 1982, chapter 2 - The concurrent programming abstraction, p. 18-19, states the same. [^](#cite_ref-Ben-Ari_p.27_20-0)Ben-Ari 1982, Section 2.7 - Summary, p. 27, summarizes the concurrent programming abstraction. - ^ [a](#cite_ref-Marsden_p.64_21-0) [b](#cite_ref-Marsden_p.64_21-1)Marsden 1986, Section 6.1 - Why are standards necessary?, p. 64-65, uses BSC as an example to show the need for both standard protocols and a standard framework. [^](#cite_ref-22)Comer 2000, Sect. 11.2 - The Need For Multiple Protocols, p. 177, explains this by drawing analogies between computer communication and programming languages. - ^ [a](#cite_ref-Sect_p._192_23-0) [b](#cite_ref-Sect_p._192_23-1)Sect. 11.10 - The Disadvantage Of Layering, p. 192, states: layering forms the basis for protocol design. - ^ [a](#cite_ref-Sect_p._177_24-0) [b](#cite_ref-Sect_p._177_24-1)Comer 2000, Sect. 11.2 - The Need For Multiple Protocols, p. 177, states the same. [^](#cite_ref-Sect_p._178_25-0)Comer 2000, Sect. 11.3 - The Conceptual Layers Of Protocol Software, p. 178, \"Each layer takes responsibility for handling one part of the problem.\" [^](#cite_ref-26)Comer 2000, Sect. 11.11 - The Basic Idea Behind Multiplexing And Demultiplexing, p. 192, states the same. [^](#cite_ref-27) [\"Data Communication - an overview | ScienceDirect Topics\"](https://www.sciencedirect.com/topics/computer-science/data-communication). www.sciencedirect.com. [Archived](https://web.archive.org/web/20220531132703/https://www.sciencedirect.com/topics/computer-science/data-communication)from the original on 31 May 2022. 31 May 2022. [^](#cite_ref-28)Kirch, Olaf Based Protocols\"](https://web.archive.org/web/20100530140215/http://www.lst.de/~okir/blackhats/node76.html). Archived from [the original](http://www.lst.de/~okir/blackhats/node76.html)on 30 May 2010. Retrieved 21 October 2014. [^](#cite_ref-29)Kirch, Olaf (16 January 2002). [\"Binary Representation Protocols\"](https://web.archive.org/web/20100530225453/http://www.lst.de/~okir/blackhats/node77.html). Archived from [the original](http://www.lst.de/~okir/blackhats/node77.html)on 30 May 2010. Retrieved 4 May 2006. [^](#cite_ref-30)Kirch, Olaf (16 January 2002). [\"Binary Representation Protocols\"](https://web.archive.org/web/20060305095832/http://www.omg.org/technology/documents/formal/edoc.htm). Archived from [the original](http://www.omg.org/technology/documents/formal/edoc.htm)on 5 March 2006. [^](#cite_ref-31) [\"Welcome To UML Web Site!\"](https://www.uml.org/). Uml.org. [Archived](https://web.archive.org/web/20190930184152/https://www.uml.org/)from the original on 30 September 2019. Retrieved 15 January 2017. [^](#cite_ref-32)Marsden 1986, Chapter 3 - Fundamental protocol concepts and problem areas, p. 26-42, explains much of the following. [^](#cite_ref-33)Comer 2000, Sect. 7.7.4 - Datagram Size, Network MTU, and Fragmentation, p. 104, Explains fragmentation and the effect on the header of the fragments. [^](#cite_ref-34)Comer 2000, Chapter 4 - Classful Internet Addresses, p. 64-67;71. [^](#cite_ref-35)Marsden 1986, Section 14.3 - Layering concepts and general definitions, p. 187, explains address mapping. [^](#cite_ref-36)Marsden 1986, Section 3.2 - Detection and transmission errors, p. 27, explains the advantages of backward error correction. [^](#cite_ref-37)Marsden 1986, Section 3.3 - Acknowledgement, p. 28-33, explains the advantages of positive only acknowledgment and mentions datagram protocols as exceptions. [^](#cite_ref-39)Marsden 1986, Section 3.4 - Loss of information - timeouts and retries, p. 33-34. [^](#cite_ref-40)Marsden 1986, Section 3.5 - Direction of information flow, p. 34-35, explains master/slave and the negotiations to gain control. [^](#cite_ref-41)Marsden 1986, Section 3.6 - Sequence control, p. 35-36, explains how packets get lost and how sequencing solves this. [^](#cite_ref-42)Marsden 1986, Section 3.7 - Flow control, p. 36-38. [^](#cite_ref-43)Ben-Ari 1982, in his preface, p. xiii. [^](#cite_ref-44)Ben-Ari 1982, in his preface, p. xiv. [^](#cite_ref-45)Hoare 1985, Chapter 4 - Communication, p. 133, deals with communication. [^](#cite_ref-46)S. Srinivasan, [Digital Circuits and Systems](https://web.archive.org/web/20091227210642/http://nptel.iitm.ac.in/video.php?courseId=1005&p=3), NPTEL courses, 27 December 2009 - ^ [a](#cite_ref-Comer_decomposition_47-0) [b](#cite_ref-Comer_decomposition_47-1)Comer 2000, Sect. 11.2 - The Need For Multiple Protocols, p. 177, introduces the decomposition in layers. [^](#cite_ref-48)Comer 2000, Sect. 11.3 - The Conceptual Layers Of Protocol Software, p. 179, the first two paragraphs describe the sending of a message through successive layers. [^](#cite_ref-Comer_p._178_49-0)Comer 2000, Sect. 11.2 - The need for multiple protocols, p. 178, explains similarities protocol software and compiler, assembler, linker, loader. [^](#cite_ref-50)Comer 2000, Sect. 11.9.1 - Operating System Boundary, p. 192, describes the operating system boundary. [^](#cite_ref-51)IETF 1989, Sect 1.3.1 - Organization, p. 15, 2nd paragraph: many design choices involve creative \"breaking\" of strict layering. [^](#cite_ref-52)Comer 2000, Sect. 11.10 - The Disadvantage Of Layering, p. 192, explains why \"strict layering can be extremely inefficient\" giving examples of optimizations. [^](#cite_ref-55)Lascano, Jorge Edison; 17 March 2017. [^](#cite_ref-56)Lascano, J. E.; Clyde, S. (2016). A Pattern Language for Application-level Communication Protocols. ICSEA 2016, The Eleventh International Conference on Software Engineering Advances. pp. 22-30. [^](#cite_ref-57)Daigneau, R. (2011). Service Design Patterns: Fundamental Design Solutions for SOAP/WSDL and RESTful Web Services (1 ed.). Upper Saddle River, NJ: Addison-Wesley Professional. [^](#cite_ref-58) [Fowler, M.](/wiki/Martin_Fowler_(software_engineer))(2002). Patterns of Professional. [ISBN](/wiki/ISBN_(identifier)) [0-321-12742-0](/wiki/Special:BookSources/0-321-12742-0). [^](#cite_ref-59)[1]F. Buschmann, K. Henney, and D. C. Schmidt, Pattern-Oriented Software Architecture Volume 4: A Pattern Language for Distributed Computing, Volume 4 edition. Chichester England; New York: Wiley, 2007. [^](#cite_ref-60)Bochmann, G. (1978). \"Finite state [S2CID](/wiki/S2CID_(identifier)) [11607967](https://api.semanticscholar.org/CorpusID:11607967). [^](#cite_ref-63)Marsden 1986, Section 6.3 - Advantages of standardization, p. 66-67, states the same. [^](#cite_ref-FOOTNOTEBryantMorrow20094_64-0) [Bryant & Morrow 2009](#CITEREFBryantMorrow2009), p. 4. [^](#cite_ref-65)Marsden 1986, Section 6.4 - Some problems with standardisation, p. 67, follows HDLC to illustrate the process. [^](#cite_ref-66) [\"X.225 : Information technology - Open Systems Interconnection - Connection-oriented Session protocol: Protocol specification\"](https://www.itu.int/rec/T-REC-X.225-199511-I/en). [Archived](https://web.archive.org/web/20210201064044/https://www.itu.int/rec/T-REC-X.225-199511-I/en)from the original on 1 February 2021. Retrieved 10 March 2023. [^](#cite_ref-67)Marsden 1986, Section 6.1 - Why are standards necessary?, p. 65, explains lessons learned from ARPANET. [^](#cite_ref-68)Marsden 1986, Section 14.1 - Introduction, p. 181, introduces OSI. [^](#cite_ref-69)Marsden 1986, Section 14.3 - Layering concepts and general definitions, p. 183-185, explains terminology. [^](#cite_ref-70)Marsden 1986, Section 14.4 - The application layer, p. 188, explains this. [^](#cite_ref-71)Marsden 1986, Section 14.5 - The presentation layer, p. 189, explains this. [^](#cite_ref-72)Marsden 1986, Section 14.6 - The session layer, p. 190, explains this. [^](#cite_ref-73)Marsden 1986, Section 14.7 - The transport layer, p. 191, explains this. [^](#cite_ref-74)Marsden 1986, Section 14.8 - The network layer, p. 192, explains this. [^](#cite_ref-75)Marsden 1986, Section 14.9 - The data link layer, p. 194, explains this. [^](#cite_ref-76)Marsden 1986, Section 14.10 - The physical layer, p. 195, explains this. [^](#cite_ref-77) [ISO 7498:1984 - Information processing systems - Open Systems Interconnection - Basic Reference Model](https://www.iso.org/standard/14252.html). p. 5. This Basic Reference Model of Open Systems Interconnection is based on the assumption that a connection is required for the transfer of data. [^](#cite_ref-78) [ISO 7498:1984/ADD 1:1987 - Information processing systems \u2014 Open Systems Interconnection \u2014 Basic Reference Model \u2014 Addendum 1](https://www.iso.org/standard/14253.html). [^](#cite_ref-79)Marsden 1986, Section 14.11 - Connectionless mode and RM/OSI, p. 195, mentions this. [^](#cite_ref-80) [ISO 7498:1994 - Information processing systems - Open Systems Interconnection - Basic Reference Model](https://www.iso.org/standard/20269.html). [^](#cite_ref-81)Comer 2000, Section 1.9 - Internet Protocols And Standardization, p. 12, explains why the IETF did not use existing protocols. - ^ [a](#cite_ref-FOOTNOTETrammellKuehlewind20192_82-0) [b](#cite_ref-FOOTNOTETrammellKuehlewind20192_82-1) [Trammell & Kuehlewind p. 2.1. Intentional Distribution. [^](#cite_ref-FOOTNOTEArkkoHardiePaulyK\u00fchlewind20232.2._Control_of_the_Distribution_of_Information_92-0) [Arkko et al. 2023](#CITEREFArkkoHardiePaulyK\u00fchlewind2023), 2.2. Control of the Distribution of Information. [^](#cite_ref-FOOTNOTEArkkoHardiePaulyK\u00fchlewind20232.3._Protecting_Information_and_Authentication_93-0) [Arkko et al. 2023](#CITEREFArkkoHardiePaulyK\u00fchlewind2023), 2.3. Protecting Information and Authentication. [^](#cite_ref-FOOTNOTEArkkoHardiePaulyK\u00fchlewind20232.5._Limiting_Impact_of_Information_94-0) [Arkko et al. 2023](#CITEREFArkkoHardiePaulyK\u00fchlewind2023), 2.5. Limiting Impact of Information. [^](#cite_ref-FOOTNOTEArkkoHardiePaulyK\u00fchlewind20232.4._Minimize_Information_95-0) [Arkko et al. 2023](#CITEREFArkkoHardiePaulyK\u00fchlewind2023), 2.4. Minimize Information. [^](#cite_ref-FOOTNOTEArkkoHardiePaulyK\u00fchlewind20232.6._Minimum_Set_of_Entities_96-0) [Arkko et al. 2023](#CITEREFArkkoHardiePaulyK\u00fchlewind2023), 2.6. Minimum Set of Entities. [^](#cite_ref-FOOTNOTEArkkoHardiePaulyK\u00fchlewind20233._Further_Work_97-0) [Arkko et al. 2023](#CITEREFArkkoHardiePaulyK\u00fchlewind2023), 3. Further Work. [^](#cite_ref-FOOTNOTEPapastergiouFairhurstRosBrunstrom2017619_98-0) [Papastergiou al. 2017](#CITEREFPapastergiouFairhurstRosBrunstrom2017), p. [^](#cite_ref-FOOTNOTEPapastergiouFairhurstRosBrunstrom2017620_99-0) [Papastergiou 2021](#CITEREFThomsonPauly2021), 3.5. Restoring Active Use. [^](#cite_ref-107)Comer 2000, Sect. 11.5.1 - The TCP/IP 5-Layer Reference Model, 183, same. [Radia Perlman](/wiki/Radia_Perlman)(1999). Interconnections: [0-201-63448-1](/wiki/Special:BookSources/0-201-63448-1).. In particular Ch. E. Comer](/wiki/Douglas_E._Comer)(2000). Internetworking with TCP/IP - Principles, Protocols and Architecture (4th ed.). Prentice Hall. [ISBN](/wiki/ISBN_(identifier)) [0-13-018380-6](/wiki/Special:BookSources/0-13-018380-6). In particular Ch.11 Protocol layering. Also has a RFC guide and a Glossary of Internetworking Terms and Abbreviations. [R. Braden](/wiki/Bob_Braden), ed. (1989). [Requirements for Internet Hosts -- Engineering abbr. of protocolsoftware. In particular the introduction gives an overview of the design goals of the suite. [M. Ben-ari](/wiki/M._Ben-Ari)(1982). Principles of concurrent programming (10th Print ed.). International. [ISBN](/wiki/ISBN_(identifier)) [0-13-701078-8](/wiki/Special:BookSources/0-13-701078-8). [C.A.R. Hoare](/wiki/Tony_Hoare)(1985). [0-13-153271-5](/wiki/Special:BookSources/0-13-153271-5). - R.D. Tennent (1981). Principles of programming languages (10th Print ed.). Prentice Hall International. [ISBN](/wiki/ISBN_(identifier)) [0-13-709873-1](/wiki/Special:BookSources/0-13-709873-1). - Brian W Marsden (1986). Communication network ed.). Chartwell Bratt. [ISBN](/wiki/ISBN_(identifier)) [0-86238-106-1](/wiki/Special:BookSources/0-86238-106-1). [Andrew S. Tanenbaum](/wiki/Andrew_S._Tanenbaum)(1984). Structured computer organization (10th Print ed.). Prentice Hall International. [ISBN](/wiki/ISBN_(identifier)) [0-13-854605-3](/wiki/Special:BookSources/0-13-854605-3). - Bryant, Stewart; Morrow, Monique, eds. [doi](/wiki/Doi_(identifier)): [10.17487/RFC8546](https://doi.org/10.17487%2FRFC8546). [RFC](/wiki/Request_for_Comments) [8546](https://datatracker.ietf.org/doc/html/rfc8546). - 2021). [Considerations around Transport Header Confidentiality, Network Operations, and the Evolution of Internet Transport Protocols](https://datatracker.ietf.org/doc/html/rfc9065). [doi](/wiki/Doi_(identifier)): [10.17487/RFC9065](https://doi.org/10.17487%2FRFC9065). 2016). Implementing Real-Time Transport Services over an Ossified Network. 2016 Applied Networking "}