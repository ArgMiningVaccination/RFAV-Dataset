{"title": "Protocols and structural subtyping#", "author": null, "url": null, "hostname": null, "description": null, "sitename": "mypy 1.5.1 documentation", "date": "2022-09-29", "cleaned_text": "Protocols and structural subtyping [#](#protocols-and-structural-subtyping) The Python type system supports two ways of deciding whether two objects are compatible as types: nominal subtyping and structural subtyping. Nominal subtyping is strictly based on the class hierarchy. If class Dog inherits class Animal, it's a subtype of Animal. Instances of Dog can be used when Animal instances are expected. This form of subtyping subtyping is what Python's type system predominantly uses: it's easy to understand and produces clear and concise error messages, and matches how the native [ check works - based on class hierarchy. isinstance](https://docs.python.org/3/library/functions.html#isinstance) Structural subtyping is based on the operations that can be performed with an object. Class Dog is a structural subtype of class Animal if the former has all attributes and methods of the latter, and with compatible types. Structural subtyping can be seen as a static equivalent of duck typing, which is well known to Python programmers. See [PEP 544](https://peps.python.org/pep-0544/) for the detailed specification of protocols and structural subtyping in Python. Predefined protocols [#](#predefined-protocols) The [ module defines various protocol classes that correspond to common Python protocols, such as typing](https://docs.python.org/3/library/typing.html#module-typing) [. If a class defines a suitable](https://docs.python.org/3/library/typing.html#typing.Iterable) Iterable[T] [method, mypy understands that it implements the iterable is compatible with](https://docs.python.org/3/reference/datamodel.html#object.__iter__) __iter__ [. For example,](https://docs.python.org/3/library/typing.html#typing.Iterable) 1, x) x = IntList(3, IntList(5, None)) print_numbered(x) # OK print_numbered([4, 5]) # Also OK [Predefined protocol reference](#predefined-protocols-reference) lists all protocols defined in [ and the signatures of the corresponding methods you need to define to implement each protocol. typing](https://docs.python.org/3/library/typing.html#module-typing) Simple user-defined protocols [#](#simple-user-defined-protocols) You can define your own protocol class by inheriting the special Protocol class: from typing import Iterable from typing_extensions import Protocol class SupportsClose(Protocol): # OK Resource is a subtype of the SupportsClose protocol since it defines a compatible close method. Regular file objects returned by [ are similarly compatible with the protocol, as they support open()](https://docs.python.org/3/library/functions.html#open) close(). Defining subprotocols and subclassing protocols [#](#defining-subprotocols-and-subclassing-protocols) You can also define subprotocols. Existing protocols can be extended and merged using multiple inheritance. Example: # ... continuing from the previous = AdvancedResource('handle with care') # OK Note that inheriting from an existing protocol does not automatically turn the subclass into a protocol - it just creates a regular (non-protocol) class or ABC that implements the given protocol (or protocols). The Protocol base class must always be explicitly present if you are defining a protocol: class NotAProtocol(SupportsClose): # This is NOT a protocol new_attr: int class new_attr: x: NotAProtocol = Concrete() # Error! You can also include default implementations of methods in protocols. If you explicitly subclass these protocols you can inherit these default implementations. Explicitly including a protocol as a base class is also a way of documenting that your class implements a particular protocol, and it forces mypy to verify that your class implementation is actually compatible with the protocol. In particular, omitting a value for an attribute or a method body will make it implicitly abstract: class SomeProto(Protocol): attr: int # Note, no right hand def method(self) -> str: ... # ExplicitSubclass() # error: Cannot instantiate abstract class 'ExplicitSubclass' # with abstract attributes 'attr' and 'method' Similarly, explicitly assigning to a protocol instance can be a way to ask the type checker to verify that your class implements a protocol: _proto: SomeProto = cast(ExplicitSubclass, None) Invariance of protocol attributes [#](#invariance-of-protocol-attributes) A common issue with protocols is that protocol attributes are invariant. For example: class Box(Protocol): \"IntBox\"; expected \"Box\" # content: expected \"object\", got \"int\" This is because Box defines content as a mutable attribute. Here's why this = \"asdf\" # This is bad, since box.content is supposed to be an object my_int_box = IntBox() takes_box_evil(my_int_box) my_int_box.content + 1 # Oops, TypeError! This can be fixed by declaring content to be read-only in the Box protocol Recursive protocols [#](#recursive-protocols) Protocols can be recursive (self-referential) and mutually recursive. This is useful for declaring abstract recursive collections such as trees and linked lists: from typing import TypeVar, Optional from typing_extensions root: SimpleTree(0) # OK Using isinstance() with protocols [#](#using-isinstance-with-protocols) You can use a protocol class with [ if you decorate it with the isinstance()](https://docs.python.org/3/library/functions.html#isinstance) @runtime_checkableclass decorator. The decorator adds rudimentary support for runtime structural checks: from typing_extensions import Portable): # Works at runtime! use(mug.handles) as](https://docs.python.org/3/library/typing.html#module-typing) typing [.](https://docs.python.org/3/library/typing.html#typing.Iterable) Iterable Warning [ with protocols is not completely safe at runtime. For example, signatures of methods are not checked. The runtime implementation only checks that all protocol members exist, not that they have the correct type. isinstance()](https://docs.python.org/3/library/functions.html#isinstance) [with protocols will only check for the existence of methods.](https://docs.python.org/3/library/functions.html#issubclass) issubclass() Note [ with protocols can also be surprisingly slow. In many cases, you're better served by using isinstance()](https://docs.python.org/3/library/functions.html#isinstance) [to check for the presence of attributes.](https://docs.python.org/3/library/functions.html#hasattr) hasattr() Callback protocols [#](#callback-protocols) Protocols can be used to define flexible callback types that are hard (or even impossible) to express using the [ syntax, such as variadic, overloaded, and complex generic callbacks. They are defined with a special Callable[...]](https://docs.python.org/3/library/typing.html#typing.Callable) [member:](https://docs.python.org/3/reference/datamodel.html#object.__call__) __call__ from typing import Optional, Error! Argument 2 has incompatible type because of # different name and kind in the callback Callback protocols and [ types can be used mostly interchangeably. Argument names in Callable](https://docs.python.org/3/library/typing.html#typing.Callable) [methods must be identical, unless a double underscore prefix is used. For example:](https://docs.python.org/3/reference/datamodel.html#object.__call__) __call__ from typing import Callable, TypeVar from typing_extensions copy_a # Also OK Predefined protocol reference [#](#predefined-protocol-reference) Iteration protocols [#](#iteration-protocols) The iteration protocols are useful in many contexts. For example, they allow iteration of objects in for loops. Iterable[T] [#](#iterable-t) The [example above](#predefined-protocols) has a simple [ method. Iterator](https://docs.python.org/3/library/typing.html#typing.Iterator) Collection protocols [#](#collection-protocols) Many of these are implemented by built-in container types such as [ and list](https://docs.python.org/3/library/stdtypes.html#list) [, and these are also useful for user-defined collection objects.](https://docs.python.org/3/library/stdtypes.html#dict) dict Sized [#](#sized) This is a type for objects that support [. len(x)](https://docs.python.org/3/library/functions.html#len) def __len__(self) -> int See also [. Sized](https://docs.python.org/3/library/typing.html#typing.Sized) Container[T] [#](#container-t) This is a type for objects that support the in operator. def __contains__(self, x: One-off protocols [#](#one-off-protocols) These protocols are typically only useful with a single standard library function or class. Reversible[T] [#](#reversible-t) This is a type for objects that support [. reversed(x)](https://docs.python.org/3/library/functions.html#reversed) def __reversed__(self) -> Iterator[T] See also [. Reversible](https://docs.python.org/3/library/typing.html#typing.Reversible) SupportsAbs[T] [#](#supportsabs-t) This is a type for objects that support [. abs(x)](https://docs.python.org/3/library/functions.html#abs) Tis the type of value returned by [.](https://docs.python.org/3/library/functions.html#abs) abs(x) __abs__(self) -> T See also [. SupportsAbs](https://docs.python.org/3/library/typing.html#typing.SupportsAbs) SupportsBytes [#](#supportsbytes) This is a type for objects that support [. bytes(x)](https://docs.python.org/3/library/stdtypes.html#bytes) def __bytes__(self) -> bytes See also [. SupportsBytes](https://docs.python.org/3/library/typing.html#typing.SupportsBytes) SupportsComplex [#](#supportscomplex) This is a type for objects that support [. Note that no arithmetic operations are supported. complex(x)](https://docs.python.org/3/library/functions.html#complex) def __complex__(self) -> complex See also [. SupportsComplex](https://docs.python.org/3/library/typing.html#typing.SupportsComplex) SupportsFloat [#](#supportsfloat) This is a type for objects that support [. Note that no arithmetic operations are supported. float(x)](https://docs.python.org/3/library/functions.html#float) def __float__(self) -> float See also [. SupportsFloat](https://docs.python.org/3/library/typing.html#typing.SupportsFloat) SupportsInt [#](#supportsint) This is a type for objects that support [. Note that no arithmetic operations are supported. int(x)](https://docs.python.org/3/library/functions.html#int) def __int__(self) -> int See also [. SupportsInt](https://docs.python.org/3/library/typing.html#typing.SupportsInt) SupportsRound[T] [#](#supportsround-t) This is a type for objects that support [. round(x)](https://docs.python.org/3/library/functions.html#round) def __round__(self) -> T See also [. SupportsRound](https://docs.python.org/3/library/typing.html#typing.SupportsRound) Async protocols [#](#async-protocols) These protocols can be useful in async code. See Context manager protocols [#](#context-manager-protocols) There are two protocols for context managers - one for regular context managers and one for async ones. These allow defining objects that can be used in with and async with "}