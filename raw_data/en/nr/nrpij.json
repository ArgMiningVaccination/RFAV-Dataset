{"title": "Homomorphic Encryption Random Beacon (HERB)", "author": "Corestar", "url": "https://medium.com/@corestar/homomorphic-encryption-random-beacon-herb-e299d894ad66", "hostname": "medium.com", "description": "Corestar (formerly a team behind DGaming, focused on research and development of blockhains in Cosmos ecosystem, such as Arcade (a...", "sitename": "Medium", "date": "2019-11-18", "cleaned_text": "[DGaming](https://github.com/corestario/dcr-docs/blob/master/Random%20posts/dgaming.com), focused on research and development of blockhains in Cosmos ecosystem, such as [Arcade](https://github.com/corestario/tendermint) (a Tendermint variant with a built-in random beacon) and [Open Market](https://github.com/corestario/dcr-docs/blob/master/Random%20posts/openmarket.one) (NFT marketplace for Cosmos) is delighted to introduce the Homomorphic Encryption Randomness Beacon (HERB). HERB a protocol geared for the continuous provision of publicly verifiable randomness in a distributed manner. The detailed paper, along with the security proofs, is presented [here](https://eprint.iacr.org/2019/1320.pdf). The paper is done in collaboration with [Omer Shlomovits](https://twitter.com/omershlomovits), co-founder [ZenGo](https://zengo.com/) and member of the [KZen Research](https://zengo.com/research/) group. In this article we will provide a brief overview of HERB and then explain the details. Brief Overview HERB is a publicly verifiable randomness beacon based on the additively homomorphic property of some encryption schemes. The randomness beacon is a cryptographic primitive that regularly outputs an unbiasable, unpredictable random number that is available and verifiable by any party. The numbers may be used for blockchain sharding, gambling, advanced cryptographic schemes, and any other medium one would want a publicly verifiable random number for. There are multiple cryptographic schemes to make a decentralized random beacon. Unlike the most well-known [Dfinity'](https://dfinity.org/pdf-viewer/pdfs/viewer?file=..%2Flibrary%2Fdfinity-consensus.pdf)s deterministic approach, each new HERB's output is generated as a new random value derived from the participants' randomness sources allowing for physical sources of entropy. This property allows using HERB for seeding and reseeding such schemes as Dfinity's BLS-based beacon. Another strong point is that HERB requires less cryptographic assumptions, such as the bilinear pairings. Our protocol requires performing a distributed key generation protocol before the main generation phase. The distributed key generation protocol is carried out once. Another of HERB's drawbacks is the relatively high communication complexity (O(n\u00b3)), or an additional requirement to use a public blockchain. HERB provides an interesting option for its applications. Parties that provide randomness sources and parties calculating the protocol's output can be two different sets of participants, thus potentially reducing communication overheads. We implemented the [ Proof-of-Concept](https://github.com/corestario/HERB) using the [ Kyber](https://github.com/dedis/kyber) library and [Cosmos SDK](https://github.com/cosmos/cosmos-sdk). A random number generation is taking around 4.1 seconds for one random output with a (67, 100)-threshold encryption scheme. The results of testing are presented in the figure below. Detailed information about the proof-of-concept is presented in the original paper. HERB can also be implemented on Ethereum or any other blockchain with a smart contract system. Protocol Description First of all, what is a randomness beacon? For a third-party, a randomness beacon looks like a black box, which publishes random numbers at some time intervals.It may be used for different purposes: blockchain sharding, leader elections in cryptographic protocols, gaming, gambling, etc. There is a good [article](/mixbytes/random-numbers-and-decentralized-networks-practical-application-ce416d90976b) about the practical application of random numbers in the decentralized networks. Let us define several key security properties for a good randomness beacon: - Availability (or liveness) \u2014 an adversary cannot prevent a random number generation process. - Unpredictability \u2014 an adversary cannot predict the protocol outcome (a random value). - Unbiasability (or bias-resistance) \u2014 an adversary cannot influence future random beacon values to their advantage. - Public-Verifiability \u2014 anyone can verify the protocol's outcome. HERB complies with all these properties. It is not the only up-to-date protocol for the distributed random number generation. Other solutions and a comparison between HERB and the other solutions are presented in the [original document](https://eprint.iacr.org/2019/1320.pdf). In this article, we are only focused on HERB. Before describing the protocol, we need to discuss what homomorphic property means for an encryption scheme. Assume, we have two messages: m_1 and m_2. Enc and Dec are encryption respectively. C_1 = Enc(m_1), other a cryptosystem is additively homomorphic if it allows summing messages without decryption. We can use this property for the random generation process. But first, let us recall the Commit-and-Reveal pattern. It is a common solution for random data generation in a distributed manner. It can be divided into three stages: - \"Commit\" \u2014 all parties broadcast hashes of their random shares. - \"Reveal\" \u2014 all parties broadcast original random shares. - \"Aggregation\" \u2014 a participant willing to get protocol outcome verifies that every party sent the correct hash at the first step and then aggregates all the shares in some way (e.g. with XOR function). A well-known problem is that the parties can refuse to reveal their shares. This allows for manipulating the protocol's outcome. There are several methods for reducing the possibility of such manipulation, for instance including additional input data (block hash from PoW blockchain) or setting penalties for dishonest parties. But these methods cannot eliminate the problem. This is where the homomorphic property comes in to give us a hand. We can aggregate \"commits\" before the \"reveal\" stage. In this case, an adversary cannot bias the output value. We need to replace a hash-function with homomorphic encryption function and we'll get simplified HERB protocol: - \"Commit\" \u2014 all parties encrypt their random shares and broadcast them. - \"Aggregation\" \u2014 calculating the sum of all encrypted shares. - \"Reveal\" \u2014 all parties jointly decrypt the aggregated encrypted value. HERB uses (t, n) \u2014 threshold cryptosystem. It means that there are n participants and any subset of size greater than t can decrypt an encrypted value. To achieve that, each of the t participants sends the decryption share to the others. Than, all decryption shares are aggregated using the Lagrange interpolation and the obtained value can be used to decrypt the ciphertext by any third party. We denote decryption share as D_i. We suggest as the default encryption scheme. However, the homomorphic property introduces a serious drawback to the cryptosystem: it makes the cryptosystem malleable. For the given C = Enc(m), it is feasible to compute C'=Enc(f(m)), where f is a nontrivial function and C' C. So, the adversary that is the last to publish their random share can send a \"fake\" commit to bias the protocol's output. We can avoid this by using the non-interactive zero-knowledge proofs (NIZKs). A NIZK restricts the parties and makes them send only the correct encrypted values. Malleability allows an adversary to create an encrypted share that changes the protocol's output to one desirable for the adversary. However, in this case, the adversary does not know which value is encrypted in the share they sent. Any participant can create the correct NIZK only if they know the encrypted value, in the opposite case, the NIZK turns into an unsolvable math puzzle. That is why non-interactive zero-knowledge proofs help us avoid malleability of an encryption function. Detailed information about the NIZKs used in HERB is presented in the original article. For simplicity, we do not present the algorithm for the generation of the NIZKs in this post and assume that any honest participant can create a correct proof for their random share. Now we can present the HERB protocol. Note that we can instantiate HERB in two different manners: with a public blockchain, or with a BFT consensus algorithm. For simplicity, we have only presented the public blockchain version in this material. Suppose the chosen public blockchain can run arbitrary logic via a smart contract system. - Each party calculates an encrypted share C_i, a NIZK proof p_i and sends them to the smart contract. - The smart contract verifies all the encrypted shares and proofs. When t shares were verified, the smart contract aggregates common value C = C_1 + C_2 + ... + C_t. - Each party sends a decryption share D_i and NIZK proof p'_i to the smart contract. - As soon as t decryption shares were sent, the smart contract calculates a new random value R = Dec(C). Assume that there are three participants: Alice, Bob, and Carol. They use (2, 3)-threshold homomorphic encryption. The figure below shows the HERB protocol for them. Note that all the participants have sent the encrypted values. However, two out of three would be sufficient (e.g. C_A and C_B). Several more interesting things about HERB: - HERB does not require bilinear pairings and requires only EC-DDH-assumption for the default settings. - The protocol can be modified for usage in the post-quantum model. - The first and the third steps can be executed by different groups of participants. For example, lottery participants can send random shares and a group of semi-trusted lottery initiators can decrypt the result. - Given that each participant encrypts their own random value, they can be sure of the quality of the randomness source. "}